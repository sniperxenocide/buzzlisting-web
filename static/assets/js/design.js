/******/
(function (modules) { // webpackBootstrap
    /******/ 	// The module cache
    /******/
    var installedModules = {};

    /******/ 	// The require function
    /******/
    function __webpack_require__(moduleId) {

        /******/ 		// Check if module is in cache
        /******/
        if (installedModules[moduleId])
        /******/            return installedModules[moduleId].exports;

        /******/ 		// Create a new module (and put it into the cache)
        /******/
        var module = installedModules[moduleId] = {
            /******/            i: moduleId,
            /******/            l: false,
            /******/            exports: {}
            /******/
        };

        /******/ 		// Execute the module function
        /******/
        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

        /******/ 		// Flag the module as loaded
        /******/
        module.l = true;

        /******/ 		// Return the exports of the module
        /******/
        return module.exports;
        /******/
    }


    /******/ 	// expose the modules object (__webpack_modules__)
    /******/
    __webpack_require__.m = modules;

    /******/ 	// expose the module cache
    /******/
    __webpack_require__.c = installedModules;

    /******/ 	// identity function for calling harmory imports with the correct context
    /******/
    __webpack_require__.i = function (value) {
        return value;
    };

    /******/ 	// define getter function for harmory exports
    /******/
    __webpack_require__.d = function (exports, name, getter) {
        /******/
        Object.defineProperty(exports, name, {
            /******/            configurable: false,
            /******/            enumerable: true,
            /******/            get: getter
            /******/
        });
        /******/
    };

    /******/ 	// getDefaultExport function for compatibility with non-harmony modules
    /******/
    __webpack_require__.n = function (module) {
        /******/
        var getter = module && module.__esModule ?
            /******/            function getDefault() {
                return module['default'];
            } :
            /******/            function getModuleExports() {
                return module;
            };
        /******/
        __webpack_require__.d(getter, 'a', getter);
        /******/
        return getter;
        /******/
    };

    /******/ 	// Object.prototype.hasOwnProperty.call
    /******/
    __webpack_require__.o = function (object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
    };

    /******/ 	// __webpack_public_path__
    /******/
    __webpack_require__.p = "";

    /******/ 	// Load entry module and return exports
    /******/
    return __webpack_require__(__webpack_require__.s = 119);
    /******/
})
/************************************************************************/
/******/([
    /* 0 */
    /***/ function (module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */
        (function (module) {//! moment.js
//! version : 2.17.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

            ;(function (global, factory) {
                true ? module.exports = factory() :
                    typeof define === 'function' && define.amd ? define(factory) :
                        global.moment = factory()
            }(this, (function () {
                'use strict';

                var hookCallback;

                function hooks() {
                    return hookCallback.apply(null, arguments);
                }

// This is done to register the method called with moment()
// without creating circular dependencies.
                function setHookCallback(callback) {
                    hookCallback = callback;
                }

                function isArray(input) {
                    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
                }

                function isObject(input) {
                    // IE8 will treat undefined and null as object if it wasn't for
                    // input != null
                    return input != null && Object.prototype.toString.call(input) === '[object Object]';
                }

                function isObjectEmpty(obj) {
                    var k;
                    for (k in obj) {
                        // even if its not own property I'd still call it non-empty
                        return false;
                    }
                    return true;
                }

                function isNumber(input) {
                    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
                }

                function isDate(input) {
                    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
                }

                function map(arr, fn) {
                    var res = [], i;
                    for (i = 0; i < arr.length; ++i) {
                        res.push(fn(arr[i], i));
                    }
                    return res;
                }

                function hasOwnProp(a, b) {
                    return Object.prototype.hasOwnProperty.call(a, b);
                }

                function extend(a, b) {
                    for (var i in b) {
                        if (hasOwnProp(b, i)) {
                            a[i] = b[i];
                        }
                    }

                    if (hasOwnProp(b, 'toString')) {
                        a.toString = b.toString;
                    }

                    if (hasOwnProp(b, 'valueOf')) {
                        a.valueOf = b.valueOf;
                    }

                    return a;
                }

                function createUTC(input, format, locale, strict) {
                    return createLocalOrUTC(input, format, locale, strict, true).utc();
                }

                function defaultParsingFlags() {
                    // We need to deep clone this object.
                    return {
                        empty: false,
                        unusedTokens: [],
                        unusedInput: [],
                        overflow: -2,
                        charsLeftOver: 0,
                        nullInput: false,
                        invalidMonth: null,
                        invalidFormat: false,
                        userInvalidated: false,
                        iso: false,
                        parsedDateParts: [],
                        meridiem: null
                    };
                }

                function getParsingFlags(m) {
                    if (m._pf == null) {
                        m._pf = defaultParsingFlags();
                    }
                    return m._pf;
                }

                var some;
                if (Array.prototype.some) {
                    some = Array.prototype.some;
                } else {
                    some = function (fun) {
                        var t = Object(this);
                        var len = t.length >>> 0;

                        for (var i = 0; i < len; i++) {
                            if (i in t && fun.call(this, t[i], i, t)) {
                                return true;
                            }
                        }

                        return false;
                    };
                }

                var some$1 = some;

                function isValid(m) {
                    if (m._isValid == null) {
                        var flags = getParsingFlags(m);
                        var parsedParts = some$1.call(flags.parsedDateParts, function (i) {
                            return i != null;
                        });
                        var isNowValid = !isNaN(m._d.getTime()) &&
                            flags.overflow < 0 &&
                            !flags.empty &&
                            !flags.invalidMonth &&
                            !flags.invalidWeekday &&
                            !flags.nullInput &&
                            !flags.invalidFormat &&
                            !flags.userInvalidated &&
                            (!flags.meridiem || (flags.meridiem && parsedParts));

                        if (m._strict) {
                            isNowValid = isNowValid &&
                                flags.charsLeftOver === 0 &&
                                flags.unusedTokens.length === 0 &&
                                flags.bigHour === undefined;
                        }

                        if (Object.isFrozen == null || !Object.isFrozen(m)) {
                            m._isValid = isNowValid;
                        }
                        else {
                            return isNowValid;
                        }
                    }
                    return m._isValid;
                }

                function createInvalid(flags) {
                    var m = createUTC(NaN);
                    if (flags != null) {
                        extend(getParsingFlags(m), flags);
                    }
                    else {
                        getParsingFlags(m).userInvalidated = true;
                    }

                    return m;
                }

                function isUndefined(input) {
                    return input === void 0;
                }

// Plugins that add properties should also add the key here (null value),
// so we can properly clone ourselves.
                var momentProperties = hooks.momentProperties = [];

                function copyConfig(to, from) {
                    var i, prop, val;

                    if (!isUndefined(from._isAMomentObject)) {
                        to._isAMomentObject = from._isAMomentObject;
                    }
                    if (!isUndefined(from._i)) {
                        to._i = from._i;
                    }
                    if (!isUndefined(from._f)) {
                        to._f = from._f;
                    }
                    if (!isUndefined(from._l)) {
                        to._l = from._l;
                    }
                    if (!isUndefined(from._strict)) {
                        to._strict = from._strict;
                    }
                    if (!isUndefined(from._tzm)) {
                        to._tzm = from._tzm;
                    }
                    if (!isUndefined(from._isUTC)) {
                        to._isUTC = from._isUTC;
                    }
                    if (!isUndefined(from._offset)) {
                        to._offset = from._offset;
                    }
                    if (!isUndefined(from._pf)) {
                        to._pf = getParsingFlags(from);
                    }
                    if (!isUndefined(from._locale)) {
                        to._locale = from._locale;
                    }

                    if (momentProperties.length > 0) {
                        for (i in momentProperties) {
                            prop = momentProperties[i];
                            val = from[prop];
                            if (!isUndefined(val)) {
                                to[prop] = val;
                            }
                        }
                    }

                    return to;
                }

                var updateInProgress = false;

// Moment prototype object
                function Moment(config) {
                    copyConfig(this, config);
                    this._d = new Date(config._d != null ? config._d.getTime() : NaN);
                    if (!this.isValid()) {
                        this._d = new Date(NaN);
                    }
                    // Prevent infinite loop in case updateOffset creates new moment
                    // objects.
                    if (updateInProgress === false) {
                        updateInProgress = true;
                        hooks.updateOffset(this);
                        updateInProgress = false;
                    }
                }

                function isMoment(obj) {
                    return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
                }

                function absFloor(number) {
                    if (number < 0) {
                        // -0 -> 0
                        return Math.ceil(number) || 0;
                    } else {
                        return Math.floor(number);
                    }
                }

                function toInt(argumentForCoercion) {
                    var coercedNumber = +argumentForCoercion,
                        value = 0;

                    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
                        value = absFloor(coercedNumber);
                    }

                    return value;
                }

// compare two arrays, return the number of differences
                function compareArrays(array1, array2, dontConvert) {
                    var len = Math.min(array1.length, array2.length),
                        lengthDiff = Math.abs(array1.length - array2.length),
                        diffs = 0,
                        i;
                    for (i = 0; i < len; i++) {
                        if ((dontConvert && array1[i] !== array2[i]) ||
                            (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                            diffs++;
                        }
                    }
                    return diffs + lengthDiff;
                }

                function warn(msg) {
                    if (hooks.suppressDeprecationWarnings === false &&
                        (typeof console !== 'undefined') && console.warn) {
                        console.warn('Deprecation warning: ' + msg);
                    }
                }

                function deprecate(msg, fn) {
                    var firstTime = true;

                    return extend(function () {
                        if (hooks.deprecationHandler != null) {
                            hooks.deprecationHandler(null, msg);
                        }
                        if (firstTime) {
                            var args = [];
                            var arg;
                            for (var i = 0; i < arguments.length; i++) {
                                arg = '';
                                if (typeof arguments[i] === 'object') {
                                    arg += '\n[' + i + '] ';
                                    for (var key in arguments[0]) {
                                        arg += key + ': ' + arguments[0][key] + ', ';
                                    }
                                    arg = arg.slice(0, -2); // Remove trailing comma and space
                                } else {
                                    arg = arguments[i];
                                }
                                args.push(arg);
                            }
                            warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
                            firstTime = false;
                        }
                        return fn.apply(this, arguments);
                    }, fn);
                }

                var deprecations = {};

                function deprecateSimple(name, msg) {
                    if (hooks.deprecationHandler != null) {
                        hooks.deprecationHandler(name, msg);
                    }
                    if (!deprecations[name]) {
                        warn(msg);
                        deprecations[name] = true;
                    }
                }

                hooks.suppressDeprecationWarnings = false;
                hooks.deprecationHandler = null;

                function isFunction(input) {
                    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
                }

                function set(config) {
                    var prop, i;
                    for (i in config) {
                        prop = config[i];
                        if (isFunction(prop)) {
                            this[i] = prop;
                        } else {
                            this['_' + i] = prop;
                        }
                    }
                    this._config = config;
                    // Lenient ordinal parsing accepts just a number in addition to
                    // number + (possibly) stuff coming from _ordinalParseLenient.
                    this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
                }

                function mergeConfigs(parentConfig, childConfig) {
                    var res = extend({}, parentConfig), prop;
                    for (prop in childConfig) {
                        if (hasOwnProp(childConfig, prop)) {
                            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                                res[prop] = {};
                                extend(res[prop], parentConfig[prop]);
                                extend(res[prop], childConfig[prop]);
                            } else if (childConfig[prop] != null) {
                                res[prop] = childConfig[prop];
                            } else {
                                delete res[prop];
                            }
                        }
                    }
                    for (prop in parentConfig) {
                        if (hasOwnProp(parentConfig, prop) &&
                            !hasOwnProp(childConfig, prop) &&
                            isObject(parentConfig[prop])) {
                            // make sure changes to properties don't modify parent config
                            res[prop] = extend({}, res[prop]);
                        }
                    }
                    return res;
                }

                function Locale(config) {
                    if (config != null) {
                        this.set(config);
                    }
                }

                var keys;

                if (Object.keys) {
                    keys = Object.keys;
                } else {
                    keys = function (obj) {
                        var i, res = [];
                        for (i in obj) {
                            if (hasOwnProp(obj, i)) {
                                res.push(i);
                            }
                        }
                        return res;
                    };
                }

                var keys$1 = keys;

                var defaultCalendar = {
                    sameDay: '[Today at] LT',
                    nextDay: '[Tomorrow at] LT',
                    nextWeek: 'dddd [at] LT',
                    lastDay: '[Yesterday at] LT',
                    lastWeek: '[Last] dddd [at] LT',
                    sameElse: 'L'
                };

                function calendar(key, mom, now) {
                    var output = this._calendar[key] || this._calendar['sameElse'];
                    return isFunction(output) ? output.call(mom, now) : output;
                }

                var defaultLongDateFormat = {
                    LTS: 'h:mm:ss A',
                    LT: 'h:mm A',
                    L: 'MM/DD/YYYY',
                    LL: 'MMMM D, YYYY',
                    LLL: 'MMMM D, YYYY h:mm A',
                    LLLL: 'dddd, MMMM D, YYYY h:mm A'
                };

                function longDateFormat(key) {
                    var format = this._longDateFormat[key],
                        formatUpper = this._longDateFormat[key.toUpperCase()];

                    if (format || !formatUpper) {
                        return format;
                    }

                    this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
                        return val.slice(1);
                    });

                    return this._longDateFormat[key];
                }

                var defaultInvalidDate = 'Invalid date';

                function invalidDate() {
                    return this._invalidDate;
                }

                var defaultOrdinal = '%d';
                var defaultOrdinalParse = /\d{1,2}/;

                function ordinal(number) {
                    return this._ordinal.replace('%d', number);
                }

                var defaultRelativeTime = {
                    future: 'in %s',
                    past: '%s ago',
                    s: 'a few seconds',
                    m: 'a minute',
                    mm: '%d minutes',
                    h: 'an hour',
                    hh: '%d hours',
                    d: 'a day',
                    dd: '%d days',
                    M: 'a month',
                    MM: '%d months',
                    y: 'a year',
                    yy: '%d years'
                };

                function relativeTime(number, withoutSuffix, string, isFuture) {
                    var output = this._relativeTime[string];
                    return (isFunction(output)) ?
                        output(number, withoutSuffix, string, isFuture) :
                        output.replace(/%d/i, number);
                }

                function pastFuture(diff, output) {
                    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
                    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
                }

                var aliases = {};

                function addUnitAlias(unit, shorthand) {
                    var lowerCase = unit.toLowerCase();
                    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
                }

                function normalizeUnits(units) {
                    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
                }

                function normalizeObjectUnits(inputObject) {
                    var normalizedInput = {},
                        normalizedProp,
                        prop;

                    for (prop in inputObject) {
                        if (hasOwnProp(inputObject, prop)) {
                            normalizedProp = normalizeUnits(prop);
                            if (normalizedProp) {
                                normalizedInput[normalizedProp] = inputObject[prop];
                            }
                        }
                    }

                    return normalizedInput;
                }

                var priorities = {};

                function addUnitPriority(unit, priority) {
                    priorities[unit] = priority;
                }

                function getPrioritizedUnits(unitsObj) {
                    var units = [];
                    for (var u in unitsObj) {
                        units.push({unit: u, priority: priorities[u]});
                    }
                    units.sort(function (a, b) {
                        return a.priority - b.priority;
                    });
                    return units;
                }

                function makeGetSet(unit, keepTime) {
                    return function (value) {
                        if (value != null) {
                            set$1(this, unit, value);
                            hooks.updateOffset(this, keepTime);
                            return this;
                        } else {
                            return get(this, unit);
                        }
                    };
                }

                function get(mom, unit) {
                    return mom.isValid() ?
                        mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
                }

                function set$1(mom, unit, value) {
                    if (mom.isValid()) {
                        mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
                    }
                }

// MOMENTS

                function stringGet(units) {
                    units = normalizeUnits(units);
                    if (isFunction(this[units])) {
                        return this[units]();
                    }
                    return this;
                }


                function stringSet(units, value) {
                    if (typeof units === 'object') {
                        units = normalizeObjectUnits(units);
                        var prioritized = getPrioritizedUnits(units);
                        for (var i = 0; i < prioritized.length; i++) {
                            this[prioritized[i].unit](units[prioritized[i].unit]);
                        }
                    } else {
                        units = normalizeUnits(units);
                        if (isFunction(this[units])) {
                            return this[units](value);
                        }
                    }
                    return this;
                }

                function zeroFill(number, targetLength, forceSign) {
                    var absNumber = '' + Math.abs(number),
                        zerosToFill = targetLength - absNumber.length,
                        sign = number >= 0;
                    return (sign ? (forceSign ? '+' : '') : '-') +
                        Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
                }

                var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

                var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

                var formatFunctions = {};

                var formatTokenFunctions = {};

// token:    'M'
// padded:   ['MM', 2]
// ordinal:  'Mo'
// callback: function () { this.month() + 1 }
                function addFormatToken(token, padded, ordinal, callback) {
                    var func = callback;
                    if (typeof callback === 'string') {
                        func = function () {
                            return this[callback]();
                        };
                    }
                    if (token) {
                        formatTokenFunctions[token] = func;
                    }
                    if (padded) {
                        formatTokenFunctions[padded[0]] = function () {
                            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
                        };
                    }
                    if (ordinal) {
                        formatTokenFunctions[ordinal] = function () {
                            return this.localeData().ordinal(func.apply(this, arguments), token);
                        };
                    }
                }

                function removeFormattingTokens(input) {
                    if (input.match(/\[[\s\S]/)) {
                        return input.replace(/^\[|\]$/g, '');
                    }
                    return input.replace(/\\/g, '');
                }

                function makeFormatFunction(format) {
                    var array = format.match(formattingTokens), i, length;

                    for (i = 0, length = array.length; i < length; i++) {
                        if (formatTokenFunctions[array[i]]) {
                            array[i] = formatTokenFunctions[array[i]];
                        } else {
                            array[i] = removeFormattingTokens(array[i]);
                        }
                    }

                    return function (mom) {
                        var output = '', i;
                        for (i = 0; i < length; i++) {
                            output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
                        }
                        return output;
                    };
                }

// format date using native date object
                function formatMoment(m, format) {
                    if (!m.isValid()) {
                        return m.localeData().invalidDate();
                    }

                    format = expandFormat(format, m.localeData());
                    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

                    return formatFunctions[format](m);
                }

                function expandFormat(format, locale) {
                    var i = 5;

                    function replaceLongDateFormatTokens(input) {
                        return locale.longDateFormat(input) || input;
                    }

                    localFormattingTokens.lastIndex = 0;
                    while (i >= 0 && localFormattingTokens.test(format)) {
                        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
                        localFormattingTokens.lastIndex = 0;
                        i -= 1;
                    }

                    return format;
                }

                var match1 = /\d/;            //       0 - 9
                var match2 = /\d\d/;          //      00 - 99
                var match3 = /\d{3}/;         //     000 - 999
                var match4 = /\d{4}/;         //    0000 - 9999
                var match6 = /[+-]?\d{6}/;    // -999999 - 999999
                var match1to2 = /\d\d?/;         //       0 - 99
                var match3to4 = /\d\d\d\d?/;     //     999 - 9999
                var match5to6 = /\d\d\d\d\d\d?/; //   99999 - 999999
                var match1to3 = /\d{1,3}/;       //       0 - 999
                var match1to4 = /\d{1,4}/;       //       0 - 9999
                var match1to6 = /[+-]?\d{1,6}/;  // -999999 - 999999

                var matchUnsigned = /\d+/;           //       0 - inf
                var matchSigned = /[+-]?\d+/;      //    -inf - inf

                var matchOffset = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
                var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

                var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

// any word (or two) characters or numbers including two/three word month in arabic.
// includes scottish gaelic two word and hyphenated months
                var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;


                var regexes = {};

                function addRegexToken(token, regex, strictRegex) {
                    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
                        return (isStrict && strictRegex) ? strictRegex : regex;
                    };
                }

                function getParseRegexForToken(token, config) {
                    if (!hasOwnProp(regexes, token)) {
                        return new RegExp(unescapeFormat(token));
                    }

                    return regexes[token](config._strict, config._locale);
                }

// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
                function unescapeFormat(s) {
                    return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
                        return p1 || p2 || p3 || p4;
                    }));
                }

                function regexEscape(s) {
                    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
                }

                var tokens = {};

                function addParseToken(token, callback) {
                    var i, func = callback;
                    if (typeof token === 'string') {
                        token = [token];
                    }
                    if (isNumber(callback)) {
                        func = function (input, array) {
                            array[callback] = toInt(input);
                        };
                    }
                    for (i = 0; i < token.length; i++) {
                        tokens[token[i]] = func;
                    }
                }

                function addWeekParseToken(token, callback) {
                    addParseToken(token, function (input, array, config, token) {
                        config._w = config._w || {};
                        callback(input, config._w, config, token);
                    });
                }

                function addTimeToArrayFromToken(token, input, config) {
                    if (input != null && hasOwnProp(tokens, token)) {
                        tokens[token](input, config._a, config, token);
                    }
                }

                var YEAR = 0;
                var MONTH = 1;
                var DATE = 2;
                var HOUR = 3;
                var MINUTE = 4;
                var SECOND = 5;
                var MILLISECOND = 6;
                var WEEK = 7;
                var WEEKDAY = 8;

                var indexOf;

                if (Array.prototype.indexOf) {
                    indexOf = Array.prototype.indexOf;
                } else {
                    indexOf = function (o) {
                        // I know
                        var i;
                        for (i = 0; i < this.length; ++i) {
                            if (this[i] === o) {
                                return i;
                            }
                        }
                        return -1;
                    };
                }

                var indexOf$1 = indexOf;

                function daysInMonth(year, month) {
                    return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
                }

// FORMATTING

                addFormatToken('M', ['MM', 2], 'Mo', function () {
                    return this.month() + 1;
                });

                addFormatToken('MMM', 0, 0, function (format) {
                    return this.localeData().monthsShort(this, format);
                });

                addFormatToken('MMMM', 0, 0, function (format) {
                    return this.localeData().months(this, format);
                });

// ALIASES

                addUnitAlias('month', 'M');

// PRIORITY

                addUnitPriority('month', 8);

// PARSING

                addRegexToken('M', match1to2);
                addRegexToken('MM', match1to2, match2);
                addRegexToken('MMM', function (isStrict, locale) {
                    return locale.monthsShortRegex(isStrict);
                });
                addRegexToken('MMMM', function (isStrict, locale) {
                    return locale.monthsRegex(isStrict);
                });

                addParseToken(['M', 'MM'], function (input, array) {
                    array[MONTH] = toInt(input) - 1;
                });

                addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
                    var month = config._locale.monthsParse(input, token, config._strict);
                    // if we didn't find a month name, mark the date as invalid.
                    if (month != null) {
                        array[MONTH] = month;
                    } else {
                        getParsingFlags(config).invalidMonth = input;
                    }
                });

// LOCALES

                var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
                var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');

                function localeMonths(m, format) {
                    if (!m) {
                        return this._months;
                    }
                    return isArray(this._months) ? this._months[m.month()] :
                        this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
                }

                var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');

                function localeMonthsShort(m, format) {
                    if (!m) {
                        return this._monthsShort;
                    }
                    return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
                        this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
                }

                function handleStrictParse(monthName, format, strict) {
                    var i, ii, mom, llc = monthName.toLocaleLowerCase();
                    if (!this._monthsParse) {
                        // this is not used
                        this._monthsParse = [];
                        this._longMonthsParse = [];
                        this._shortMonthsParse = [];
                        for (i = 0; i < 12; ++i) {
                            mom = createUTC([2000, i]);
                            this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
                            this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
                        }
                    }

                    if (strict) {
                        if (format === 'MMM') {
                            ii = indexOf$1.call(this._shortMonthsParse, llc);
                            return ii !== -1 ? ii : null;
                        } else {
                            ii = indexOf$1.call(this._longMonthsParse, llc);
                            return ii !== -1 ? ii : null;
                        }
                    } else {
                        if (format === 'MMM') {
                            ii = indexOf$1.call(this._shortMonthsParse, llc);
                            if (ii !== -1) {
                                return ii;
                            }
                            ii = indexOf$1.call(this._longMonthsParse, llc);
                            return ii !== -1 ? ii : null;
                        } else {
                            ii = indexOf$1.call(this._longMonthsParse, llc);
                            if (ii !== -1) {
                                return ii;
                            }
                            ii = indexOf$1.call(this._shortMonthsParse, llc);
                            return ii !== -1 ? ii : null;
                        }
                    }
                }

                function localeMonthsParse(monthName, format, strict) {
                    var i, mom, regex;

                    if (this._monthsParseExact) {
                        return handleStrictParse.call(this, monthName, format, strict);
                    }

                    if (!this._monthsParse) {
                        this._monthsParse = [];
                        this._longMonthsParse = [];
                        this._shortMonthsParse = [];
                    }

                    // TODO: add sorting
                    // Sorting makes sure if one month (or abbr) is a prefix of another
                    // see sorting in computeMonthsParse
                    for (i = 0; i < 12; i++) {
                        // make the regex if we don't have it already
                        mom = createUTC([2000, i]);
                        if (strict && !this._longMonthsParse[i]) {
                            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
                        }
                        if (!strict && !this._monthsParse[i]) {
                            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
                        }
                        // test the regex
                        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                            return i;
                        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                            return i;
                        } else if (!strict && this._monthsParse[i].test(monthName)) {
                            return i;
                        }
                    }
                }

// MOMENTS

                function setMonth(mom, value) {
                    var dayOfMonth;

                    if (!mom.isValid()) {
                        // No op
                        return mom;
                    }

                    if (typeof value === 'string') {
                        if (/^\d+$/.test(value)) {
                            value = toInt(value);
                        } else {
                            value = mom.localeData().monthsParse(value);
                            // TODO: Another silent failure?
                            if (!isNumber(value)) {
                                return mom;
                            }
                        }
                    }

                    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
                    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
                    return mom;
                }

                function getSetMonth(value) {
                    if (value != null) {
                        setMonth(this, value);
                        hooks.updateOffset(this, true);
                        return this;
                    } else {
                        return get(this, 'Month');
                    }
                }

                function getDaysInMonth() {
                    return daysInMonth(this.year(), this.month());
                }

                var defaultMonthsShortRegex = matchWord;

                function monthsShortRegex(isStrict) {
                    if (this._monthsParseExact) {
                        if (!hasOwnProp(this, '_monthsRegex')) {
                            computeMonthsParse.call(this);
                        }
                        if (isStrict) {
                            return this._monthsShortStrictRegex;
                        } else {
                            return this._monthsShortRegex;
                        }
                    } else {
                        if (!hasOwnProp(this, '_monthsShortRegex')) {
                            this._monthsShortRegex = defaultMonthsShortRegex;
                        }
                        return this._monthsShortStrictRegex && isStrict ?
                            this._monthsShortStrictRegex : this._monthsShortRegex;
                    }
                }

                var defaultMonthsRegex = matchWord;

                function monthsRegex(isStrict) {
                    if (this._monthsParseExact) {
                        if (!hasOwnProp(this, '_monthsRegex')) {
                            computeMonthsParse.call(this);
                        }
                        if (isStrict) {
                            return this._monthsStrictRegex;
                        } else {
                            return this._monthsRegex;
                        }
                    } else {
                        if (!hasOwnProp(this, '_monthsRegex')) {
                            this._monthsRegex = defaultMonthsRegex;
                        }
                        return this._monthsStrictRegex && isStrict ?
                            this._monthsStrictRegex : this._monthsRegex;
                    }
                }

                function computeMonthsParse() {
                    function cmpLenRev(a, b) {
                        return b.length - a.length;
                    }

                    var shortPieces = [], longPieces = [], mixedPieces = [],
                        i, mom;
                    for (i = 0; i < 12; i++) {
                        // make the regex if we don't have it already
                        mom = createUTC([2000, i]);
                        shortPieces.push(this.monthsShort(mom, ''));
                        longPieces.push(this.months(mom, ''));
                        mixedPieces.push(this.months(mom, ''));
                        mixedPieces.push(this.monthsShort(mom, ''));
                    }
                    // Sorting makes sure if one month (or abbr) is a prefix of another it
                    // will match the longer piece.
                    shortPieces.sort(cmpLenRev);
                    longPieces.sort(cmpLenRev);
                    mixedPieces.sort(cmpLenRev);
                    for (i = 0; i < 12; i++) {
                        shortPieces[i] = regexEscape(shortPieces[i]);
                        longPieces[i] = regexEscape(longPieces[i]);
                    }
                    for (i = 0; i < 24; i++) {
                        mixedPieces[i] = regexEscape(mixedPieces[i]);
                    }

                    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
                    this._monthsShortRegex = this._monthsRegex;
                    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
                    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
                }

// FORMATTING

                addFormatToken('Y', 0, 0, function () {
                    var y = this.year();
                    return y <= 9999 ? '' + y : '+' + y;
                });

                addFormatToken(0, ['YY', 2], 0, function () {
                    return this.year() % 100;
                });

                addFormatToken(0, ['YYYY', 4], 0, 'year');
                addFormatToken(0, ['YYYYY', 5], 0, 'year');
                addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

// ALIASES

                addUnitAlias('year', 'y');

// PRIORITIES

                addUnitPriority('year', 1);

// PARSING

                addRegexToken('Y', matchSigned);
                addRegexToken('YY', match1to2, match2);
                addRegexToken('YYYY', match1to4, match4);
                addRegexToken('YYYYY', match1to6, match6);
                addRegexToken('YYYYYY', match1to6, match6);

                addParseToken(['YYYYY', 'YYYYYY'], YEAR);
                addParseToken('YYYY', function (input, array) {
                    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
                });
                addParseToken('YY', function (input, array) {
                    array[YEAR] = hooks.parseTwoDigitYear(input);
                });
                addParseToken('Y', function (input, array) {
                    array[YEAR] = parseInt(input, 10);
                });

// HELPERS

                function daysInYear(year) {
                    return isLeapYear(year) ? 366 : 365;
                }

                function isLeapYear(year) {
                    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
                }

// HOOKS

                hooks.parseTwoDigitYear = function (input) {
                    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
                };

// MOMENTS

                var getSetYear = makeGetSet('FullYear', true);

                function getIsLeapYear() {
                    return isLeapYear(this.year());
                }

                function createDate(y, m, d, h, M, s, ms) {
                    //can't just apply() to create a date:
                    //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
                    var date = new Date(y, m, d, h, M, s, ms);

                    //the date constructor remaps years 0-99 to 1900-1999
                    if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
                        date.setFullYear(y);
                    }
                    return date;
                }

                function createUTCDate(y) {
                    var date = new Date(Date.UTC.apply(null, arguments));

                    //the Date.UTC function remaps years 0-99 to 1900-1999
                    if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
                        date.setUTCFullYear(y);
                    }
                    return date;
                }

// start-of-first-week - start-of-year
                function firstWeekOffset(year, dow, doy) {
                    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
                        fwd = 7 + dow - doy,
                        // first-week day local weekday -- which local weekday is fwd
                        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

                    return -fwdlw + fwd - 1;
                }

//http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
                function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
                    var localWeekday = (7 + weekday - dow) % 7,
                        weekOffset = firstWeekOffset(year, dow, doy),
                        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
                        resYear, resDayOfYear;

                    if (dayOfYear <= 0) {
                        resYear = year - 1;
                        resDayOfYear = daysInYear(resYear) + dayOfYear;
                    } else if (dayOfYear > daysInYear(year)) {
                        resYear = year + 1;
                        resDayOfYear = dayOfYear - daysInYear(year);
                    } else {
                        resYear = year;
                        resDayOfYear = dayOfYear;
                    }

                    return {
                        year: resYear,
                        dayOfYear: resDayOfYear
                    };
                }

                function weekOfYear(mom, dow, doy) {
                    var weekOffset = firstWeekOffset(mom.year(), dow, doy),
                        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
                        resWeek, resYear;

                    if (week < 1) {
                        resYear = mom.year() - 1;
                        resWeek = week + weeksInYear(resYear, dow, doy);
                    } else if (week > weeksInYear(mom.year(), dow, doy)) {
                        resWeek = week - weeksInYear(mom.year(), dow, doy);
                        resYear = mom.year() + 1;
                    } else {
                        resYear = mom.year();
                        resWeek = week;
                    }

                    return {
                        week: resWeek,
                        year: resYear
                    };
                }

                function weeksInYear(year, dow, doy) {
                    var weekOffset = firstWeekOffset(year, dow, doy),
                        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
                    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
                }

// FORMATTING

                addFormatToken('w', ['ww', 2], 'wo', 'week');
                addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

// ALIASES

                addUnitAlias('week', 'w');
                addUnitAlias('isoWeek', 'W');

// PRIORITIES

                addUnitPriority('week', 5);
                addUnitPriority('isoWeek', 5);

// PARSING

                addRegexToken('w', match1to2);
                addRegexToken('ww', match1to2, match2);
                addRegexToken('W', match1to2);
                addRegexToken('WW', match1to2, match2);

                addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
                    week[token.substr(0, 1)] = toInt(input);
                });

// HELPERS

// LOCALES

                function localeWeek(mom) {
                    return weekOfYear(mom, this._week.dow, this._week.doy).week;
                }

                var defaultLocaleWeek = {
                    dow: 0, // Sunday is the first day of the week.
                    doy: 6  // The week that contains Jan 1st is the first week of the year.
                };

                function localeFirstDayOfWeek() {
                    return this._week.dow;
                }

                function localeFirstDayOfYear() {
                    return this._week.doy;
                }

// MOMENTS

                function getSetWeek(input) {
                    var week = this.localeData().week(this);
                    return input == null ? week : this.add((input - week) * 7, 'd');
                }

                function getSetISOWeek(input) {
                    var week = weekOfYear(this, 1, 4).week;
                    return input == null ? week : this.add((input - week) * 7, 'd');
                }

// FORMATTING

                addFormatToken('d', 0, 'do', 'day');

                addFormatToken('dd', 0, 0, function (format) {
                    return this.localeData().weekdaysMin(this, format);
                });

                addFormatToken('ddd', 0, 0, function (format) {
                    return this.localeData().weekdaysShort(this, format);
                });

                addFormatToken('dddd', 0, 0, function (format) {
                    return this.localeData().weekdays(this, format);
                });

                addFormatToken('e', 0, 0, 'weekday');
                addFormatToken('E', 0, 0, 'isoWeekday');

// ALIASES

                addUnitAlias('day', 'd');
                addUnitAlias('weekday', 'e');
                addUnitAlias('isoWeekday', 'E');

// PRIORITY
                addUnitPriority('day', 11);
                addUnitPriority('weekday', 11);
                addUnitPriority('isoWeekday', 11);

// PARSING

                addRegexToken('d', match1to2);
                addRegexToken('e', match1to2);
                addRegexToken('E', match1to2);
                addRegexToken('dd', function (isStrict, locale) {
                    return locale.weekdaysMinRegex(isStrict);
                });
                addRegexToken('ddd', function (isStrict, locale) {
                    return locale.weekdaysShortRegex(isStrict);
                });
                addRegexToken('dddd', function (isStrict, locale) {
                    return locale.weekdaysRegex(isStrict);
                });

                addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
                    var weekday = config._locale.weekdaysParse(input, token, config._strict);
                    // if we didn't get a weekday name, mark the date as invalid
                    if (weekday != null) {
                        week.d = weekday;
                    } else {
                        getParsingFlags(config).invalidWeekday = input;
                    }
                });

                addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
                    week[token] = toInt(input);
                });

// HELPERS

                function parseWeekday(input, locale) {
                    if (typeof input !== 'string') {
                        return input;
                    }

                    if (!isNaN(input)) {
                        return parseInt(input, 10);
                    }

                    input = locale.weekdaysParse(input);
                    if (typeof input === 'number') {
                        return input;
                    }

                    return null;
                }

                function parseIsoWeekday(input, locale) {
                    if (typeof input === 'string') {
                        return locale.weekdaysParse(input) % 7 || 7;
                    }
                    return isNaN(input) ? null : input;
                }

// LOCALES

                var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');

                function localeWeekdays(m, format) {
                    if (!m) {
                        return this._weekdays;
                    }
                    return isArray(this._weekdays) ? this._weekdays[m.day()] :
                        this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
                }

                var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');

                function localeWeekdaysShort(m) {
                    return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
                }

                var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');

                function localeWeekdaysMin(m) {
                    return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
                }

                function handleStrictParse$1(weekdayName, format, strict) {
                    var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
                    if (!this._weekdaysParse) {
                        this._weekdaysParse = [];
                        this._shortWeekdaysParse = [];
                        this._minWeekdaysParse = [];

                        for (i = 0; i < 7; ++i) {
                            mom = createUTC([2000, 1]).day(i);
                            this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
                            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
                            this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
                        }
                    }

                    if (strict) {
                        if (format === 'dddd') {
                            ii = indexOf$1.call(this._weekdaysParse, llc);
                            return ii !== -1 ? ii : null;
                        } else if (format === 'ddd') {
                            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
                            return ii !== -1 ? ii : null;
                        } else {
                            ii = indexOf$1.call(this._minWeekdaysParse, llc);
                            return ii !== -1 ? ii : null;
                        }
                    } else {
                        if (format === 'dddd') {
                            ii = indexOf$1.call(this._weekdaysParse, llc);
                            if (ii !== -1) {
                                return ii;
                            }
                            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
                            if (ii !== -1) {
                                return ii;
                            }
                            ii = indexOf$1.call(this._minWeekdaysParse, llc);
                            return ii !== -1 ? ii : null;
                        } else if (format === 'ddd') {
                            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
                            if (ii !== -1) {
                                return ii;
                            }
                            ii = indexOf$1.call(this._weekdaysParse, llc);
                            if (ii !== -1) {
                                return ii;
                            }
                            ii = indexOf$1.call(this._minWeekdaysParse, llc);
                            return ii !== -1 ? ii : null;
                        } else {
                            ii = indexOf$1.call(this._minWeekdaysParse, llc);
                            if (ii !== -1) {
                                return ii;
                            }
                            ii = indexOf$1.call(this._weekdaysParse, llc);
                            if (ii !== -1) {
                                return ii;
                            }
                            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
                            return ii !== -1 ? ii : null;
                        }
                    }
                }

                function localeWeekdaysParse(weekdayName, format, strict) {
                    var i, mom, regex;

                    if (this._weekdaysParseExact) {
                        return handleStrictParse$1.call(this, weekdayName, format, strict);
                    }

                    if (!this._weekdaysParse) {
                        this._weekdaysParse = [];
                        this._minWeekdaysParse = [];
                        this._shortWeekdaysParse = [];
                        this._fullWeekdaysParse = [];
                    }

                    for (i = 0; i < 7; i++) {
                        // make the regex if we don't have it already

                        mom = createUTC([2000, 1]).day(i);
                        if (strict && !this._fullWeekdaysParse[i]) {
                            this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
                            this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
                            this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
                        }
                        if (!this._weekdaysParse[i]) {
                            regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                            this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
                        }
                        // test the regex
                        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                            return i;
                        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                            return i;
                        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                            return i;
                        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                            return i;
                        }
                    }
                }

// MOMENTS

                function getSetDayOfWeek(input) {
                    if (!this.isValid()) {
                        return input != null ? this : NaN;
                    }
                    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
                    if (input != null) {
                        input = parseWeekday(input, this.localeData());
                        return this.add(input - day, 'd');
                    } else {
                        return day;
                    }
                }

                function getSetLocaleDayOfWeek(input) {
                    if (!this.isValid()) {
                        return input != null ? this : NaN;
                    }
                    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
                    return input == null ? weekday : this.add(input - weekday, 'd');
                }

                function getSetISODayOfWeek(input) {
                    if (!this.isValid()) {
                        return input != null ? this : NaN;
                    }

                    // behaves the same as moment#day except
                    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
                    // as a setter, sunday should belong to the previous week.

                    if (input != null) {
                        var weekday = parseIsoWeekday(input, this.localeData());
                        return this.day(this.day() % 7 ? weekday : weekday - 7);
                    } else {
                        return this.day() || 7;
                    }
                }

                var defaultWeekdaysRegex = matchWord;

                function weekdaysRegex(isStrict) {
                    if (this._weekdaysParseExact) {
                        if (!hasOwnProp(this, '_weekdaysRegex')) {
                            computeWeekdaysParse.call(this);
                        }
                        if (isStrict) {
                            return this._weekdaysStrictRegex;
                        } else {
                            return this._weekdaysRegex;
                        }
                    } else {
                        if (!hasOwnProp(this, '_weekdaysRegex')) {
                            this._weekdaysRegex = defaultWeekdaysRegex;
                        }
                        return this._weekdaysStrictRegex && isStrict ?
                            this._weekdaysStrictRegex : this._weekdaysRegex;
                    }
                }

                var defaultWeekdaysShortRegex = matchWord;

                function weekdaysShortRegex(isStrict) {
                    if (this._weekdaysParseExact) {
                        if (!hasOwnProp(this, '_weekdaysRegex')) {
                            computeWeekdaysParse.call(this);
                        }
                        if (isStrict) {
                            return this._weekdaysShortStrictRegex;
                        } else {
                            return this._weekdaysShortRegex;
                        }
                    } else {
                        if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
                        }
                        return this._weekdaysShortStrictRegex && isStrict ?
                            this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
                    }
                }

                var defaultWeekdaysMinRegex = matchWord;

                function weekdaysMinRegex(isStrict) {
                    if (this._weekdaysParseExact) {
                        if (!hasOwnProp(this, '_weekdaysRegex')) {
                            computeWeekdaysParse.call(this);
                        }
                        if (isStrict) {
                            return this._weekdaysMinStrictRegex;
                        } else {
                            return this._weekdaysMinRegex;
                        }
                    } else {
                        if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
                        }
                        return this._weekdaysMinStrictRegex && isStrict ?
                            this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
                    }
                }


                function computeWeekdaysParse() {
                    function cmpLenRev(a, b) {
                        return b.length - a.length;
                    }

                    var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
                        i, mom, minp, shortp, longp;
                    for (i = 0; i < 7; i++) {
                        // make the regex if we don't have it already
                        mom = createUTC([2000, 1]).day(i);
                        minp = this.weekdaysMin(mom, '');
                        shortp = this.weekdaysShort(mom, '');
                        longp = this.weekdays(mom, '');
                        minPieces.push(minp);
                        shortPieces.push(shortp);
                        longPieces.push(longp);
                        mixedPieces.push(minp);
                        mixedPieces.push(shortp);
                        mixedPieces.push(longp);
                    }
                    // Sorting makes sure if one weekday (or abbr) is a prefix of another it
                    // will match the longer piece.
                    minPieces.sort(cmpLenRev);
                    shortPieces.sort(cmpLenRev);
                    longPieces.sort(cmpLenRev);
                    mixedPieces.sort(cmpLenRev);
                    for (i = 0; i < 7; i++) {
                        shortPieces[i] = regexEscape(shortPieces[i]);
                        longPieces[i] = regexEscape(longPieces[i]);
                        mixedPieces[i] = regexEscape(mixedPieces[i]);
                    }

                    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
                    this._weekdaysShortRegex = this._weekdaysRegex;
                    this._weekdaysMinRegex = this._weekdaysRegex;

                    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
                    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
                    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
                }

// FORMATTING

                function hFormat() {
                    return this.hours() % 12 || 12;
                }

                function kFormat() {
                    return this.hours() || 24;
                }

                addFormatToken('H', ['HH', 2], 0, 'hour');
                addFormatToken('h', ['hh', 2], 0, hFormat);
                addFormatToken('k', ['kk', 2], 0, kFormat);

                addFormatToken('hmm', 0, 0, function () {
                    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
                });

                addFormatToken('hmmss', 0, 0, function () {
                    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
                        zeroFill(this.seconds(), 2);
                });

                addFormatToken('Hmm', 0, 0, function () {
                    return '' + this.hours() + zeroFill(this.minutes(), 2);
                });

                addFormatToken('Hmmss', 0, 0, function () {
                    return '' + this.hours() + zeroFill(this.minutes(), 2) +
                        zeroFill(this.seconds(), 2);
                });

                function meridiem(token, lowercase) {
                    addFormatToken(token, 0, 0, function () {
                        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
                    });
                }

                meridiem('a', true);
                meridiem('A', false);

// ALIASES

                addUnitAlias('hour', 'h');

// PRIORITY
                addUnitPriority('hour', 13);

// PARSING

                function matchMeridiem(isStrict, locale) {
                    return locale._meridiemParse;
                }

                addRegexToken('a', matchMeridiem);
                addRegexToken('A', matchMeridiem);
                addRegexToken('H', match1to2);
                addRegexToken('h', match1to2);
                addRegexToken('HH', match1to2, match2);
                addRegexToken('hh', match1to2, match2);

                addRegexToken('hmm', match3to4);
                addRegexToken('hmmss', match5to6);
                addRegexToken('Hmm', match3to4);
                addRegexToken('Hmmss', match5to6);

                addParseToken(['H', 'HH'], HOUR);
                addParseToken(['a', 'A'], function (input, array, config) {
                    config._isPm = config._locale.isPM(input);
                    config._meridiem = input;
                });
                addParseToken(['h', 'hh'], function (input, array, config) {
                    array[HOUR] = toInt(input);
                    getParsingFlags(config).bigHour = true;
                });
                addParseToken('hmm', function (input, array, config) {
                    var pos = input.length - 2;
                    array[HOUR] = toInt(input.substr(0, pos));
                    array[MINUTE] = toInt(input.substr(pos));
                    getParsingFlags(config).bigHour = true;
                });
                addParseToken('hmmss', function (input, array, config) {
                    var pos1 = input.length - 4;
                    var pos2 = input.length - 2;
                    array[HOUR] = toInt(input.substr(0, pos1));
                    array[MINUTE] = toInt(input.substr(pos1, 2));
                    array[SECOND] = toInt(input.substr(pos2));
                    getParsingFlags(config).bigHour = true;
                });
                addParseToken('Hmm', function (input, array, config) {
                    var pos = input.length - 2;
                    array[HOUR] = toInt(input.substr(0, pos));
                    array[MINUTE] = toInt(input.substr(pos));
                });
                addParseToken('Hmmss', function (input, array, config) {
                    var pos1 = input.length - 4;
                    var pos2 = input.length - 2;
                    array[HOUR] = toInt(input.substr(0, pos1));
                    array[MINUTE] = toInt(input.substr(pos1, 2));
                    array[SECOND] = toInt(input.substr(pos2));
                });

// LOCALES

                function localeIsPM(input) {
                    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
                    // Using charAt should be more compatible.
                    return ((input + '').toLowerCase().charAt(0) === 'p');
                }

                var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;

                function localeMeridiem(hours, minutes, isLower) {
                    if (hours > 11) {
                        return isLower ? 'pm' : 'PM';
                    } else {
                        return isLower ? 'am' : 'AM';
                    }
                }


// MOMENTS

// Setting the hour should keep the time, because the user explicitly
// specified which hour he wants. So trying to maintain the same hour (in
// a new timezone) makes sense. Adding/subtracting hours does not follow
// this rule.
                var getSetHour = makeGetSet('Hours', true);

// months
// week
// weekdays
// meridiem
                var baseConfig = {
                    calendar: defaultCalendar,
                    longDateFormat: defaultLongDateFormat,
                    invalidDate: defaultInvalidDate,
                    ordinal: defaultOrdinal,
                    ordinalParse: defaultOrdinalParse,
                    relativeTime: defaultRelativeTime,

                    months: defaultLocaleMonths,
                    monthsShort: defaultLocaleMonthsShort,

                    week: defaultLocaleWeek,

                    weekdays: defaultLocaleWeekdays,
                    weekdaysMin: defaultLocaleWeekdaysMin,
                    weekdaysShort: defaultLocaleWeekdaysShort,

                    meridiemParse: defaultLocaleMeridiemParse
                };

// internal storage for locale config files
                var locales = {};
                var localeFamilies = {};
                var globalLocale;

                function normalizeLocale(key) {
                    return key ? key.toLowerCase().replace('_', '-') : key;
                }

// pick the locale from the array
// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
                function chooseLocale(names) {
                    var i = 0, j, next, locale, split;

                    while (i < names.length) {
                        split = normalizeLocale(names[i]).split('-');
                        j = split.length;
                        next = normalizeLocale(names[i + 1]);
                        next = next ? next.split('-') : null;
                        while (j > 0) {
                            locale = loadLocale(split.slice(0, j).join('-'));
                            if (locale) {
                                return locale;
                            }
                            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                                //the next array item is better than a shallower substring of this one
                                break;
                            }
                            j--;
                        }
                        i++;
                    }
                    return null;
                }

                function loadLocale(name) {
                    var oldLocale = null;
                    // TODO: Find a better way to register and load all the locales in Node
                    if (!locales[name] && (typeof module !== 'undefined') &&
                        module && module.exports) {
                        try {
                            oldLocale = globalLocale._abbr;
                            __webpack_require__(113)("./" + name);
                            // because defineLocale currently also sets the global locale, we
                            // want to undo that for lazy loaded locales
                            getSetGlobalLocale(oldLocale);
                        } catch (e) {
                        }
                    }
                    return locales[name];
                }

// This function will load locale and then set the global locale.  If
// no arguments are passed in, it will simply return the current global
// locale key.
                function getSetGlobalLocale(key, values) {
                    var data;
                    if (key) {
                        if (isUndefined(values)) {
                            data = getLocale(key);
                        }
                        else {
                            data = defineLocale(key, values);
                        }

                        if (data) {
                            // moment.duration._locale = moment._locale = data;
                            globalLocale = data;
                        }
                    }

                    return globalLocale._abbr;
                }

                function defineLocale(name, config) {
                    if (config !== null) {
                        var parentConfig = baseConfig;
                        config.abbr = name;
                        if (locales[name] != null) {
                            deprecateSimple('defineLocaleOverride',
                                'use moment.updateLocale(localeName, config) to change ' +
                                'an existing locale. moment.defineLocale(localeName, ' +
                                'config) should only be used for creating a new locale ' +
                                'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
                            parentConfig = locales[name]._config;
                        } else if (config.parentLocale != null) {
                            if (locales[config.parentLocale] != null) {
                                parentConfig = locales[config.parentLocale]._config;
                            } else {
                                if (!localeFamilies[config.parentLocale]) {
                                    localeFamilies[config.parentLocale] = [];
                                }
                                localeFamilies[config.parentLocale].push({
                                    name: name,
                                    config: config
                                });
                                return null;
                            }
                        }
                        locales[name] = new Locale(mergeConfigs(parentConfig, config));

                        if (localeFamilies[name]) {
                            localeFamilies[name].forEach(function (x) {
                                defineLocale(x.name, x.config);
                            });
                        }

                        // backwards compat for now: also set the locale
                        // make sure we set the locale AFTER all child locales have been
                        // created, so we won't end up with the child locale set.
                        getSetGlobalLocale(name);


                        return locales[name];
                    } else {
                        // useful for testing
                        delete locales[name];
                        return null;
                    }
                }

                function updateLocale(name, config) {
                    if (config != null) {
                        var locale, parentConfig = baseConfig;
                        // MERGE
                        if (locales[name] != null) {
                            parentConfig = locales[name]._config;
                        }
                        config = mergeConfigs(parentConfig, config);
                        locale = new Locale(config);
                        locale.parentLocale = locales[name];
                        locales[name] = locale;

                        // backwards compat for now: also set the locale
                        getSetGlobalLocale(name);
                    } else {
                        // pass null for config to unupdate, useful for tests
                        if (locales[name] != null) {
                            if (locales[name].parentLocale != null) {
                                locales[name] = locales[name].parentLocale;
                            } else if (locales[name] != null) {
                                delete locales[name];
                            }
                        }
                    }
                    return locales[name];
                }

// returns locale data
                function getLocale(key) {
                    var locale;

                    if (key && key._locale && key._locale._abbr) {
                        key = key._locale._abbr;
                    }

                    if (!key) {
                        return globalLocale;
                    }

                    if (!isArray(key)) {
                        //short-circuit everything else
                        locale = loadLocale(key);
                        if (locale) {
                            return locale;
                        }
                        key = [key];
                    }

                    return chooseLocale(key);
                }

                function listLocales() {
                    return keys$1(locales);
                }

                function checkOverflow(m) {
                    var overflow;
                    var a = m._a;

                    if (a && getParsingFlags(m).overflow === -2) {
                        overflow =
                            a[MONTH] < 0 || a[MONTH] > 11 ? MONTH :
                                a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                                    a[HOUR] < 0 || a[HOUR] > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                                        a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE :
                                            a[SECOND] < 0 || a[SECOND] > 59 ? SECOND :
                                                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                                                    -1;

                        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                            overflow = DATE;
                        }
                        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                            overflow = WEEK;
                        }
                        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                            overflow = WEEKDAY;
                        }

                        getParsingFlags(m).overflow = overflow;
                    }

                    return m;
                }

// iso 8601 regex
// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
                var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
                var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

                var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

                var isoDates = [
                    ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
                    ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
                    ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
                    ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
                    ['YYYY-DDD', /\d{4}-\d{3}/],
                    ['YYYY-MM', /\d{4}-\d\d/, false],
                    ['YYYYYYMMDD', /[+-]\d{10}/],
                    ['YYYYMMDD', /\d{8}/],
                    // YYYYMM is NOT allowed by the standard
                    ['GGGG[W]WWE', /\d{4}W\d{3}/],
                    ['GGGG[W]WW', /\d{4}W\d{2}/, false],
                    ['YYYYDDD', /\d{7}/]
                ];

// iso time formats and regexes
                var isoTimes = [
                    ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
                    ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
                    ['HH:mm:ss', /\d\d:\d\d:\d\d/],
                    ['HH:mm', /\d\d:\d\d/],
                    ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
                    ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
                    ['HHmmss', /\d\d\d\d\d\d/],
                    ['HHmm', /\d\d\d\d/],
                    ['HH', /\d\d/]
                ];

                var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

// date from iso format
                function configFromISO(config) {
                    var i, l,
                        string = config._i,
                        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
                        allowTime, dateFormat, timeFormat, tzFormat;

                    if (match) {
                        getParsingFlags(config).iso = true;

                        for (i = 0, l = isoDates.length; i < l; i++) {
                            if (isoDates[i][1].exec(match[1])) {
                                dateFormat = isoDates[i][0];
                                allowTime = isoDates[i][2] !== false;
                                break;
                            }
                        }
                        if (dateFormat == null) {
                            config._isValid = false;
                            return;
                        }
                        if (match[3]) {
                            for (i = 0, l = isoTimes.length; i < l; i++) {
                                if (isoTimes[i][1].exec(match[3])) {
                                    // match[2] should be 'T' or space
                                    timeFormat = (match[2] || ' ') + isoTimes[i][0];
                                    break;
                                }
                            }
                            if (timeFormat == null) {
                                config._isValid = false;
                                return;
                            }
                        }
                        if (!allowTime && timeFormat != null) {
                            config._isValid = false;
                            return;
                        }
                        if (match[4]) {
                            if (tzRegex.exec(match[4])) {
                                tzFormat = 'Z';
                            } else {
                                config._isValid = false;
                                return;
                            }
                        }
                        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
                        configFromStringAndFormat(config);
                    } else {
                        config._isValid = false;
                    }
                }

// date from iso format or fallback
                function configFromString(config) {
                    var matched = aspNetJsonRegex.exec(config._i);

                    if (matched !== null) {
                        config._d = new Date(+matched[1]);
                        return;
                    }

                    configFromISO(config);
                    if (config._isValid === false) {
                        delete config._isValid;
                        hooks.createFromInputFallback(config);
                    }
                }

                hooks.createFromInputFallback = deprecate(
                    'value provided is not in a recognized ISO format. moment construction falls back to js Date(), ' +
                    'which is not reliable across all browsers and versions. Non ISO date formats are ' +
                    'discouraged and will be removed in an upcoming major release. Please refer to ' +
                    'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
                    function (config) {
                        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
                    }
                );

// Pick the first defined of two or three arguments.
                function defaults(a, b, c) {
                    if (a != null) {
                        return a;
                    }
                    if (b != null) {
                        return b;
                    }
                    return c;
                }

                function currentDateArray(config) {
                    // hooks is actually the exported moment object
                    var nowValue = new Date(hooks.now());
                    if (config._useUTC) {
                        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
                    }
                    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
                }

// convert an array to a date.
// the array should mirror the parameters below
// note: all values past the year are optional and will default to the lowest possible value.
// [year, month, day , hour, minute, second, millisecond]
                function configFromArray(config) {
                    var i, date, input = [], currentDate, yearToUse;

                    if (config._d) {
                        return;
                    }

                    currentDate = currentDateArray(config);

                    //compute day of the year from weeks and weekdays
                    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
                        dayOfYearFromWeekInfo(config);
                    }

                    //if the day of the year is set, figure out what it is
                    if (config._dayOfYear) {
                        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

                        if (config._dayOfYear > daysInYear(yearToUse)) {
                            getParsingFlags(config)._overflowDayOfYear = true;
                        }

                        date = createUTCDate(yearToUse, 0, config._dayOfYear);
                        config._a[MONTH] = date.getUTCMonth();
                        config._a[DATE] = date.getUTCDate();
                    }

                    // Default to current date.
                    // * if no year, month, day of month are given, default to today
                    // * if day of month is given, default month and year
                    // * if month is given, default only year
                    // * if year is given, don't default anything
                    for (i = 0; i < 3 && config._a[i] == null; ++i) {
                        config._a[i] = input[i] = currentDate[i];
                    }

                    // Zero out whatever was not defaulted, including time
                    for (; i < 7; i++) {
                        config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
                    }

                    // Check for 24:00:00.000
                    if (config._a[HOUR] === 24 &&
                        config._a[MINUTE] === 0 &&
                        config._a[SECOND] === 0 &&
                        config._a[MILLISECOND] === 0) {
                        config._nextDay = true;
                        config._a[HOUR] = 0;
                    }

                    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
                    // Apply timezone offset from input. The actual utcOffset can be changed
                    // with parseZone.
                    if (config._tzm != null) {
                        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
                    }

                    if (config._nextDay) {
                        config._a[HOUR] = 24;
                    }
                }

                function dayOfYearFromWeekInfo(config) {
                    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

                    w = config._w;
                    if (w.GG != null || w.W != null || w.E != null) {
                        dow = 1;
                        doy = 4;

                        // TODO: We need to take the current isoWeekYear, but that depends on
                        // how we interpret now (local, utc, fixed offset). So create
                        // a now version of current config (take local/utc/offset flags, and
                        // create now).
                        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
                        week = defaults(w.W, 1);
                        weekday = defaults(w.E, 1);
                        if (weekday < 1 || weekday > 7) {
                            weekdayOverflow = true;
                        }
                    } else {
                        dow = config._locale._week.dow;
                        doy = config._locale._week.doy;

                        var curWeek = weekOfYear(createLocal(), dow, doy);

                        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

                        // Default to current week.
                        week = defaults(w.w, curWeek.week);

                        if (w.d != null) {
                            // weekday -- low day numbers are considered next week
                            weekday = w.d;
                            if (weekday < 0 || weekday > 6) {
                                weekdayOverflow = true;
                            }
                        } else if (w.e != null) {
                            // local weekday -- counting starts from begining of week
                            weekday = w.e + dow;
                            if (w.e < 0 || w.e > 6) {
                                weekdayOverflow = true;
                            }
                        } else {
                            // default to begining of week
                            weekday = dow;
                        }
                    }
                    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
                        getParsingFlags(config)._overflowWeeks = true;
                    } else if (weekdayOverflow != null) {
                        getParsingFlags(config)._overflowWeekday = true;
                    } else {
                        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
                        config._a[YEAR] = temp.year;
                        config._dayOfYear = temp.dayOfYear;
                    }
                }

// constant that refers to the ISO standard
                hooks.ISO_8601 = function () {
                };

// date from string and format string
                function configFromStringAndFormat(config) {
                    // TODO: Move this to another part of the creation flow to prevent circular deps
                    if (config._f === hooks.ISO_8601) {
                        configFromISO(config);
                        return;
                    }

                    config._a = [];
                    getParsingFlags(config).empty = true;

                    // This array is used to make a Date, either with `new Date` or `Date.UTC`
                    var string = '' + config._i,
                        i, parsedInput, tokens, token, skipped,
                        stringLength = string.length,
                        totalParsedInputLength = 0;

                    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

                    for (i = 0; i < tokens.length; i++) {
                        token = tokens[i];
                        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
                        // console.log('token', token, 'parsedInput', parsedInput,
                        //         'regex', getParseRegexForToken(token, config));
                        if (parsedInput) {
                            skipped = string.substr(0, string.indexOf(parsedInput));
                            if (skipped.length > 0) {
                                getParsingFlags(config).unusedInput.push(skipped);
                            }
                            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                            totalParsedInputLength += parsedInput.length;
                        }
                        // don't parse if it's not a known token
                        if (formatTokenFunctions[token]) {
                            if (parsedInput) {
                                getParsingFlags(config).empty = false;
                            }
                            else {
                                getParsingFlags(config).unusedTokens.push(token);
                            }
                            addTimeToArrayFromToken(token, parsedInput, config);
                        }
                        else if (config._strict && !parsedInput) {
                            getParsingFlags(config).unusedTokens.push(token);
                        }
                    }

                    // add remaining unparsed input length to the string
                    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
                    if (string.length > 0) {
                        getParsingFlags(config).unusedInput.push(string);
                    }

                    // clear _12h flag if hour is <= 12
                    if (config._a[HOUR] <= 12 &&
                        getParsingFlags(config).bigHour === true &&
                        config._a[HOUR] > 0) {
                        getParsingFlags(config).bigHour = undefined;
                    }

                    getParsingFlags(config).parsedDateParts = config._a.slice(0);
                    getParsingFlags(config).meridiem = config._meridiem;
                    // handle meridiem
                    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

                    configFromArray(config);
                    checkOverflow(config);
                }


                function meridiemFixWrap(locale, hour, meridiem) {
                    var isPm;

                    if (meridiem == null) {
                        // nothing to do
                        return hour;
                    }
                    if (locale.meridiemHour != null) {
                        return locale.meridiemHour(hour, meridiem);
                    } else if (locale.isPM != null) {
                        // Fallback
                        isPm = locale.isPM(meridiem);
                        if (isPm && hour < 12) {
                            hour += 12;
                        }
                        if (!isPm && hour === 12) {
                            hour = 0;
                        }
                        return hour;
                    } else {
                        // this is not supposed to happen
                        return hour;
                    }
                }

// date from string and array of format strings
                function configFromStringAndArray(config) {
                    var tempConfig,
                        bestMoment,

                        scoreToBeat,
                        i,
                        currentScore;

                    if (config._f.length === 0) {
                        getParsingFlags(config).invalidFormat = true;
                        config._d = new Date(NaN);
                        return;
                    }

                    for (i = 0; i < config._f.length; i++) {
                        currentScore = 0;
                        tempConfig = copyConfig({}, config);
                        if (config._useUTC != null) {
                            tempConfig._useUTC = config._useUTC;
                        }
                        tempConfig._f = config._f[i];
                        configFromStringAndFormat(tempConfig);

                        if (!isValid(tempConfig)) {
                            continue;
                        }

                        // if there is any input that was not parsed add a penalty for that format
                        currentScore += getParsingFlags(tempConfig).charsLeftOver;

                        //or tokens
                        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

                        getParsingFlags(tempConfig).score = currentScore;

                        if (scoreToBeat == null || currentScore < scoreToBeat) {
                            scoreToBeat = currentScore;
                            bestMoment = tempConfig;
                        }
                    }

                    extend(config, bestMoment || tempConfig);
                }

                function configFromObject(config) {
                    if (config._d) {
                        return;
                    }

                    var i = normalizeObjectUnits(config._i);
                    config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
                        return obj && parseInt(obj, 10);
                    });

                    configFromArray(config);
                }

                function createFromConfig(config) {
                    var res = new Moment(checkOverflow(prepareConfig(config)));
                    if (res._nextDay) {
                        // Adding is smart enough around DST
                        res.add(1, 'd');
                        res._nextDay = undefined;
                    }

                    return res;
                }

                function prepareConfig(config) {
                    var input = config._i,
                        format = config._f;

                    config._locale = config._locale || getLocale(config._l);

                    if (input === null || (format === undefined && input === '')) {
                        return createInvalid({nullInput: true});
                    }

                    if (typeof input === 'string') {
                        config._i = input = config._locale.preparse(input);
                    }

                    if (isMoment(input)) {
                        return new Moment(checkOverflow(input));
                    } else if (isDate(input)) {
                        config._d = input;
                    } else if (isArray(format)) {
                        configFromStringAndArray(config);
                    } else if (format) {
                        configFromStringAndFormat(config);
                    } else {
                        configFromInput(config);
                    }

                    if (!isValid(config)) {
                        config._d = null;
                    }

                    return config;
                }

                function configFromInput(config) {
                    var input = config._i;
                    if (input === undefined) {
                        config._d = new Date(hooks.now());
                    } else if (isDate(input)) {
                        config._d = new Date(input.valueOf());
                    } else if (typeof input === 'string') {
                        configFromString(config);
                    } else if (isArray(input)) {
                        config._a = map(input.slice(0), function (obj) {
                            return parseInt(obj, 10);
                        });
                        configFromArray(config);
                    } else if (typeof(input) === 'object') {
                        configFromObject(config);
                    } else if (isNumber(input)) {
                        // from milliseconds
                        config._d = new Date(input);
                    } else {
                        hooks.createFromInputFallback(config);
                    }
                }

                function createLocalOrUTC(input, format, locale, strict, isUTC) {
                    var c = {};

                    if (locale === true || locale === false) {
                        strict = locale;
                        locale = undefined;
                    }

                    if ((isObject(input) && isObjectEmpty(input)) ||
                        (isArray(input) && input.length === 0)) {
                        input = undefined;
                    }
                    // object construction must be done this way.
                    // https://github.com/moment/moment/issues/1423
                    c._isAMomentObject = true;
                    c._useUTC = c._isUTC = isUTC;
                    c._l = locale;
                    c._i = input;
                    c._f = format;
                    c._strict = strict;

                    return createFromConfig(c);
                }

                function createLocal(input, format, locale, strict) {
                    return createLocalOrUTC(input, format, locale, strict, false);
                }

                var prototypeMin = deprecate(
                    'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
                    function () {
                        var other = createLocal.apply(null, arguments);
                        if (this.isValid() && other.isValid()) {
                            return other < this ? this : other;
                        } else {
                            return createInvalid();
                        }
                    }
                );

                var prototypeMax = deprecate(
                    'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
                    function () {
                        var other = createLocal.apply(null, arguments);
                        if (this.isValid() && other.isValid()) {
                            return other > this ? this : other;
                        } else {
                            return createInvalid();
                        }
                    }
                );

// Pick a moment m from moments so that m[fn](other) is true for all
// other. This relies on the function fn to be transitive.
//
// moments should either be an array of moment objects or an array, whose
// first element is an array of moment objects.
                function pickBy(fn, moments) {
                    var res, i;
                    if (moments.length === 1 && isArray(moments[0])) {
                        moments = moments[0];
                    }
                    if (!moments.length) {
                        return createLocal();
                    }
                    res = moments[0];
                    for (i = 1; i < moments.length; ++i) {
                        if (!moments[i].isValid() || moments[i][fn](res)) {
                            res = moments[i];
                        }
                    }
                    return res;
                }

// TODO: Use [].sort instead?
                function min() {
                    var args = [].slice.call(arguments, 0);

                    return pickBy('isBefore', args);
                }

                function max() {
                    var args = [].slice.call(arguments, 0);

                    return pickBy('isAfter', args);
                }

                var now = function () {
                    return Date.now ? Date.now() : +(new Date());
                };

                function Duration(duration) {
                    var normalizedInput = normalizeObjectUnits(duration),
                        years = normalizedInput.year || 0,
                        quarters = normalizedInput.quarter || 0,
                        months = normalizedInput.month || 0,
                        weeks = normalizedInput.week || 0,
                        days = normalizedInput.day || 0,
                        hours = normalizedInput.hour || 0,
                        minutes = normalizedInput.minute || 0,
                        seconds = normalizedInput.second || 0,
                        milliseconds = normalizedInput.millisecond || 0;

                    // representation for dateAddRemove
                    this._milliseconds = +milliseconds +
                        seconds * 1e3 + // 1000
                        minutes * 6e4 + // 1000 * 60
                        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
                    // Because of dateAddRemove treats 24 hours as different from a
                    // day when working around DST, we need to store them separately
                    this._days = +days +
                        weeks * 7;
                    // It is impossible translate months into days without knowing
                    // which months you are are talking about, so we have to store
                    // it separately.
                    this._months = +months +
                        quarters * 3 +
                        years * 12;

                    this._data = {};

                    this._locale = getLocale();

                    this._bubble();
                }

                function isDuration(obj) {
                    return obj instanceof Duration;
                }

                function absRound(number) {
                    if (number < 0) {
                        return Math.round(-1 * number) * -1;
                    } else {
                        return Math.round(number);
                    }
                }

// FORMATTING

                function offset(token, separator) {
                    addFormatToken(token, 0, 0, function () {
                        var offset = this.utcOffset();
                        var sign = '+';
                        if (offset < 0) {
                            offset = -offset;
                            sign = '-';
                        }
                        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
                    });
                }

                offset('Z', ':');
                offset('ZZ', '');

// PARSING

                addRegexToken('Z', matchShortOffset);
                addRegexToken('ZZ', matchShortOffset);
                addParseToken(['Z', 'ZZ'], function (input, array, config) {
                    config._useUTC = true;
                    config._tzm = offsetFromString(matchShortOffset, input);
                });

// HELPERS

// timezone chunker
// '+10:00' > ['10',  '00']
// '-1530'  > ['-15', '30']
                var chunkOffset = /([\+\-]|\d\d)/gi;

                function offsetFromString(matcher, string) {
                    var matches = (string || '').match(matcher);

                    if (matches === null) {
                        return null;
                    }

                    var chunk = matches[matches.length - 1] || [];
                    var parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
                    var minutes = +(parts[1] * 60) + toInt(parts[2]);

                    return minutes === 0 ?
                        0 :
                        parts[0] === '+' ? minutes : -minutes;
                }

// Return a moment from input, that is local/utc/zone equivalent to model.
                function cloneWithOffset(input, model) {
                    var res, diff;
                    if (model._isUTC) {
                        res = model.clone();
                        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
                        // Use low-level api, because this fn is low-level api.
                        res._d.setTime(res._d.valueOf() + diff);
                        hooks.updateOffset(res, false);
                        return res;
                    } else {
                        return createLocal(input).local();
                    }
                }

                function getDateOffset(m) {
                    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
                    // https://github.com/moment/moment/pull/1871
                    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
                }

// HOOKS

// This function will be called whenever a moment is mutated.
// It is intended to keep the offset in sync with the timezone.
                hooks.updateOffset = function () {
                };

// MOMENTS

// keepLocalTime = true means only change the timezone, without
// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
// +0200, so we adjust the time as needed, to be valid.
//
// Keeping the time actually adds/subtracts (one hour)
// from the actual represented time. That is why we call updateOffset
// a second time. In case it wants us to change the offset again
// _changeInProgress == true case, then we have to adjust, because
// there is no such time in the given timezone.
                function getSetOffset(input, keepLocalTime) {
                    var offset = this._offset || 0,
                        localAdjust;
                    if (!this.isValid()) {
                        return input != null ? this : NaN;
                    }
                    if (input != null) {
                        if (typeof input === 'string') {
                            input = offsetFromString(matchShortOffset, input);
                            if (input === null) {
                                return this;
                            }
                        } else if (Math.abs(input) < 16) {
                            input = input * 60;
                        }
                        if (!this._isUTC && keepLocalTime) {
                            localAdjust = getDateOffset(this);
                        }
                        this._offset = input;
                        this._isUTC = true;
                        if (localAdjust != null) {
                            this.add(localAdjust, 'm');
                        }
                        if (offset !== input) {
                            if (!keepLocalTime || this._changeInProgress) {
                                addSubtract(this, createDuration(input - offset, 'm'), 1, false);
                            } else if (!this._changeInProgress) {
                                this._changeInProgress = true;
                                hooks.updateOffset(this, true);
                                this._changeInProgress = null;
                            }
                        }
                        return this;
                    } else {
                        return this._isUTC ? offset : getDateOffset(this);
                    }
                }

                function getSetZone(input, keepLocalTime) {
                    if (input != null) {
                        if (typeof input !== 'string') {
                            input = -input;
                        }

                        this.utcOffset(input, keepLocalTime);

                        return this;
                    } else {
                        return -this.utcOffset();
                    }
                }

                function setOffsetToUTC(keepLocalTime) {
                    return this.utcOffset(0, keepLocalTime);
                }

                function setOffsetToLocal(keepLocalTime) {
                    if (this._isUTC) {
                        this.utcOffset(0, keepLocalTime);
                        this._isUTC = false;

                        if (keepLocalTime) {
                            this.subtract(getDateOffset(this), 'm');
                        }
                    }
                    return this;
                }

                function setOffsetToParsedOffset() {
                    if (this._tzm != null) {
                        this.utcOffset(this._tzm);
                    } else if (typeof this._i === 'string') {
                        var tZone = offsetFromString(matchOffset, this._i);
                        if (tZone != null) {
                            this.utcOffset(tZone);
                        }
                        else {
                            this.utcOffset(0, true);
                        }
                    }
                    return this;
                }

                function hasAlignedHourOffset(input) {
                    if (!this.isValid()) {
                        return false;
                    }
                    input = input ? createLocal(input).utcOffset() : 0;

                    return (this.utcOffset() - input) % 60 === 0;
                }

                function isDaylightSavingTime() {
                    return (
                        this.utcOffset() > this.clone().month(0).utcOffset() ||
                        this.utcOffset() > this.clone().month(5).utcOffset()
                    );
                }

                function isDaylightSavingTimeShifted() {
                    if (!isUndefined(this._isDSTShifted)) {
                        return this._isDSTShifted;
                    }

                    var c = {};

                    copyConfig(c, this);
                    c = prepareConfig(c);

                    if (c._a) {
                        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
                        this._isDSTShifted = this.isValid() &&
                            compareArrays(c._a, other.toArray()) > 0;
                    } else {
                        this._isDSTShifted = false;
                    }

                    return this._isDSTShifted;
                }

                function isLocal() {
                    return this.isValid() ? !this._isUTC : false;
                }

                function isUtcOffset() {
                    return this.isValid() ? this._isUTC : false;
                }

                function isUtc() {
                    return this.isValid() ? this._isUTC && this._offset === 0 : false;
                }

// ASP.NET json date format regex
                var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
// and further modified to allow for strings containing both week and day
                var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;

                function createDuration(input, key) {
                    var duration = input,
                        // matching against regexp is expensive, do it on demand
                        match = null,
                        sign,
                        ret,
                        diffRes;

                    if (isDuration(input)) {
                        duration = {
                            ms: input._milliseconds,
                            d: input._days,
                            M: input._months
                        };
                    } else if (isNumber(input)) {
                        duration = {};
                        if (key) {
                            duration[key] = input;
                        } else {
                            duration.milliseconds = input;
                        }
                    } else if (!!(match = aspNetRegex.exec(input))) {
                        sign = (match[1] === '-') ? -1 : 1;
                        duration = {
                            y: 0,
                            d: toInt(match[DATE]) * sign,
                            h: toInt(match[HOUR]) * sign,
                            m: toInt(match[MINUTE]) * sign,
                            s: toInt(match[SECOND]) * sign,
                            ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
                        };
                    } else if (!!(match = isoRegex.exec(input))) {
                        sign = (match[1] === '-') ? -1 : 1;
                        duration = {
                            y: parseIso(match[2], sign),
                            M: parseIso(match[3], sign),
                            w: parseIso(match[4], sign),
                            d: parseIso(match[5], sign),
                            h: parseIso(match[6], sign),
                            m: parseIso(match[7], sign),
                            s: parseIso(match[8], sign)
                        };
                    } else if (duration == null) {// checks for null or undefined
                        duration = {};
                    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
                        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

                        duration = {};
                        duration.ms = diffRes.milliseconds;
                        duration.M = diffRes.months;
                    }

                    ret = new Duration(duration);

                    if (isDuration(input) && hasOwnProp(input, '_locale')) {
                        ret._locale = input._locale;
                    }

                    return ret;
                }

                createDuration.fn = Duration.prototype;

                function parseIso(inp, sign) {
                    // We'd normally use ~~inp for this, but unfortunately it also
                    // converts floats to ints.
                    // inp may be undefined, so careful calling replace on it.
                    var res = inp && parseFloat(inp.replace(',', '.'));
                    // apply sign while we're at it
                    return (isNaN(res) ? 0 : res) * sign;
                }

                function positiveMomentsDifference(base, other) {
                    var res = {milliseconds: 0, months: 0};

                    res.months = other.month() - base.month() +
                        (other.year() - base.year()) * 12;
                    if (base.clone().add(res.months, 'M').isAfter(other)) {
                        --res.months;
                    }

                    res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

                    return res;
                }

                function momentsDifference(base, other) {
                    var res;
                    if (!(base.isValid() && other.isValid())) {
                        return {milliseconds: 0, months: 0};
                    }

                    other = cloneWithOffset(other, base);
                    if (base.isBefore(other)) {
                        res = positiveMomentsDifference(base, other);
                    } else {
                        res = positiveMomentsDifference(other, base);
                        res.milliseconds = -res.milliseconds;
                        res.months = -res.months;
                    }

                    return res;
                }

// TODO: remove 'name' arg after deprecation is removed
                function createAdder(direction, name) {
                    return function (val, period) {
                        var dur, tmp;
                        //invert the arguments, but complain about it
                        if (period !== null && !isNaN(+period)) {
                            deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
                                'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
                            tmp = val;
                            val = period;
                            period = tmp;
                        }

                        val = typeof val === 'string' ? +val : val;
                        dur = createDuration(val, period);
                        addSubtract(this, dur, direction);
                        return this;
                    };
                }

                function addSubtract(mom, duration, isAdding, updateOffset) {
                    var milliseconds = duration._milliseconds,
                        days = absRound(duration._days),
                        months = absRound(duration._months);

                    if (!mom.isValid()) {
                        // No op
                        return;
                    }

                    updateOffset = updateOffset == null ? true : updateOffset;

                    if (milliseconds) {
                        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
                    }
                    if (days) {
                        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
                    }
                    if (months) {
                        setMonth(mom, get(mom, 'Month') + months * isAdding);
                    }
                    if (updateOffset) {
                        hooks.updateOffset(mom, days || months);
                    }
                }

                var add = createAdder(1, 'add');
                var subtract = createAdder(-1, 'subtract');

                function getCalendarFormat(myMoment, now) {
                    var diff = myMoment.diff(now, 'days', true);
                    return diff < -6 ? 'sameElse' :
                        diff < -1 ? 'lastWeek' :
                            diff < 0 ? 'lastDay' :
                                diff < 1 ? 'sameDay' :
                                    diff < 2 ? 'nextDay' :
                                        diff < 7 ? 'nextWeek' : 'sameElse';
                }

                function calendar$1(time, formats) {
                    // We want to compare the start of today, vs this.
                    // Getting start-of-today depends on whether we're local/utc/offset or not.
                    var now = time || createLocal(),
                        sod = cloneWithOffset(now, this).startOf('day'),
                        format = hooks.calendarFormat(this, sod) || 'sameElse';

                    var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

                    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
                }

                function clone() {
                    return new Moment(this);
                }

                function isAfter(input, units) {
                    var localInput = isMoment(input) ? input : createLocal(input);
                    if (!(this.isValid() && localInput.isValid())) {
                        return false;
                    }
                    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
                    if (units === 'millisecond') {
                        return this.valueOf() > localInput.valueOf();
                    } else {
                        return localInput.valueOf() < this.clone().startOf(units).valueOf();
                    }
                }

                function isBefore(input, units) {
                    var localInput = isMoment(input) ? input : createLocal(input);
                    if (!(this.isValid() && localInput.isValid())) {
                        return false;
                    }
                    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
                    if (units === 'millisecond') {
                        return this.valueOf() < localInput.valueOf();
                    } else {
                        return this.clone().endOf(units).valueOf() < localInput.valueOf();
                    }
                }

                function isBetween(from, to, units, inclusivity) {
                    inclusivity = inclusivity || '()';
                    return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
                        (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
                }

                function isSame(input, units) {
                    var localInput = isMoment(input) ? input : createLocal(input),
                        inputMs;
                    if (!(this.isValid() && localInput.isValid())) {
                        return false;
                    }
                    units = normalizeUnits(units || 'millisecond');
                    if (units === 'millisecond') {
                        return this.valueOf() === localInput.valueOf();
                    } else {
                        inputMs = localInput.valueOf();
                        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
                    }
                }

                function isSameOrAfter(input, units) {
                    return this.isSame(input, units) || this.isAfter(input, units);
                }

                function isSameOrBefore(input, units) {
                    return this.isSame(input, units) || this.isBefore(input, units);
                }

                function diff(input, units, asFloat) {
                    var that,
                        zoneDelta,
                        delta, output;

                    if (!this.isValid()) {
                        return NaN;
                    }

                    that = cloneWithOffset(input, this);

                    if (!that.isValid()) {
                        return NaN;
                    }

                    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

                    units = normalizeUnits(units);

                    if (units === 'year' || units === 'month' || units === 'quarter') {
                        output = monthDiff(this, that);
                        if (units === 'quarter') {
                            output = output / 3;
                        } else if (units === 'year') {
                            output = output / 12;
                        }
                    } else {
                        delta = this - that;
                        output = units === 'second' ? delta / 1e3 : // 1000
                            units === 'minute' ? delta / 6e4 : // 1000 * 60
                                units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
                                    units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                                        units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                                            delta;
                    }
                    return asFloat ? output : absFloor(output);
                }

                function monthDiff(a, b) {
                    // difference in months
                    var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
                        // b is in (anchor - 1 month, anchor + 1 month)
                        anchor = a.clone().add(wholeMonthDiff, 'months'),
                        anchor2, adjust;

                    if (b - anchor < 0) {
                        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
                        // linear across the month
                        adjust = (b - anchor) / (anchor - anchor2);
                    } else {
                        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
                        // linear across the month
                        adjust = (b - anchor) / (anchor2 - anchor);
                    }

                    //check for negative zero, return zero if negative zero
                    return -(wholeMonthDiff + adjust) || 0;
                }

                hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
                hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

                function toString() {
                    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
                }

                function toISOString() {
                    var m = this.clone().utc();
                    if (0 < m.year() && m.year() <= 9999) {
                        if (isFunction(Date.prototype.toISOString)) {
                            // native implementation is ~50x faster, use it when we can
                            return this.toDate().toISOString();
                        } else {
                            return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
                        }
                    } else {
                        return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
                    }
                }

                /**
                 * Return a human readable representation of a moment that can
                 * also be evaluated to get a new moment which is the same
                 *
                 * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
                 */
                function inspect() {
                    if (!this.isValid()) {
                        return 'moment.invalid(/* ' + this._i + ' */)';
                    }
                    var func = 'moment';
                    var zone = '';
                    if (!this.isLocal()) {
                        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
                        zone = 'Z';
                    }
                    var prefix = '[' + func + '("]';
                    var year = (0 < this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
                    var datetime = '-MM-DD[T]HH:mm:ss.SSS';
                    var suffix = zone + '[")]';

                    return this.format(prefix + year + datetime + suffix);
                }

                function format(inputString) {
                    if (!inputString) {
                        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
                    }
                    var output = formatMoment(this, inputString);
                    return this.localeData().postformat(output);
                }

                function from(time, withoutSuffix) {
                    if (this.isValid() &&
                        ((isMoment(time) && time.isValid()) ||
                            createLocal(time).isValid())) {
                        return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
                    } else {
                        return this.localeData().invalidDate();
                    }
                }

                function fromNow(withoutSuffix) {
                    return this.from(createLocal(), withoutSuffix);
                }

                function to(time, withoutSuffix) {
                    if (this.isValid() &&
                        ((isMoment(time) && time.isValid()) ||
                            createLocal(time).isValid())) {
                        return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
                    } else {
                        return this.localeData().invalidDate();
                    }
                }

                function toNow(withoutSuffix) {
                    return this.to(createLocal(), withoutSuffix);
                }

// If passed a locale key, it will set the locale for this
// instance.  Otherwise, it will return the locale configuration
// variables for this instance.
                function locale(key) {
                    var newLocaleData;

                    if (key === undefined) {
                        return this._locale._abbr;
                    } else {
                        newLocaleData = getLocale(key);
                        if (newLocaleData != null) {
                            this._locale = newLocaleData;
                        }
                        return this;
                    }
                }

                var lang = deprecate(
                    'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
                    function (key) {
                        if (key === undefined) {
                            return this.localeData();
                        } else {
                            return this.locale(key);
                        }
                    }
                );

                function localeData() {
                    return this._locale;
                }

                function startOf(units) {
                    units = normalizeUnits(units);
                    // the following switch intentionally omits break keywords
                    // to utilize falling through the cases.
                    switch (units) {
                        case 'year':
                            this.month(0);
                        /* falls through */
                        case 'quarter':
                        case 'month':
                            this.date(1);
                        /* falls through */
                        case 'week':
                        case 'isoWeek':
                        case 'day':
                        case 'date':
                            this.hours(0);
                        /* falls through */
                        case 'hour':
                            this.minutes(0);
                        /* falls through */
                        case 'minute':
                            this.seconds(0);
                        /* falls through */
                        case 'second':
                            this.milliseconds(0);
                    }

                    // weeks are a special case
                    if (units === 'week') {
                        this.weekday(0);
                    }
                    if (units === 'isoWeek') {
                        this.isoWeekday(1);
                    }

                    // quarters are also special
                    if (units === 'quarter') {
                        this.month(Math.floor(this.month() / 3) * 3);
                    }

                    return this;
                }

                function endOf(units) {
                    units = normalizeUnits(units);
                    if (units === undefined || units === 'millisecond') {
                        return this;
                    }

                    // 'date' is an alias for 'day', so it should be considered as such.
                    if (units === 'date') {
                        units = 'day';
                    }

                    return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
                }

                function valueOf() {
                    return this._d.valueOf() - ((this._offset || 0) * 60000);
                }

                function unix() {
                    return Math.floor(this.valueOf() / 1000);
                }

                function toDate() {
                    return new Date(this.valueOf());
                }

                function toArray() {
                    var m = this;
                    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
                }

                function toObject() {
                    var m = this;
                    return {
                        years: m.year(),
                        months: m.month(),
                        date: m.date(),
                        hours: m.hours(),
                        minutes: m.minutes(),
                        seconds: m.seconds(),
                        milliseconds: m.milliseconds()
                    };
                }

                function toJSON() {
                    // new Date(NaN).toJSON() === null
                    return this.isValid() ? this.toISOString() : null;
                }

                function isValid$1() {
                    return isValid(this);
                }

                function parsingFlags() {
                    return extend({}, getParsingFlags(this));
                }

                function invalidAt() {
                    return getParsingFlags(this).overflow;
                }

                function creationData() {
                    return {
                        input: this._i,
                        format: this._f,
                        locale: this._locale,
                        isUTC: this._isUTC,
                        strict: this._strict
                    };
                }

// FORMATTING

                addFormatToken(0, ['gg', 2], 0, function () {
                    return this.weekYear() % 100;
                });

                addFormatToken(0, ['GG', 2], 0, function () {
                    return this.isoWeekYear() % 100;
                });

                function addWeekYearFormatToken(token, getter) {
                    addFormatToken(0, [token, token.length], 0, getter);
                }

                addWeekYearFormatToken('gggg', 'weekYear');
                addWeekYearFormatToken('ggggg', 'weekYear');
                addWeekYearFormatToken('GGGG', 'isoWeekYear');
                addWeekYearFormatToken('GGGGG', 'isoWeekYear');

// ALIASES

                addUnitAlias('weekYear', 'gg');
                addUnitAlias('isoWeekYear', 'GG');

// PRIORITY

                addUnitPriority('weekYear', 1);
                addUnitPriority('isoWeekYear', 1);


// PARSING

                addRegexToken('G', matchSigned);
                addRegexToken('g', matchSigned);
                addRegexToken('GG', match1to2, match2);
                addRegexToken('gg', match1to2, match2);
                addRegexToken('GGGG', match1to4, match4);
                addRegexToken('gggg', match1to4, match4);
                addRegexToken('GGGGG', match1to6, match6);
                addRegexToken('ggggg', match1to6, match6);

                addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
                    week[token.substr(0, 2)] = toInt(input);
                });

                addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
                    week[token] = hooks.parseTwoDigitYear(input);
                });

// MOMENTS

                function getSetWeekYear(input) {
                    return getSetWeekYearHelper.call(this,
                        input,
                        this.week(),
                        this.weekday(),
                        this.localeData()._week.dow,
                        this.localeData()._week.doy);
                }

                function getSetISOWeekYear(input) {
                    return getSetWeekYearHelper.call(this,
                        input, this.isoWeek(), this.isoWeekday(), 1, 4);
                }

                function getISOWeeksInYear() {
                    return weeksInYear(this.year(), 1, 4);
                }

                function getWeeksInYear() {
                    var weekInfo = this.localeData()._week;
                    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
                }

                function getSetWeekYearHelper(input, week, weekday, dow, doy) {
                    var weeksTarget;
                    if (input == null) {
                        return weekOfYear(this, dow, doy).year;
                    } else {
                        weeksTarget = weeksInYear(input, dow, doy);
                        if (week > weeksTarget) {
                            week = weeksTarget;
                        }
                        return setWeekAll.call(this, input, week, weekday, dow, doy);
                    }
                }

                function setWeekAll(weekYear, week, weekday, dow, doy) {
                    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
                        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

                    this.year(date.getUTCFullYear());
                    this.month(date.getUTCMonth());
                    this.date(date.getUTCDate());
                    return this;
                }

// FORMATTING

                addFormatToken('Q', 0, 'Qo', 'quarter');

// ALIASES

                addUnitAlias('quarter', 'Q');

// PRIORITY

                addUnitPriority('quarter', 7);

// PARSING

                addRegexToken('Q', match1);
                addParseToken('Q', function (input, array) {
                    array[MONTH] = (toInt(input) - 1) * 3;
                });

// MOMENTS

                function getSetQuarter(input) {
                    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
                }

// FORMATTING

                addFormatToken('D', ['DD', 2], 'Do', 'date');

// ALIASES

                addUnitAlias('date', 'D');

// PRIOROITY
                addUnitPriority('date', 9);

// PARSING

                addRegexToken('D', match1to2);
                addRegexToken('DD', match1to2, match2);
                addRegexToken('Do', function (isStrict, locale) {
                    return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
                });

                addParseToken(['D', 'DD'], DATE);
                addParseToken('Do', function (input, array) {
                    array[DATE] = toInt(input.match(match1to2)[0], 10);
                });

// MOMENTS

                var getSetDayOfMonth = makeGetSet('Date', true);

// FORMATTING

                addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

// ALIASES

                addUnitAlias('dayOfYear', 'DDD');

// PRIORITY
                addUnitPriority('dayOfYear', 4);

// PARSING

                addRegexToken('DDD', match1to3);
                addRegexToken('DDDD', match3);
                addParseToken(['DDD', 'DDDD'], function (input, array, config) {
                    config._dayOfYear = toInt(input);
                });

// HELPERS

// MOMENTS

                function getSetDayOfYear(input) {
                    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
                    return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
                }

// FORMATTING

                addFormatToken('m', ['mm', 2], 0, 'minute');

// ALIASES

                addUnitAlias('minute', 'm');

// PRIORITY

                addUnitPriority('minute', 14);

// PARSING

                addRegexToken('m', match1to2);
                addRegexToken('mm', match1to2, match2);
                addParseToken(['m', 'mm'], MINUTE);

// MOMENTS

                var getSetMinute = makeGetSet('Minutes', false);

// FORMATTING

                addFormatToken('s', ['ss', 2], 0, 'second');

// ALIASES

                addUnitAlias('second', 's');

// PRIORITY

                addUnitPriority('second', 15);

// PARSING

                addRegexToken('s', match1to2);
                addRegexToken('ss', match1to2, match2);
                addParseToken(['s', 'ss'], SECOND);

// MOMENTS

                var getSetSecond = makeGetSet('Seconds', false);

// FORMATTING

                addFormatToken('S', 0, 0, function () {
                    return ~~(this.millisecond() / 100);
                });

                addFormatToken(0, ['SS', 2], 0, function () {
                    return ~~(this.millisecond() / 10);
                });

                addFormatToken(0, ['SSS', 3], 0, 'millisecond');
                addFormatToken(0, ['SSSS', 4], 0, function () {
                    return this.millisecond() * 10;
                });
                addFormatToken(0, ['SSSSS', 5], 0, function () {
                    return this.millisecond() * 100;
                });
                addFormatToken(0, ['SSSSSS', 6], 0, function () {
                    return this.millisecond() * 1000;
                });
                addFormatToken(0, ['SSSSSSS', 7], 0, function () {
                    return this.millisecond() * 10000;
                });
                addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
                    return this.millisecond() * 100000;
                });
                addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
                    return this.millisecond() * 1000000;
                });


// ALIASES

                addUnitAlias('millisecond', 'ms');

// PRIORITY

                addUnitPriority('millisecond', 16);

// PARSING

                addRegexToken('S', match1to3, match1);
                addRegexToken('SS', match1to3, match2);
                addRegexToken('SSS', match1to3, match3);

                var token;
                for (token = 'SSSS'; token.length <= 9; token += 'S') {
                    addRegexToken(token, matchUnsigned);
                }

                function parseMs(input, array) {
                    array[MILLISECOND] = toInt(('0.' + input) * 1000);
                }

                for (token = 'S'; token.length <= 9; token += 'S') {
                    addParseToken(token, parseMs);
                }
// MOMENTS

                var getSetMillisecond = makeGetSet('Milliseconds', false);

// FORMATTING

                addFormatToken('z', 0, 0, 'zoneAbbr');
                addFormatToken('zz', 0, 0, 'zoneName');

// MOMENTS

                function getZoneAbbr() {
                    return this._isUTC ? 'UTC' : '';
                }

                function getZoneName() {
                    return this._isUTC ? 'Coordinated Universal Time' : '';
                }

                var proto = Moment.prototype;

                proto.add = add;
                proto.calendar = calendar$1;
                proto.clone = clone;
                proto.diff = diff;
                proto.endOf = endOf;
                proto.format = format;
                proto.from = from;
                proto.fromNow = fromNow;
                proto.to = to;
                proto.toNow = toNow;
                proto.get = stringGet;
                proto.invalidAt = invalidAt;
                proto.isAfter = isAfter;
                proto.isBefore = isBefore;
                proto.isBetween = isBetween;
                proto.isSame = isSame;
                proto.isSameOrAfter = isSameOrAfter;
                proto.isSameOrBefore = isSameOrBefore;
                proto.isValid = isValid$1;
                proto.lang = lang;
                proto.locale = locale;
                proto.localeData = localeData;
                proto.max = prototypeMax;
                proto.min = prototypeMin;
                proto.parsingFlags = parsingFlags;
                proto.set = stringSet;
                proto.startOf = startOf;
                proto.subtract = subtract;
                proto.toArray = toArray;
                proto.toObject = toObject;
                proto.toDate = toDate;
                proto.toISOString = toISOString;
                proto.inspect = inspect;
                proto.toJSON = toJSON;
                proto.toString = toString;
                proto.unix = unix;
                proto.valueOf = valueOf;
                proto.creationData = creationData;

// Year
                proto.year = getSetYear;
                proto.isLeapYear = getIsLeapYear;

// Week Year
                proto.weekYear = getSetWeekYear;
                proto.isoWeekYear = getSetISOWeekYear;

// Quarter
                proto.quarter = proto.quarters = getSetQuarter;

// Month
                proto.month = getSetMonth;
                proto.daysInMonth = getDaysInMonth;

// Week
                proto.week = proto.weeks = getSetWeek;
                proto.isoWeek = proto.isoWeeks = getSetISOWeek;
                proto.weeksInYear = getWeeksInYear;
                proto.isoWeeksInYear = getISOWeeksInYear;

// Day
                proto.date = getSetDayOfMonth;
                proto.day = proto.days = getSetDayOfWeek;
                proto.weekday = getSetLocaleDayOfWeek;
                proto.isoWeekday = getSetISODayOfWeek;
                proto.dayOfYear = getSetDayOfYear;

// Hour
                proto.hour = proto.hours = getSetHour;

// Minute
                proto.minute = proto.minutes = getSetMinute;

// Second
                proto.second = proto.seconds = getSetSecond;

// Millisecond
                proto.millisecond = proto.milliseconds = getSetMillisecond;

// Offset
                proto.utcOffset = getSetOffset;
                proto.utc = setOffsetToUTC;
                proto.local = setOffsetToLocal;
                proto.parseZone = setOffsetToParsedOffset;
                proto.hasAlignedHourOffset = hasAlignedHourOffset;
                proto.isDST = isDaylightSavingTime;
                proto.isLocal = isLocal;
                proto.isUtcOffset = isUtcOffset;
                proto.isUtc = isUtc;
                proto.isUTC = isUtc;

// Timezone
                proto.zoneAbbr = getZoneAbbr;
                proto.zoneName = getZoneName;

// Deprecations
                proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
                proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
                proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
                proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
                proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

                function createUnix(input) {
                    return createLocal(input * 1000);
                }

                function createInZone() {
                    return createLocal.apply(null, arguments).parseZone();
                }

                function preParsePostFormat(string) {
                    return string;
                }

                var proto$1 = Locale.prototype;

                proto$1.calendar = calendar;
                proto$1.longDateFormat = longDateFormat;
                proto$1.invalidDate = invalidDate;
                proto$1.ordinal = ordinal;
                proto$1.preparse = preParsePostFormat;
                proto$1.postformat = preParsePostFormat;
                proto$1.relativeTime = relativeTime;
                proto$1.pastFuture = pastFuture;
                proto$1.set = set;

// Month
                proto$1.months = localeMonths;
                proto$1.monthsShort = localeMonthsShort;
                proto$1.monthsParse = localeMonthsParse;
                proto$1.monthsRegex = monthsRegex;
                proto$1.monthsShortRegex = monthsShortRegex;

// Week
                proto$1.week = localeWeek;
                proto$1.firstDayOfYear = localeFirstDayOfYear;
                proto$1.firstDayOfWeek = localeFirstDayOfWeek;

// Day of Week
                proto$1.weekdays = localeWeekdays;
                proto$1.weekdaysMin = localeWeekdaysMin;
                proto$1.weekdaysShort = localeWeekdaysShort;
                proto$1.weekdaysParse = localeWeekdaysParse;

                proto$1.weekdaysRegex = weekdaysRegex;
                proto$1.weekdaysShortRegex = weekdaysShortRegex;
                proto$1.weekdaysMinRegex = weekdaysMinRegex;

// Hours
                proto$1.isPM = localeIsPM;
                proto$1.meridiem = localeMeridiem;

                function get$1(format, index, field, setter) {
                    var locale = getLocale();
                    var utc = createUTC().set(setter, index);
                    return locale[field](utc, format);
                }

                function listMonthsImpl(format, index, field) {
                    if (isNumber(format)) {
                        index = format;
                        format = undefined;
                    }

                    format = format || '';

                    if (index != null) {
                        return get$1(format, index, field, 'month');
                    }

                    var i;
                    var out = [];
                    for (i = 0; i < 12; i++) {
                        out[i] = get$1(format, i, field, 'month');
                    }
                    return out;
                }

// ()
// (5)
// (fmt, 5)
// (fmt)
// (true)
// (true, 5)
// (true, fmt, 5)
// (true, fmt)
                function listWeekdaysImpl(localeSorted, format, index, field) {
                    if (typeof localeSorted === 'boolean') {
                        if (isNumber(format)) {
                            index = format;
                            format = undefined;
                        }

                        format = format || '';
                    } else {
                        format = localeSorted;
                        index = format;
                        localeSorted = false;

                        if (isNumber(format)) {
                            index = format;
                            format = undefined;
                        }

                        format = format || '';
                    }

                    var locale = getLocale(),
                        shift = localeSorted ? locale._week.dow : 0;

                    if (index != null) {
                        return get$1(format, (index + shift) % 7, field, 'day');
                    }

                    var i;
                    var out = [];
                    for (i = 0; i < 7; i++) {
                        out[i] = get$1(format, (i + shift) % 7, field, 'day');
                    }
                    return out;
                }

                function listMonths(format, index) {
                    return listMonthsImpl(format, index, 'months');
                }

                function listMonthsShort(format, index) {
                    return listMonthsImpl(format, index, 'monthsShort');
                }

                function listWeekdays(localeSorted, format, index) {
                    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
                }

                function listWeekdaysShort(localeSorted, format, index) {
                    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
                }

                function listWeekdaysMin(localeSorted, format, index) {
                    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
                }

                getSetGlobalLocale('en', {
                    ordinalParse: /\d{1,2}(th|st|nd|rd)/,
                    ordinal: function (number) {
                        var b = number % 10,
                            output = (toInt(number % 100 / 10) === 1) ? 'th' :
                                (b === 1) ? 'st' :
                                    (b === 2) ? 'nd' :
                                        (b === 3) ? 'rd' : 'th';
                        return number + output;
                    }
                });

// Side effect imports
                hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
                hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

                var mathAbs = Math.abs;

                function abs() {
                    var data = this._data;

                    this._milliseconds = mathAbs(this._milliseconds);
                    this._days = mathAbs(this._days);
                    this._months = mathAbs(this._months);

                    data.milliseconds = mathAbs(data.milliseconds);
                    data.seconds = mathAbs(data.seconds);
                    data.minutes = mathAbs(data.minutes);
                    data.hours = mathAbs(data.hours);
                    data.months = mathAbs(data.months);
                    data.years = mathAbs(data.years);

                    return this;
                }

                function addSubtract$1(duration, input, value, direction) {
                    var other = createDuration(input, value);

                    duration._milliseconds += direction * other._milliseconds;
                    duration._days += direction * other._days;
                    duration._months += direction * other._months;

                    return duration._bubble();
                }

// supports only 2.0-style add(1, 's') or add(duration)
                function add$1(input, value) {
                    return addSubtract$1(this, input, value, 1);
                }

// supports only 2.0-style subtract(1, 's') or subtract(duration)
                function subtract$1(input, value) {
                    return addSubtract$1(this, input, value, -1);
                }

                function absCeil(number) {
                    if (number < 0) {
                        return Math.floor(number);
                    } else {
                        return Math.ceil(number);
                    }
                }

                function bubble() {
                    var milliseconds = this._milliseconds;
                    var days = this._days;
                    var months = this._months;
                    var data = this._data;
                    var seconds, minutes, hours, years, monthsFromDays;

                    // if we have a mix of positive and negative values, bubble down first
                    // check: https://github.com/moment/moment/issues/2166
                    if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                            (milliseconds <= 0 && days <= 0 && months <= 0))) {
                        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
                        days = 0;
                        months = 0;
                    }

                    // The following code bubbles up values, see the tests for
                    // examples of what that means.
                    data.milliseconds = milliseconds % 1000;

                    seconds = absFloor(milliseconds / 1000);
                    data.seconds = seconds % 60;

                    minutes = absFloor(seconds / 60);
                    data.minutes = minutes % 60;

                    hours = absFloor(minutes / 60);
                    data.hours = hours % 24;

                    days += absFloor(hours / 24);

                    // convert days to months
                    monthsFromDays = absFloor(daysToMonths(days));
                    months += monthsFromDays;
                    days -= absCeil(monthsToDays(monthsFromDays));

                    // 12 months -> 1 year
                    years = absFloor(months / 12);
                    months %= 12;

                    data.days = days;
                    data.months = months;
                    data.years = years;

                    return this;
                }

                function daysToMonths(days) {
                    // 400 years have 146097 days (taking into account leap year rules)
                    // 400 years have 12 months === 4800
                    return days * 4800 / 146097;
                }

                function monthsToDays(months) {
                    // the reverse of daysToMonths
                    return months * 146097 / 4800;
                }

                function as(units) {
                    var days;
                    var months;
                    var milliseconds = this._milliseconds;

                    units = normalizeUnits(units);

                    if (units === 'month' || units === 'year') {
                        days = this._days + milliseconds / 864e5;
                        months = this._months + daysToMonths(days);
                        return units === 'month' ? months : months / 12;
                    } else {
                        // handle milliseconds separately because of floating point math errors (issue #1867)
                        days = this._days + Math.round(monthsToDays(this._months));
                        switch (units) {
                            case 'week'   :
                                return days / 7 + milliseconds / 6048e5;
                            case 'day'    :
                                return days + milliseconds / 864e5;
                            case 'hour'   :
                                return days * 24 + milliseconds / 36e5;
                            case 'minute' :
                                return days * 1440 + milliseconds / 6e4;
                            case 'second' :
                                return days * 86400 + milliseconds / 1000;
                            // Math.floor prevents floating point math errors here
                            case 'millisecond':
                                return Math.floor(days * 864e5) + milliseconds;
                            default:
                                throw new Error('Unknown unit ' + units);
                        }
                    }
                }

// TODO: Use this.as('ms')?
                function valueOf$1() {
                    return (
                        this._milliseconds +
                        this._days * 864e5 +
                        (this._months % 12) * 2592e6 +
                        toInt(this._months / 12) * 31536e6
                    );
                }

                function makeAs(alias) {
                    return function () {
                        return this.as(alias);
                    };
                }

                var asMilliseconds = makeAs('ms');
                var asSeconds = makeAs('s');
                var asMinutes = makeAs('m');
                var asHours = makeAs('h');
                var asDays = makeAs('d');
                var asWeeks = makeAs('w');
                var asMonths = makeAs('M');
                var asYears = makeAs('y');

                function get$2(units) {
                    units = normalizeUnits(units);
                    return this[units + 's']();
                }

                function makeGetter(name) {
                    return function () {
                        return this._data[name];
                    };
                }

                var milliseconds = makeGetter('milliseconds');
                var seconds = makeGetter('seconds');
                var minutes = makeGetter('minutes');
                var hours = makeGetter('hours');
                var days = makeGetter('days');
                var months = makeGetter('months');
                var years = makeGetter('years');

                function weeks() {
                    return absFloor(this.days() / 7);
                }

                var round = Math.round;
                var thresholds = {
                    s: 45,  // seconds to minute
                    m: 45,  // minutes to hour
                    h: 22,  // hours to day
                    d: 26,  // days to month
                    M: 11   // months to year
                };

// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
                function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
                    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
                }

                function relativeTime$1(posNegDuration, withoutSuffix, locale) {
                    var duration = createDuration(posNegDuration).abs();
                    var seconds = round(duration.as('s'));
                    var minutes = round(duration.as('m'));
                    var hours = round(duration.as('h'));
                    var days = round(duration.as('d'));
                    var months = round(duration.as('M'));
                    var years = round(duration.as('y'));

                    var a = seconds < thresholds.s && ['s', seconds] ||
                        minutes <= 1 && ['m'] ||
                        minutes < thresholds.m && ['mm', minutes] ||
                        hours <= 1 && ['h'] ||
                        hours < thresholds.h && ['hh', hours] ||
                        days <= 1 && ['d'] ||
                        days < thresholds.d && ['dd', days] ||
                        months <= 1 && ['M'] ||
                        months < thresholds.M && ['MM', months] ||
                        years <= 1 && ['y'] || ['yy', years];

                    a[2] = withoutSuffix;
                    a[3] = +posNegDuration > 0;
                    a[4] = locale;
                    return substituteTimeAgo.apply(null, a);
                }

// This function allows you to set the rounding function for relative time strings
                function getSetRelativeTimeRounding(roundingFunction) {
                    if (roundingFunction === undefined) {
                        return round;
                    }
                    if (typeof(roundingFunction) === 'function') {
                        round = roundingFunction;
                        return true;
                    }
                    return false;
                }

// This function allows you to set a threshold for relative time strings
                function getSetRelativeTimeThreshold(threshold, limit) {
                    if (thresholds[threshold] === undefined) {
                        return false;
                    }
                    if (limit === undefined) {
                        return thresholds[threshold];
                    }
                    thresholds[threshold] = limit;
                    return true;
                }

                function humanize(withSuffix) {
                    var locale = this.localeData();
                    var output = relativeTime$1(this, !withSuffix, locale);

                    if (withSuffix) {
                        output = locale.pastFuture(+this, output);
                    }

                    return locale.postformat(output);
                }

                var abs$1 = Math.abs;

                function toISOString$1() {
                    // for ISO strings we do not use the normal bubbling rules:
                    //  * milliseconds bubble up until they become hours
                    //  * days do not bubble at all
                    //  * months bubble up until they become years
                    // This is because there is no context-free conversion between hours and days
                    // (think of clock changes)
                    // and also not between days and months (28-31 days per month)
                    var seconds = abs$1(this._milliseconds) / 1000;
                    var days = abs$1(this._days);
                    var months = abs$1(this._months);
                    var minutes, hours, years;

                    // 3600 seconds -> 60 minutes -> 1 hour
                    minutes = absFloor(seconds / 60);
                    hours = absFloor(minutes / 60);
                    seconds %= 60;
                    minutes %= 60;

                    // 12 months -> 1 year
                    years = absFloor(months / 12);
                    months %= 12;


                    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
                    var Y = years;
                    var M = months;
                    var D = days;
                    var h = hours;
                    var m = minutes;
                    var s = seconds;
                    var total = this.asSeconds();

                    if (!total) {
                        // this is the same as C#'s (Noda) and python (isodate)...
                        // but not other JS (goog.date)
                        return 'P0D';
                    }

                    return (total < 0 ? '-' : '') +
                        'P' +
                        (Y ? Y + 'Y' : '') +
                        (M ? M + 'M' : '') +
                        (D ? D + 'D' : '') +
                        ((h || m || s) ? 'T' : '') +
                        (h ? h + 'H' : '') +
                        (m ? m + 'M' : '') +
                        (s ? s + 'S' : '');
                }

                var proto$2 = Duration.prototype;

                proto$2.abs = abs;
                proto$2.add = add$1;
                proto$2.subtract = subtract$1;
                proto$2.as = as;
                proto$2.asMilliseconds = asMilliseconds;
                proto$2.asSeconds = asSeconds;
                proto$2.asMinutes = asMinutes;
                proto$2.asHours = asHours;
                proto$2.asDays = asDays;
                proto$2.asWeeks = asWeeks;
                proto$2.asMonths = asMonths;
                proto$2.asYears = asYears;
                proto$2.valueOf = valueOf$1;
                proto$2._bubble = bubble;
                proto$2.get = get$2;
                proto$2.milliseconds = milliseconds;
                proto$2.seconds = seconds;
                proto$2.minutes = minutes;
                proto$2.hours = hours;
                proto$2.days = days;
                proto$2.weeks = weeks;
                proto$2.months = months;
                proto$2.years = years;
                proto$2.humanize = humanize;
                proto$2.toISOString = toISOString$1;
                proto$2.toString = toISOString$1;
                proto$2.toJSON = toISOString$1;
                proto$2.locale = locale;
                proto$2.localeData = localeData;

// Deprecations
                proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
                proto$2.lang = lang;

// Side effect imports

// FORMATTING

                addFormatToken('X', 0, 0, 'unix');
                addFormatToken('x', 0, 0, 'valueOf');

// PARSING

                addRegexToken('x', matchSigned);
                addRegexToken('X', matchTimestamp);
                addParseToken('X', function (input, array, config) {
                    config._d = new Date(parseFloat(input, 10) * 1000);
                });
                addParseToken('x', function (input, array, config) {
                    config._d = new Date(toInt(input));
                });

// Side effect imports


                hooks.version = '2.17.1';

                setHookCallback(createLocal);

                hooks.fn = proto;
                hooks.min = min;
                hooks.max = max;
                hooks.now = now;
                hooks.utc = createUTC;
                hooks.unix = createUnix;
                hooks.months = listMonths;
                hooks.isDate = isDate;
                hooks.locale = getSetGlobalLocale;
                hooks.invalid = createInvalid;
                hooks.duration = createDuration;
                hooks.isMoment = isMoment;
                hooks.weekdays = listWeekdays;
                hooks.parseZone = createInZone;
                hooks.localeData = getLocale;
                hooks.isDuration = isDuration;
                hooks.monthsShort = listMonthsShort;
                hooks.weekdaysMin = listWeekdaysMin;
                hooks.defineLocale = defineLocale;
                hooks.updateLocale = updateLocale;
                hooks.locales = listLocales;
                hooks.weekdaysShort = listWeekdaysShort;
                hooks.normalizeUnits = normalizeUnits;
                hooks.relativeTimeRounding = getSetRelativeTimeRounding;
                hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
                hooks.calendarFormat = getCalendarFormat;
                hooks.prototype = proto;

                return hooks;

            })));

            /* WEBPACK VAR INJECTION */
        }.call(exports, __webpack_require__(117)(module)))

        /***/
    },
    /* 1 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Afrikaans [af]
//! author : Werner Mollentze : https://github.com/wernerm

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var af = moment.defineLocale('af', {
                months: 'Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember'.split('_'),
                monthsShort: 'Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des'.split('_'),
                weekdays: 'Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag'.split('_'),
                weekdaysShort: 'Son_Maa_Din_Woe_Don_Vry_Sat'.split('_'),
                weekdaysMin: 'So_Ma_Di_Wo_Do_Vr_Sa'.split('_'),
                meridiemParse: /vm|nm/i,
                isPM: function (input) {
                    return /^nm$/i.test(input);
                },
                meridiem: function (hours, minutes, isLower) {
                    if (hours < 12) {
                        return isLower ? 'vm' : 'VM';
                    } else {
                        return isLower ? 'nm' : 'NM';
                    }
                },
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY HH:mm',
                    LLLL: 'dddd, D MMMM YYYY HH:mm'
                },
                calendar: {
                    sameDay: '[Vandag om] LT',
                    nextDay: '[Mre om] LT',
                    nextWeek: 'dddd [om] LT',
                    lastDay: '[Gister om] LT',
                    lastWeek: '[Laas] dddd [om] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'oor %s',
                    past: '%s gelede',
                    s: '\'n paar sekondes',
                    m: '\'n minuut',
                    mm: '%d minute',
                    h: '\'n uur',
                    hh: '%d ure',
                    d: '\'n dag',
                    dd: '%d dae',
                    M: '\'n maand',
                    MM: '%d maande',
                    y: '\'n jaar',
                    yy: '%d jaar'
                },
                ordinalParse: /\d{1,2}(ste|de)/,
                ordinal: function (number) {
                    return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de'); // Thanks to Joris Rling : https://github.com/jjupiter
                },
                week: {
                    dow: 1, // Maandag is die eerste dag van die week.
                    doy: 4  // Die week wat die 4de Januarie bevat is die eerste week van die jaar.
                }
            });

            return af;

        })));


        /***/
    },
    /* 2 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic (Algeria) [ar-dz]
//! author : Noureddine LOUAHEDJ : https://github.com/noureddineme

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var arDz = moment.defineLocale('ar-dz', {
                months: '___________'.split('_'),
                monthsShort: '___________'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                weekdaysParseExact: true,
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY HH:mm',
                    LLLL: 'dddd D MMMM YYYY HH:mm'
                },
                calendar: {
                    sameDay: '[  ] LT',
                    nextDay: '[  ] LT',
                    nextWeek: 'dddd [ ] LT',
                    lastDay: '[  ] LT',
                    lastWeek: 'dddd [ ] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: ' %s',
                    past: ' %s',
                    s: '',
                    m: '',
                    mm: '%d ',
                    h: '',
                    hh: '%d ',
                    d: '',
                    dd: '%d ',
                    M: '',
                    MM: '%d ',
                    y: '',
                    yy: '%d '
                },
                week: {
                    dow: 0, // Sunday is the first day of the week.
                    doy: 4  // The week that contains Jan 1st is the first week of the year.
                }
            });

            return arDz;

        })));


        /***/
    },
    /* 3 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic (Lybia) [ar-ly]
//! author : Ali Hmer: https://github.com/kikoanis

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var symbolMap = {
                '1': '1',
                '2': '2',
                '3': '3',
                '4': '4',
                '5': '5',
                '6': '6',
                '7': '7',
                '8': '8',
                '9': '9',
                '0': '0'
            };
            var pluralForm = function (n) {
                return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
            };
            var plurals = {
                s: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
                m: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
                h: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
                d: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
                M: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
                y: ['  ', ' ', ['', ''], '%d ', '%d ', '%d ']
            };
            var pluralize = function (u) {
                return function (number, withoutSuffix, string, isFuture) {
                    var f = pluralForm(number),
                        str = plurals[u][pluralForm(number)];
                    if (f === 2) {
                        str = str[withoutSuffix ? 0 : 1];
                    }
                    return str.replace(/%d/i, number);
                };
            };
            var months = [
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                ''
            ];

            var arLy = moment.defineLocale('ar-ly', {
                months: months,
                monthsShort: months,
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                weekdaysParseExact: true,
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'D/\u200FM/\u200FYYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY HH:mm',
                    LLLL: 'dddd D MMMM YYYY HH:mm'
                },
                meridiemParse: /|/,
                isPM: function (input) {
                    return '' === input;
                },
                meridiem: function (hour, minute, isLower) {
                    if (hour < 12) {
                        return '';
                    } else {
                        return '';
                    }
                },
                calendar: {
                    sameDay: '[  ] LT',
                    nextDay: '[  ] LT',
                    nextWeek: 'dddd [ ] LT',
                    lastDay: '[  ] LT',
                    lastWeek: 'dddd [ ] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: ' %s',
                    past: ' %s',
                    s: pluralize('s'),
                    m: pluralize('m'),
                    mm: pluralize('m'),
                    h: pluralize('h'),
                    hh: pluralize('h'),
                    d: pluralize('d'),
                    dd: pluralize('d'),
                    M: pluralize('M'),
                    MM: pluralize('M'),
                    y: pluralize('y'),
                    yy: pluralize('y')
                },
                preparse: function (string) {
                    return string.replace(/\u200f/g, '').replace(//g, ',');
                },
                postformat: function (string) {
                    return string.replace(/\d/g, function (match) {
                        return symbolMap[match];
                    }).replace(/,/g, '');
                },
                week: {
                    dow: 6, // Saturday is the first day of the week.
                    doy: 12  // The week that contains Jan 1st is the first week of the year.
                }
            });

            return arLy;

        })));


        /***/
    },
    /* 4 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic (Morocco) [ar-ma]
//! author : ElFadili Yassine : https://github.com/ElFadiliY
//! author : Abdel Said : https://github.com/abdelsaid

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var arMa = moment.defineLocale('ar-ma', {
                months: '___________'.split('_'),
                monthsShort: '___________'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                weekdaysParseExact: true,
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY HH:mm',
                    LLLL: 'dddd D MMMM YYYY HH:mm'
                },
                calendar: {
                    sameDay: '[  ] LT',
                    nextDay: '[  ] LT',
                    nextWeek: 'dddd [ ] LT',
                    lastDay: '[  ] LT',
                    lastWeek: 'dddd [ ] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: ' %s',
                    past: ' %s',
                    s: '',
                    m: '',
                    mm: '%d ',
                    h: '',
                    hh: '%d ',
                    d: '',
                    dd: '%d ',
                    M: '',
                    MM: '%d ',
                    y: '',
                    yy: '%d '
                },
                week: {
                    dow: 6, // Saturday is the first day of the week.
                    doy: 12  // The week that contains Jan 1st is the first week of the year.
                }
            });

            return arMa;

        })));


        /***/
    },
    /* 5 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic (Saudi Arabia) [ar-sa]
//! author : Suhail Alkowaileet : https://github.com/xsoh

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var symbolMap = {
                '1': '',
                '2': '',
                '3': '',
                '4': '',
                '5': '',
                '6': '',
                '7': '',
                '8': '',
                '9': '',
                '0': ''
            };
            var numberMap = {
                '': '1',
                '': '2',
                '': '3',
                '': '4',
                '': '5',
                '': '6',
                '': '7',
                '': '8',
                '': '9',
                '': '0'
            };

            var arSa = moment.defineLocale('ar-sa', {
                months: '___________'.split('_'),
                monthsShort: '___________'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                weekdaysParseExact: true,
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY HH:mm',
                    LLLL: 'dddd D MMMM YYYY HH:mm'
                },
                meridiemParse: /|/,
                isPM: function (input) {
                    return '' === input;
                },
                meridiem: function (hour, minute, isLower) {
                    if (hour < 12) {
                        return '';
                    } else {
                        return '';
                    }
                },
                calendar: {
                    sameDay: '[  ] LT',
                    nextDay: '[  ] LT',
                    nextWeek: 'dddd [ ] LT',
                    lastDay: '[  ] LT',
                    lastWeek: 'dddd [ ] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: ' %s',
                    past: ' %s',
                    s: '',
                    m: '',
                    mm: '%d ',
                    h: '',
                    hh: '%d ',
                    d: '',
                    dd: '%d ',
                    M: '',
                    MM: '%d ',
                    y: '',
                    yy: '%d '
                },
                preparse: function (string) {
                    return string.replace(/[]/g, function (match) {
                        return numberMap[match];
                    }).replace(//g, ',');
                },
                postformat: function (string) {
                    return string.replace(/\d/g, function (match) {
                        return symbolMap[match];
                    }).replace(/,/g, '');
                },
                week: {
                    dow: 0, // Sunday is the first day of the week.
                    doy: 6  // The week that contains Jan 1st is the first week of the year.
                }
            });

            return arSa;

        })));


        /***/
    },
    /* 6 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale  :  Arabic (Tunisia) [ar-tn]
//! author : Nader Toukabri : https://github.com/naderio

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var arTn = moment.defineLocale('ar-tn', {
                months: '___________'.split('_'),
                monthsShort: '___________'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                weekdaysParseExact: true,
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY HH:mm',
                    LLLL: 'dddd D MMMM YYYY HH:mm'
                },
                calendar: {
                    sameDay: '[  ] LT',
                    nextDay: '[  ] LT',
                    nextWeek: 'dddd [ ] LT',
                    lastDay: '[  ] LT',
                    lastWeek: 'dddd [ ] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: ' %s',
                    past: ' %s',
                    s: '',
                    m: '',
                    mm: '%d ',
                    h: '',
                    hh: '%d ',
                    d: '',
                    dd: '%d ',
                    M: '',
                    MM: '%d ',
                    y: '',
                    yy: '%d '
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4 // The week that contains Jan 4th is the first week of the year.
                }
            });

            return arTn;

        })));


        /***/
    },
    /* 7 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic [ar]
//! author : Abdel Said: https://github.com/abdelsaid
//! author : Ahmed Elkhatib
//! author : forabi https://github.com/forabi

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var symbolMap = {
                '1': '',
                '2': '',
                '3': '',
                '4': '',
                '5': '',
                '6': '',
                '7': '',
                '8': '',
                '9': '',
                '0': ''
            };
            var numberMap = {
                '': '1',
                '': '2',
                '': '3',
                '': '4',
                '': '5',
                '': '6',
                '': '7',
                '': '8',
                '': '9',
                '': '0'
            };
            var pluralForm = function (n) {
                return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
            };
            var plurals = {
                s: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
                m: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
                h: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
                d: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
                M: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
                y: ['  ', ' ', ['', ''], '%d ', '%d ', '%d ']
            };
            var pluralize = function (u) {
                return function (number, withoutSuffix, string, isFuture) {
                    var f = pluralForm(number),
                        str = plurals[u][pluralForm(number)];
                    if (f === 2) {
                        str = str[withoutSuffix ? 0 : 1];
                    }
                    return str.replace(/%d/i, number);
                };
            };
            var months = [
                '  ',
                ' ',
                ' ',
                ' ',
                ' ',
                ' ',
                ' ',
                ' ',
                ' ',
                '  ',
                '  ',
                '  '
            ];

            var ar = moment.defineLocale('ar', {
                months: months,
                monthsShort: months,
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                weekdaysParseExact: true,
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'D/\u200FM/\u200FYYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY HH:mm',
                    LLLL: 'dddd D MMMM YYYY HH:mm'
                },
                meridiemParse: /|/,
                isPM: function (input) {
                    return '' === input;
                },
                meridiem: function (hour, minute, isLower) {
                    if (hour < 12) {
                        return '';
                    } else {
                        return '';
                    }
                },
                calendar: {
                    sameDay: '[  ] LT',
                    nextDay: '[  ] LT',
                    nextWeek: 'dddd [ ] LT',
                    lastDay: '[  ] LT',
                    lastWeek: 'dddd [ ] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: ' %s',
                    past: ' %s',
                    s: pluralize('s'),
                    m: pluralize('m'),
                    mm: pluralize('m'),
                    h: pluralize('h'),
                    hh: pluralize('h'),
                    d: pluralize('d'),
                    dd: pluralize('d'),
                    M: pluralize('M'),
                    MM: pluralize('M'),
                    y: pluralize('y'),
                    yy: pluralize('y')
                },
                preparse: function (string) {
                    return string.replace(/\u200f/g, '').replace(/[]/g, function (match) {
                        return numberMap[match];
                    }).replace(//g, ',');
                },
                postformat: function (string) {
                    return string.replace(/\d/g, function (match) {
                        return symbolMap[match];
                    }).replace(/,/g, '');
                },
                week: {
                    dow: 6, // Saturday is the first day of the week.
                    doy: 12  // The week that contains Jan 1st is the first week of the year.
                }
            });

            return ar;

        })));


        /***/
    },
    /* 8 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Azerbaijani [az]
//! author : topchiyev : https://github.com/topchiyev

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var suffixes = {
                1: '-inci',
                5: '-inci',
                8: '-inci',
                70: '-inci',
                80: '-inci',
                2: '-nci',
                7: '-nci',
                20: '-nci',
                50: '-nci',
                3: '-nc',
                4: '-nc',
                100: '-nc',
                6: '-nc',
                9: '-uncu',
                10: '-uncu',
                30: '-uncu',
                60: '-nc',
                90: '-nc'
            };

            var az = moment.defineLocale('az', {
                months: 'yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr'.split('_'),
                monthsShort: 'yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek'.split('_'),
                weekdays: 'Bazar_Bazar ertsi_rnb axam_rnb_Cm axam_Cm_nb'.split('_'),
                weekdaysShort: 'Baz_BzE_Ax_r_CAx_Cm_n'.split('_'),
                weekdaysMin: 'Bz_BE_A__CA_C_'.split('_'),
                weekdaysParseExact: true,
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD.MM.YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY HH:mm',
                    LLLL: 'dddd, D MMMM YYYY HH:mm'
                },
                calendar: {
                    sameDay: '[bugn saat] LT',
                    nextDay: '[sabah saat] LT',
                    nextWeek: '[gln hft] dddd [saat] LT',
                    lastDay: '[dnn] LT',
                    lastWeek: '[ken hft] dddd [saat] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: '%s sonra',
                    past: '%s vvl',
                    s: 'birne saniyy',
                    m: 'bir dqiq',
                    mm: '%d dqiq',
                    h: 'bir saat',
                    hh: '%d saat',
                    d: 'bir gn',
                    dd: '%d gn',
                    M: 'bir ay',
                    MM: '%d ay',
                    y: 'bir il',
                    yy: '%d il'
                },
                meridiemParse: /gec|shr|gndz|axam/,
                isPM: function (input) {
                    return /^(gndz|axam)$/.test(input);
                },
                meridiem: function (hour, minute, isLower) {
                    if (hour < 4) {
                        return 'gec';
                    } else if (hour < 12) {
                        return 'shr';
                    } else if (hour < 17) {
                        return 'gndz';
                    } else {
                        return 'axam';
                    }
                },
                ordinalParse: /\d{1,2}-(nc|inci|nci|nc|nc|uncu)/,
                ordinal: function (number) {
                    if (number === 0) {  // special case for zero
                        return number + '-nc';
                    }
                    var a = number % 10,
                        b = number % 100 - a,
                        c = number >= 100 ? 100 : null;
                    return number + (suffixes[a] || suffixes[b] || suffixes[c]);
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7  // The week that contains Jan 1st is the first week of the year.
                }
            });

            return az;

        })));


        /***/
    },
    /* 9 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Belarusian [be]
//! author : Dmitry Demidov : https://github.com/demidov91
//! author: Praleska: http://praleska.pro/
//! Author : Menelion Elensle : https://github.com/Oire

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            function plural(word, num) {
                var forms = word.split('_');
                return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
            }

            function relativeTimeWithPlural(number, withoutSuffix, key) {
                var format = {
                    'mm': withoutSuffix ? '__' : '__',
                    'hh': withoutSuffix ? '__' : '__',
                    'dd': '__',
                    'MM': '__',
                    'yy': '__'
                };
                if (key === 'm') {
                    return withoutSuffix ? '' : '';
                }
                else if (key === 'h') {
                    return withoutSuffix ? '' : '';
                }
                else {
                    return number + ' ' + plural(format[key], +number);
                }
            }

            var be = moment.defineLocale('be', {
                months: {
                    format: '___________'.split('_'),
                    standalone: '___________'.split('_')
                },
                monthsShort: '___________'.split('_'),
                weekdays: {
                    format: '______'.split('_'),
                    standalone: '______'.split('_'),
                    isFormat: /\[ ?[] ?(?:|)? ?\] ?dddd/
                },
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD.MM.YYYY',
                    LL: 'D MMMM YYYY .',
                    LLL: 'D MMMM YYYY ., HH:mm',
                    LLLL: 'dddd, D MMMM YYYY ., HH:mm'
                },
                calendar: {
                    sameDay: '[ ] LT',
                    nextDay: '[ ] LT',
                    lastDay: '[ ] LT',
                    nextWeek: function () {
                        return '[] dddd [] LT';
                    },
                    lastWeek: function () {
                        switch (this.day()) {
                            case 0:
                            case 3:
                            case 5:
                            case 6:
                                return '[ ] dddd [] LT';
                            case 1:
                            case 2:
                            case 4:
                                return '[ ] dddd [] LT';
                        }
                    },
                    sameElse: 'L'
                },
                relativeTime: {
                    future: ' %s',
                    past: '%s ',
                    s: ' ',
                    m: relativeTimeWithPlural,
                    mm: relativeTimeWithPlural,
                    h: relativeTimeWithPlural,
                    hh: relativeTimeWithPlural,
                    d: '',
                    dd: relativeTimeWithPlural,
                    M: '',
                    MM: relativeTimeWithPlural,
                    y: '',
                    yy: relativeTimeWithPlural
                },
                meridiemParse: /|||/,
                isPM: function (input) {
                    return /^(|)$/.test(input);
                },
                meridiem: function (hour, minute, isLower) {
                    if (hour < 4) {
                        return '';
                    } else if (hour < 12) {
                        return '';
                    } else if (hour < 17) {
                        return '';
                    } else {
                        return '';
                    }
                },
                ordinalParse: /\d{1,2}-(||)/,
                ordinal: function (number, period) {
                    switch (period) {
                        case 'M':
                        case 'd':
                        case 'DDD':
                        case 'w':
                        case 'W':
                            return (number % 10 === 2 || number % 10 === 3) && (number % 100 !== 12 && number % 100 !== 13) ? number + '-' : number + '-';
                        case 'D':
                            return number + '-';
                        default:
                            return number;
                    }
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7  // The week that contains Jan 1st is the first week of the year.
                }
            });

            return be;

        })));


        /***/
    },
    /* 10 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Bulgarian [bg]
//! author : Krasen Borisov : https://github.com/kraz

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var bg = moment.defineLocale('bg', {
                months: '___________'.split('_'),
                monthsShort: '___________'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'H:mm',
                    LTS: 'H:mm:ss',
                    L: 'D.MM.YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY H:mm',
                    LLLL: 'dddd, D MMMM YYYY H:mm'
                },
                calendar: {
                    sameDay: '[ ] LT',
                    nextDay: '[ ] LT',
                    nextWeek: 'dddd [] LT',
                    lastDay: '[ ] LT',
                    lastWeek: function () {
                        switch (this.day()) {
                            case 0:
                            case 3:
                            case 6:
                                return '[ ] dddd [] LT';
                            case 1:
                            case 2:
                            case 4:
                            case 5:
                                return '[ ] dddd [] LT';
                        }
                    },
                    sameElse: 'L'
                },
                relativeTime: {
                    future: ' %s',
                    past: ' %s',
                    s: ' ',
                    m: '',
                    mm: '%d ',
                    h: '',
                    hh: '%d ',
                    d: '',
                    dd: '%d ',
                    M: '',
                    MM: '%d ',
                    y: '',
                    yy: '%d '
                },
                ordinalParse: /\d{1,2}-(|||||)/,
                ordinal: function (number) {
                    var lastDigit = number % 10,
                        last2Digits = number % 100;
                    if (number === 0) {
                        return number + '-';
                    } else if (last2Digits === 0) {
                        return number + '-';
                    } else if (last2Digits > 10 && last2Digits < 20) {
                        return number + '-';
                    } else if (lastDigit === 1) {
                        return number + '-';
                    } else if (lastDigit === 2) {
                        return number + '-';
                    } else if (lastDigit === 7 || lastDigit === 8) {
                        return number + '-';
                    } else {
                        return number + '-';
                    }
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7  // The week that contains Jan 1st is the first week of the year.
                }
            });

            return bg;

        })));


        /***/
    },
    /* 11 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Bengali [bn]
//! author : Kaushik Gandhi : https://github.com/kaushikgandhi

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var symbolMap = {
                '1': '',
                '2': '',
                '3': '',
                '4': '',
                '5': '',
                '6': '',
                '7': '',
                '8': '',
                '9': '',
                '0': ''
            };
            var numberMap = {
                '': '1',
                '': '2',
                '': '3',
                '': '4',
                '': '5',
                '': '6',
                '': '7',
                '': '8',
                '': '9',
                '': '0'
            };

            var bn = moment.defineLocale('bn', {
                months: '___________'.split('_'),
                monthsShort: '___________'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'A h:mm ',
                    LTS: 'A h:mm:ss ',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY, A h:mm ',
                    LLLL: 'dddd, D MMMM YYYY, A h:mm '
                },
                calendar: {
                    sameDay: '[] LT',
                    nextDay: '[] LT',
                    nextWeek: 'dddd, LT',
                    lastDay: '[] LT',
                    lastWeek: '[] dddd, LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: '%s ',
                    past: '%s ',
                    s: ' ',
                    m: ' ',
                    mm: '%d ',
                    h: ' ',
                    hh: '%d ',
                    d: ' ',
                    dd: '%d ',
                    M: ' ',
                    MM: '%d ',
                    y: ' ',
                    yy: '%d '
                },
                preparse: function (string) {
                    return string.replace(/[]/g, function (match) {
                        return numberMap[match];
                    });
                },
                postformat: function (string) {
                    return string.replace(/\d/g, function (match) {
                        return symbolMap[match];
                    });
                },
                meridiemParse: /||||/,
                meridiemHour: function (hour, meridiem) {
                    if (hour === 12) {
                        hour = 0;
                    }
                    if ((meridiem === '' && hour >= 4) ||
                        (meridiem === '' && hour < 5) ||
                        meridiem === '') {
                        return hour + 12;
                    } else {
                        return hour;
                    }
                },
                meridiem: function (hour, minute, isLower) {
                    if (hour < 4) {
                        return '';
                    } else if (hour < 10) {
                        return '';
                    } else if (hour < 17) {
                        return '';
                    } else if (hour < 20) {
                        return '';
                    } else {
                        return '';
                    }
                },
                week: {
                    dow: 0, // Sunday is the first day of the week.
                    doy: 6  // The week that contains Jan 1st is the first week of the year.
                }
            });

            return bn;

        })));


        /***/
    },
    /* 12 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Tibetan [bo]
//! author : Thupten N. Chakrishar : https://github.com/vajradog

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var symbolMap = {
                '1': '',
                '2': '',
                '3': '',
                '4': '',
                '5': '',
                '6': '',
                '7': '',
                '8': '',
                '9': '',
                '0': ''
            };
            var numberMap = {
                '': '1',
                '': '2',
                '': '3',
                '': '4',
                '': '5',
                '': '6',
                '': '7',
                '': '8',
                '': '9',
                '': '0'
            };

            var bo = moment.defineLocale('bo', {
                months: '___________'.split('_'),
                monthsShort: '___________'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'A h:mm',
                    LTS: 'A h:mm:ss',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY, A h:mm',
                    LLLL: 'dddd, D MMMM YYYY, A h:mm'
                },
                calendar: {
                    sameDay: '[] LT',
                    nextDay: '[] LT',
                    nextWeek: '[], LT',
                    lastDay: '[] LT',
                    lastWeek: '[] dddd, LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: '%s ',
                    past: '%s ',
                    s: '',
                    m: '',
                    mm: '%d ',
                    h: '',
                    hh: '%d ',
                    d: '',
                    dd: '%d ',
                    M: '',
                    MM: '%d ',
                    y: '',
                    yy: '%d '
                },
                preparse: function (string) {
                    return string.replace(/[]/g, function (match) {
                        return numberMap[match];
                    });
                },
                postformat: function (string) {
                    return string.replace(/\d/g, function (match) {
                        return symbolMap[match];
                    });
                },
                meridiemParse: /||||/,
                meridiemHour: function (hour, meridiem) {
                    if (hour === 12) {
                        hour = 0;
                    }
                    if ((meridiem === '' && hour >= 4) ||
                        (meridiem === '' && hour < 5) ||
                        meridiem === '') {
                        return hour + 12;
                    } else {
                        return hour;
                    }
                },
                meridiem: function (hour, minute, isLower) {
                    if (hour < 4) {
                        return '';
                    } else if (hour < 10) {
                        return '';
                    } else if (hour < 17) {
                        return '';
                    } else if (hour < 20) {
                        return '';
                    } else {
                        return '';
                    }
                },
                week: {
                    dow: 0, // Sunday is the first day of the week.
                    doy: 6  // The week that contains Jan 1st is the first week of the year.
                }
            });

            return bo;

        })));


        /***/
    },
    /* 13 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Breton [br]
//! author : Jean-Baptiste Le Duigou : https://github.com/jbleduigou

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            function relativeTimeWithMutation(number, withoutSuffix, key) {
                var format = {
                    'mm': 'munutenn',
                    'MM': 'miz',
                    'dd': 'devezh'
                };
                return number + ' ' + mutation(format[key], number);
            }

            function specialMutationForYears(number) {
                switch (lastNumber(number)) {
                    case 1:
                    case 3:
                    case 4:
                    case 5:
                    case 9:
                        return number + ' bloaz';
                    default:
                        return number + ' vloaz';
                }
            }

            function lastNumber(number) {
                if (number > 9) {
                    return lastNumber(number % 10);
                }
                return number;
            }

            function mutation(text, number) {
                if (number === 2) {
                    return softMutation(text);
                }
                return text;
            }

            function softMutation(text) {
                var mutationTable = {
                    'm': 'v',
                    'b': 'v',
                    'd': 'z'
                };
                if (mutationTable[text.charAt(0)] === undefined) {
                    return text;
                }
                return mutationTable[text.charAt(0)] + text.substring(1);
            }

            var br = moment.defineLocale('br', {
                months: 'Genver_C\'hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu'.split('_'),
                monthsShort: 'Gen_C\'hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker'.split('_'),
                weekdays: 'Sul_Lun_Meurzh_Merc\'her_Yaou_Gwener_Sadorn'.split('_'),
                weekdaysShort: 'Sul_Lun_Meu_Mer_Yao_Gwe_Sad'.split('_'),
                weekdaysMin: 'Su_Lu_Me_Mer_Ya_Gw_Sa'.split('_'),
                weekdaysParseExact: true,
                longDateFormat: {
                    LT: 'h[e]mm A',
                    LTS: 'h[e]mm:ss A',
                    L: 'DD/MM/YYYY',
                    LL: 'D [a viz] MMMM YYYY',
                    LLL: 'D [a viz] MMMM YYYY h[e]mm A',
                    LLLL: 'dddd, D [a viz] MMMM YYYY h[e]mm A'
                },
                calendar: {
                    sameDay: '[Hiziv da] LT',
                    nextDay: '[Warc\'hoazh da] LT',
                    nextWeek: 'dddd [da] LT',
                    lastDay: '[Dec\'h da] LT',
                    lastWeek: 'dddd [paset da] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'a-benn %s',
                    past: '%s \'zo',
                    s: 'un nebeud segondenno',
                    m: 'ur vunutenn',
                    mm: relativeTimeWithMutation,
                    h: 'un eur',
                    hh: '%d eur',
                    d: 'un devezh',
                    dd: relativeTimeWithMutation,
                    M: 'ur miz',
                    MM: relativeTimeWithMutation,
                    y: 'ur bloaz',
                    yy: specialMutationForYears
                },
                ordinalParse: /\d{1,2}(a|vet)/,
                ordinal: function (number) {
                    var output = (number === 1) ? 'a' : 'vet';
                    return number + output;
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4  // The week that contains Jan 4th is the first week of the year.
                }
            });

            return br;

        })));


        /***/
    },
    /* 14 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Bosnian [bs]
//! author : Nedim Cholich : https://github.com/frontyard
//! based on (hr) translation by Bojan Markovi

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            function translate(number, withoutSuffix, key) {
                var result = number + ' ';
                switch (key) {
                    case 'm':
                        return withoutSuffix ? 'jedna minuta' : 'jedne minute';
                    case 'mm':
                        if (number === 1) {
                            result += 'minuta';
                        } else if (number === 2 || number === 3 || number === 4) {
                            result += 'minute';
                        } else {
                            result += 'minuta';
                        }
                        return result;
                    case 'h':
                        return withoutSuffix ? 'jedan sat' : 'jednog sata';
                    case 'hh':
                        if (number === 1) {
                            result += 'sat';
                        } else if (number === 2 || number === 3 || number === 4) {
                            result += 'sata';
                        } else {
                            result += 'sati';
                        }
                        return result;
                    case 'dd':
                        if (number === 1) {
                            result += 'dan';
                        } else {
                            result += 'dana';
                        }
                        return result;
                    case 'MM':
                        if (number === 1) {
                            result += 'mjesec';
                        } else if (number === 2 || number === 3 || number === 4) {
                            result += 'mjeseca';
                        } else {
                            result += 'mjeseci';
                        }
                        return result;
                    case 'yy':
                        if (number === 1) {
                            result += 'godina';
                        } else if (number === 2 || number === 3 || number === 4) {
                            result += 'godine';
                        } else {
                            result += 'godina';
                        }
                        return result;
                }
            }

            var bs = moment.defineLocale('bs', {
                months: 'januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar'.split('_'),
                monthsShort: 'jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.'.split('_'),
                monthsParseExact: true,
                weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
                weekdaysShort: 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
                weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
                weekdaysParseExact: true,
                longDateFormat: {
                    LT: 'H:mm',
                    LTS: 'H:mm:ss',
                    L: 'DD.MM.YYYY',
                    LL: 'D. MMMM YYYY',
                    LLL: 'D. MMMM YYYY H:mm',
                    LLLL: 'dddd, D. MMMM YYYY H:mm'
                },
                calendar: {
                    sameDay: '[danas u] LT',
                    nextDay: '[sutra u] LT',
                    nextWeek: function () {
                        switch (this.day()) {
                            case 0:
                                return '[u] [nedjelju] [u] LT';
                            case 3:
                                return '[u] [srijedu] [u] LT';
                            case 6:
                                return '[u] [subotu] [u] LT';
                            case 1:
                            case 2:
                            case 4:
                            case 5:
                                return '[u] dddd [u] LT';
                        }
                    },
                    lastDay: '[juer u] LT',
                    lastWeek: function () {
                        switch (this.day()) {
                            case 0:
                            case 3:
                                return '[prolu] dddd [u] LT';
                            case 6:
                                return '[prole] [subote] [u] LT';
                            case 1:
                            case 2:
                            case 4:
                            case 5:
                                return '[proli] dddd [u] LT';
                        }
                    },
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'za %s',
                    past: 'prije %s',
                    s: 'par sekundi',
                    m: translate,
                    mm: translate,
                    h: translate,
                    hh: translate,
                    d: 'dan',
                    dd: translate,
                    M: 'mjesec',
                    MM: translate,
                    y: 'godinu',
                    yy: translate
                },
                ordinalParse: /\d{1,2}\./,
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7  // The week that contains Jan 1st is the first week of the year.
                }
            });

            return bs;

        })));


        /***/
    },
    /* 15 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Catalan [ca]
//! author : Juan G. Hurtado : https://github.com/juanghurtado

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var ca = moment.defineLocale('ca', {
                months: 'gener_febrer_mar_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre'.split('_'),
                monthsShort: 'gen._febr._mar._abr._mai._jun._jul._ag._set._oct._nov._des.'.split('_'),
                monthsParseExact: true,
                weekdays: 'diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte'.split('_'),
                weekdaysShort: 'dg._dl._dt._dc._dj._dv._ds.'.split('_'),
                weekdaysMin: 'Dg_Dl_Dt_Dc_Dj_Dv_Ds'.split('_'),
                weekdaysParseExact: true,
                longDateFormat: {
                    LT: 'H:mm',
                    LTS: 'H:mm:ss',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY H:mm',
                    LLLL: 'dddd D MMMM YYYY H:mm'
                },
                calendar: {
                    sameDay: function () {
                        return '[avui a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
                    },
                    nextDay: function () {
                        return '[dem a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
                    },
                    nextWeek: function () {
                        return 'dddd [a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
                    },
                    lastDay: function () {
                        return '[ahir a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
                    },
                    lastWeek: function () {
                        return '[el] dddd [passat a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
                    },
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'd\'aqu %s',
                    past: 'fa %s',
                    s: 'uns segons',
                    m: 'un minut',
                    mm: '%d minuts',
                    h: 'una hora',
                    hh: '%d hores',
                    d: 'un dia',
                    dd: '%d dies',
                    M: 'un mes',
                    MM: '%d mesos',
                    y: 'un any',
                    yy: '%d anys'
                },
                ordinalParse: /\d{1,2}(r|n|t||a)/,
                ordinal: function (number, period) {
                    var output = (number === 1) ? 'r' :
                        (number === 2) ? 'n' :
                            (number === 3) ? 'r' :
                                (number === 4) ? 't' : '';
                    if (period === 'w' || period === 'W') {
                        output = 'a';
                    }
                    return number + output;
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4  // The week that contains Jan 4th is the first week of the year.
                }
            });

            return ca;

        })));


        /***/
    },
    /* 16 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Czech [cs]
//! author : petrbela : https://github.com/petrbela

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var months = 'leden_nor_bezen_duben_kvten_erven_ervenec_srpen_z_jen_listopad_prosinec'.split('_');
            var monthsShort = 'led_no_be_dub_kv_vn_vc_srp_z_j_lis_pro'.split('_');

            function plural(n) {
                return (n > 1) && (n < 5) && (~~(n / 10) !== 1);
            }

            function translate(number, withoutSuffix, key, isFuture) {
                var result = number + ' ';
                switch (key) {
                    case 's':  // a few seconds / in a few seconds / a few seconds ago
                        return (withoutSuffix || isFuture) ? 'pr sekund' : 'pr sekundami';
                    case 'm':  // a minute / in a minute / a minute ago
                        return withoutSuffix ? 'minuta' : (isFuture ? 'minutu' : 'minutou');
                    case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
                        if (withoutSuffix || isFuture) {
                            return result + (plural(number) ? 'minuty' : 'minut');
                        } else {
                            return result + 'minutami';
                        }
                        break;
                    case 'h':  // an hour / in an hour / an hour ago
                        return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
                    case 'hh': // 9 hours / in 9 hours / 9 hours ago
                        if (withoutSuffix || isFuture) {
                            return result + (plural(number) ? 'hodiny' : 'hodin');
                        } else {
                            return result + 'hodinami';
                        }
                        break;
                    case 'd':  // a day / in a day / a day ago
                        return (withoutSuffix || isFuture) ? 'den' : 'dnem';
                    case 'dd': // 9 days / in 9 days / 9 days ago
                        if (withoutSuffix || isFuture) {
                            return result + (plural(number) ? 'dny' : 'dn');
                        } else {
                            return result + 'dny';
                        }
                        break;
                    case 'M':  // a month / in a month / a month ago
                        return (withoutSuffix || isFuture) ? 'msc' : 'mscem';
                    case 'MM': // 9 months / in 9 months / 9 months ago
                        if (withoutSuffix || isFuture) {
                            return result + (plural(number) ? 'msce' : 'msc');
                        } else {
                            return result + 'msci';
                        }
                        break;
                    case 'y':  // a year / in a year / a year ago
                        return (withoutSuffix || isFuture) ? 'rok' : 'rokem';
                    case 'yy': // 9 years / in 9 years / 9 years ago
                        if (withoutSuffix || isFuture) {
                            return result + (plural(number) ? 'roky' : 'let');
                        } else {
                            return result + 'lety';
                        }
                        break;
                }
            }

            var cs = moment.defineLocale('cs', {
                months: months,
                monthsShort: monthsShort,
                monthsParse: (function (months, monthsShort) {
                    var i, _monthsParse = [];
                    for (i = 0; i < 12; i++) {
                        // use custom parser to solve problem with July (ervenec)
                        _monthsParse[i] = new RegExp('^' + months[i] + '$|^' + monthsShort[i] + '$', 'i');
                    }
                    return _monthsParse;
                }(months, monthsShort)),
                shortMonthsParse: (function (monthsShort) {
                    var i, _shortMonthsParse = [];
                    for (i = 0; i < 12; i++) {
                        _shortMonthsParse[i] = new RegExp('^' + monthsShort[i] + '$', 'i');
                    }
                    return _shortMonthsParse;
                }(monthsShort)),
                longMonthsParse: (function (months) {
                    var i, _longMonthsParse = [];
                    for (i = 0; i < 12; i++) {
                        _longMonthsParse[i] = new RegExp('^' + months[i] + '$', 'i');
                    }
                    return _longMonthsParse;
                }(months)),
                weekdays: 'nedle_pondl_ter_steda_tvrtek_ptek_sobota'.split('_'),
                weekdaysShort: 'ne_po_t_st_t_p_so'.split('_'),
                weekdaysMin: 'ne_po_t_st_t_p_so'.split('_'),
                longDateFormat: {
                    LT: 'H:mm',
                    LTS: 'H:mm:ss',
                    L: 'DD.MM.YYYY',
                    LL: 'D. MMMM YYYY',
                    LLL: 'D. MMMM YYYY H:mm',
                    LLLL: 'dddd D. MMMM YYYY H:mm',
                    l: 'D. M. YYYY'
                },
                calendar: {
                    sameDay: '[dnes v] LT',
                    nextDay: '[ztra v] LT',
                    nextWeek: function () {
                        switch (this.day()) {
                            case 0:
                                return '[v nedli v] LT';
                            case 1:
                            case 2:
                                return '[v] dddd [v] LT';
                            case 3:
                                return '[ve stedu v] LT';
                            case 4:
                                return '[ve tvrtek v] LT';
                            case 5:
                                return '[v ptek v] LT';
                            case 6:
                                return '[v sobotu v] LT';
                        }
                    },
                    lastDay: '[vera v] LT',
                    lastWeek: function () {
                        switch (this.day()) {
                            case 0:
                                return '[minulou nedli v] LT';
                            case 1:
                            case 2:
                                return '[minul] dddd [v] LT';
                            case 3:
                                return '[minulou stedu v] LT';
                            case 4:
                            case 5:
                                return '[minul] dddd [v] LT';
                            case 6:
                                return '[minulou sobotu v] LT';
                        }
                    },
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'za %s',
                    past: 'ped %s',
                    s: translate,
                    m: translate,
                    mm: translate,
                    h: translate,
                    hh: translate,
                    d: translate,
                    dd: translate,
                    M: translate,
                    MM: translate,
                    y: translate,
                    yy: translate
                },
                ordinalParse: /\d{1,2}\./,
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4  // The week that contains Jan 4th is the first week of the year.
                }
            });

            return cs;

        })));


        /***/
    },
    /* 17 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Chuvash [cv]
//! author : Anatoly Mironov : https://github.com/mirontoli

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var cv = moment.defineLocale('cv', {
                months: '___________'.split('_'),
                monthsShort: '___________'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD-MM-YYYY',
                    LL: 'YYYY [] MMMM [] D[-]',
                    LLL: 'YYYY [] MMMM [] D[-], HH:mm',
                    LLLL: 'dddd, YYYY [] MMMM [] D[-], HH:mm'
                },
                calendar: {
                    sameDay: '[] LT []',
                    nextDay: '[] LT []',
                    lastDay: '[] LT []',
                    nextWeek: '[] dddd LT []',
                    lastWeek: '[] dddd LT []',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: function (output) {
                        var affix = /$/i.exec(output) ? '' : /$/i.exec(output) ? '' : '';
                        return output + affix;
                    },
                    past: '%s ',
                    s: '- ',
                    m: ' ',
                    mm: '%d ',
                    h: ' ',
                    hh: '%d ',
                    d: ' ',
                    dd: '%d ',
                    M: ' ',
                    MM: '%d ',
                    y: ' ',
                    yy: '%d '
                },
                ordinalParse: /\d{1,2}-/,
                ordinal: '%d-',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7  // The week that contains Jan 1st is the first week of the year.
                }
            });

            return cv;

        })));


        /***/
    },
    /* 18 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Welsh [cy]
//! author : Robert Allen : https://github.com/robgallen
//! author : https://github.com/ryangreaves

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var cy = moment.defineLocale('cy', {
                months: 'Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr'.split('_'),
                monthsShort: 'Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag'.split('_'),
                weekdays: 'Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn'.split('_'),
                weekdaysShort: 'Sul_Llun_Maw_Mer_Iau_Gwe_Sad'.split('_'),
                weekdaysMin: 'Su_Ll_Ma_Me_Ia_Gw_Sa'.split('_'),
                weekdaysParseExact: true,
                // time formats are the same as en-gb
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY HH:mm',
                    LLLL: 'dddd, D MMMM YYYY HH:mm'
                },
                calendar: {
                    sameDay: '[Heddiw am] LT',
                    nextDay: '[Yfory am] LT',
                    nextWeek: 'dddd [am] LT',
                    lastDay: '[Ddoe am] LT',
                    lastWeek: 'dddd [diwethaf am] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'mewn %s',
                    past: '%s yn l',
                    s: 'ychydig eiliadau',
                    m: 'munud',
                    mm: '%d munud',
                    h: 'awr',
                    hh: '%d awr',
                    d: 'diwrnod',
                    dd: '%d diwrnod',
                    M: 'mis',
                    MM: '%d mis',
                    y: 'blwyddyn',
                    yy: '%d flynedd'
                },
                ordinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
                // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
                ordinal: function (number) {
                    var b = number,
                        output = '',
                        lookup = [
                            '', 'af', 'il', 'ydd', 'ydd', 'ed', 'ed', 'ed', 'fed', 'fed', 'fed', // 1af to 10fed
                            'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'fed' // 11eg to 20fed
                        ];
                    if (b > 20) {
                        if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
                            output = 'fed'; // not 30ain, 70ain or 90ain
                        } else {
                            output = 'ain';
                        }
                    } else if (b > 0) {
                        output = lookup[b];
                    }
                    return number + output;
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4  // The week that contains Jan 4th is the first week of the year.
                }
            });

            return cy;

        })));


        /***/
    },
    /* 19 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Danish [da]
//! author : Ulrik Nielsen : https://github.com/mrbase

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var da = moment.defineLocale('da', {
                months: 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split('_'),
                monthsShort: 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
                weekdays: 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
                weekdaysShort: 'sn_man_tir_ons_tor_fre_lr'.split('_'),
                weekdaysMin: 's_ma_ti_on_to_fr_l'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD/MM/YYYY',
                    LL: 'D. MMMM YYYY',
                    LLL: 'D. MMMM YYYY HH:mm',
                    LLLL: 'dddd [d.] D. MMMM YYYY HH:mm'
                },
                calendar: {
                    sameDay: '[I dag kl.] LT',
                    nextDay: '[I morgen kl.] LT',
                    nextWeek: 'dddd [kl.] LT',
                    lastDay: '[I gr kl.] LT',
                    lastWeek: '[sidste] dddd [kl] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'om %s',
                    past: '%s siden',
                    s: 'f sekunder',
                    m: 'et minut',
                    mm: '%d minutter',
                    h: 'en time',
                    hh: '%d timer',
                    d: 'en dag',
                    dd: '%d dage',
                    M: 'en mned',
                    MM: '%d mneder',
                    y: 'et r',
                    yy: '%d r'
                },
                ordinalParse: /\d{1,2}\./,
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4  // The week that contains Jan 4th is the first week of the year.
                }
            });

            return da;

        })));


        /***/
    },
    /* 20 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : German (Austria) [de-at]
//! author : lluchs : https://github.com/lluchs
//! author: Menelion Elensle: https://github.com/Oire
//! author : Martin Groller : https://github.com/MadMG
//! author : Mikolaj Dadela : https://github.com/mik01aj

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            function processRelativeTime(number, withoutSuffix, key, isFuture) {
                var format = {
                    'm': ['eine Minute', 'einer Minute'],
                    'h': ['eine Stunde', 'einer Stunde'],
                    'd': ['ein Tag', 'einem Tag'],
                    'dd': [number + ' Tage', number + ' Tagen'],
                    'M': ['ein Monat', 'einem Monat'],
                    'MM': [number + ' Monate', number + ' Monaten'],
                    'y': ['ein Jahr', 'einem Jahr'],
                    'yy': [number + ' Jahre', number + ' Jahren']
                };
                return withoutSuffix ? format[key][0] : format[key][1];
            }

            var deAt = moment.defineLocale('de-at', {
                months: 'Jnner_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
                monthsShort: 'Jn._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
                monthsParseExact: true,
                weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
                weekdaysShort: 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
                weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
                weekdaysParseExact: true,
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD.MM.YYYY',
                    LL: 'D. MMMM YYYY',
                    LLL: 'D. MMMM YYYY HH:mm',
                    LLLL: 'dddd, D. MMMM YYYY HH:mm'
                },
                calendar: {
                    sameDay: '[heute um] LT [Uhr]',
                    sameElse: 'L',
                    nextDay: '[morgen um] LT [Uhr]',
                    nextWeek: 'dddd [um] LT [Uhr]',
                    lastDay: '[gestern um] LT [Uhr]',
                    lastWeek: '[letzten] dddd [um] LT [Uhr]'
                },
                relativeTime: {
                    future: 'in %s',
                    past: 'vor %s',
                    s: 'ein paar Sekunden',
                    m: processRelativeTime,
                    mm: '%d Minuten',
                    h: processRelativeTime,
                    hh: '%d Stunden',
                    d: processRelativeTime,
                    dd: processRelativeTime,
                    M: processRelativeTime,
                    MM: processRelativeTime,
                    y: processRelativeTime,
                    yy: processRelativeTime
                },
                ordinalParse: /\d{1,2}\./,
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4  // The week that contains Jan 4th is the first week of the year.
                }
            });

            return deAt;

        })));


        /***/
    },
    /* 21 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : German [de]
//! author : lluchs : https://github.com/lluchs
//! author: Menelion Elensle: https://github.com/Oire
//! author : Mikolaj Dadela : https://github.com/mik01aj

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            function processRelativeTime(number, withoutSuffix, key, isFuture) {
                var format = {
                    'm': ['eine Minute', 'einer Minute'],
                    'h': ['eine Stunde', 'einer Stunde'],
                    'd': ['ein Tag', 'einem Tag'],
                    'dd': [number + ' Tage', number + ' Tagen'],
                    'M': ['ein Monat', 'einem Monat'],
                    'MM': [number + ' Monate', number + ' Monaten'],
                    'y': ['ein Jahr', 'einem Jahr'],
                    'yy': [number + ' Jahre', number + ' Jahren']
                };
                return withoutSuffix ? format[key][0] : format[key][1];
            }

            var de = moment.defineLocale('de', {
                months: 'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
                monthsShort: 'Jan._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
                monthsParseExact: true,
                weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
                weekdaysShort: 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
                weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
                weekdaysParseExact: true,
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD.MM.YYYY',
                    LL: 'D. MMMM YYYY',
                    LLL: 'D. MMMM YYYY HH:mm',
                    LLLL: 'dddd, D. MMMM YYYY HH:mm'
                },
                calendar: {
                    sameDay: '[heute um] LT [Uhr]',
                    sameElse: 'L',
                    nextDay: '[morgen um] LT [Uhr]',
                    nextWeek: 'dddd [um] LT [Uhr]',
                    lastDay: '[gestern um] LT [Uhr]',
                    lastWeek: '[letzten] dddd [um] LT [Uhr]'
                },
                relativeTime: {
                    future: 'in %s',
                    past: 'vor %s',
                    s: 'ein paar Sekunden',
                    m: processRelativeTime,
                    mm: '%d Minuten',
                    h: processRelativeTime,
                    hh: '%d Stunden',
                    d: processRelativeTime,
                    dd: processRelativeTime,
                    M: processRelativeTime,
                    MM: processRelativeTime,
                    y: processRelativeTime,
                    yy: processRelativeTime
                },
                ordinalParse: /\d{1,2}\./,
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4  // The week that contains Jan 4th is the first week of the year.
                }
            });

            return de;

        })));


        /***/
    },
    /* 22 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Maldivian [dv]
//! author : Jawish Hameed : https://github.com/jawish

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var months = [
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                ''
            ];
            var weekdays = [
                '',
                '',
                '',
                '',
                '',
                '',
                ''
            ];

            var dv = moment.defineLocale('dv', {
                months: months,
                monthsShort: months,
                weekdays: weekdays,
                weekdaysShort: weekdays,
                weekdaysMin: '______'.split('_'),
                longDateFormat: {

                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'D/M/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY HH:mm',
                    LLLL: 'dddd D MMMM YYYY HH:mm'
                },
                meridiemParse: /|/,
                isPM: function (input) {
                    return '' === input;
                },
                meridiem: function (hour, minute, isLower) {
                    if (hour < 12) {
                        return '';
                    } else {
                        return '';
                    }
                },
                calendar: {
                    sameDay: '[] LT',
                    nextDay: '[] LT',
                    nextWeek: 'dddd LT',
                    lastDay: '[] LT',
                    lastWeek: '[] dddd LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: ' %s',
                    past: ' %s',
                    s: '',
                    m: '',
                    mm: ' %d',
                    h: '',
                    hh: ' %d',
                    d: '',
                    dd: ' %d',
                    M: '',
                    MM: ' %d',
                    y: '',
                    yy: ' %d'
                },
                preparse: function (string) {
                    return string.replace(//g, ',');
                },
                postformat: function (string) {
                    return string.replace(/,/g, '');
                },
                week: {
                    dow: 7,  // Sunday is the first day of the week.
                    doy: 12  // The week that contains Jan 1st is the first week of the year.
                }
            });

            return dv;

        })));


        /***/
    },
    /* 23 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Greek [el]
//! author : Aggelos Karalias : https://github.com/mehiel

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';

            function isFunction(input) {
                return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
            }


            var el = moment.defineLocale('el', {
                monthsNominativeEl: '___________'.split('_'),
                monthsGenitiveEl: '___________'.split('_'),
                months: function (momentToFormat, format) {
                    if (/D/.test(format.substring(0, format.indexOf('MMMM')))) { // if there is a day number before 'MMMM'
                        return this._monthsGenitiveEl[momentToFormat.month()];
                    } else {
                        return this._monthsNominativeEl[momentToFormat.month()];
                    }
                },
                monthsShort: '___________'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                meridiem: function (hours, minutes, isLower) {
                    if (hours > 11) {
                        return isLower ? '' : '';
                    } else {
                        return isLower ? '' : '';
                    }
                },
                isPM: function (input) {
                    return ((input + '').toLowerCase()[0] === '');
                },
                meridiemParse: /[]\.??\.?/i,
                longDateFormat: {
                    LT: 'h:mm A',
                    LTS: 'h:mm:ss A',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY h:mm A',
                    LLLL: 'dddd, D MMMM YYYY h:mm A'
                },
                calendarEl: {
                    sameDay: '[ {}] LT',
                    nextDay: '[ {}] LT',
                    nextWeek: 'dddd [{}] LT',
                    lastDay: '[ {}] LT',
                    lastWeek: function () {
                        switch (this.day()) {
                            case 6:
                                return '[ ] dddd [{}] LT';
                            default:
                                return '[ ] dddd [{}] LT';
                        }
                    },
                    sameElse: 'L'
                },
                calendar: function (key, mom) {
                    var output = this._calendarEl[key],
                        hours = mom && mom.hours();
                    if (isFunction(output)) {
                        output = output.apply(mom);
                    }
                    return output.replace('{}', (hours % 12 === 1 ? '' : ''));
                },
                relativeTime: {
                    future: ' %s',
                    past: '%s ',
                    s: ' ',
                    m: ' ',
                    mm: '%d ',
                    h: ' ',
                    hh: '%d ',
                    d: ' ',
                    dd: '%d ',
                    M: ' ',
                    MM: '%d ',
                    y: ' ',
                    yy: '%d '
                },
                ordinalParse: /\d{1,2}/,
                ordinal: '%d',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4  // The week that contains Jan 4st is the first week of the year.
                }
            });

            return el;

        })));


        /***/
    },
    /* 24 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (Australia) [en-au]
//! author : Jared Morse : https://github.com/jarcoal

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var enAu = moment.defineLocale('en-au', {
                months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
                monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
                weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
                weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
                weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
                longDateFormat: {
                    LT: 'h:mm A',
                    LTS: 'h:mm:ss A',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY h:mm A',
                    LLLL: 'dddd, D MMMM YYYY h:mm A'
                },
                calendar: {
                    sameDay: '[Today at] LT',
                    nextDay: '[Tomorrow at] LT',
                    nextWeek: 'dddd [at] LT',
                    lastDay: '[Yesterday at] LT',
                    lastWeek: '[Last] dddd [at] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'in %s',
                    past: '%s ago',
                    s: 'a few seconds',
                    m: 'a minute',
                    mm: '%d minutes',
                    h: 'an hour',
                    hh: '%d hours',
                    d: 'a day',
                    dd: '%d days',
                    M: 'a month',
                    MM: '%d months',
                    y: 'a year',
                    yy: '%d years'
                },
                ordinalParse: /\d{1,2}(st|nd|rd|th)/,
                ordinal: function (number) {
                    var b = number % 10,
                        output = (~~(number % 100 / 10) === 1) ? 'th' :
                            (b === 1) ? 'st' :
                                (b === 2) ? 'nd' :
                                    (b === 3) ? 'rd' : 'th';
                    return number + output;
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4  // The week that contains Jan 4th is the first week of the year.
                }
            });

            return enAu;

        })));


        /***/
    },
    /* 25 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (Canada) [en-ca]
//! author : Jonathan Abourbih : https://github.com/jonbca

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var enCa = moment.defineLocale('en-ca', {
                months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
                monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
                weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
                weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
                weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
                longDateFormat: {
                    LT: 'h:mm A',
                    LTS: 'h:mm:ss A',
                    L: 'YYYY-MM-DD',
                    LL: 'MMMM D, YYYY',
                    LLL: 'MMMM D, YYYY h:mm A',
                    LLLL: 'dddd, MMMM D, YYYY h:mm A'
                },
                calendar: {
                    sameDay: '[Today at] LT',
                    nextDay: '[Tomorrow at] LT',
                    nextWeek: 'dddd [at] LT',
                    lastDay: '[Yesterday at] LT',
                    lastWeek: '[Last] dddd [at] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'in %s',
                    past: '%s ago',
                    s: 'a few seconds',
                    m: 'a minute',
                    mm: '%d minutes',
                    h: 'an hour',
                    hh: '%d hours',
                    d: 'a day',
                    dd: '%d days',
                    M: 'a month',
                    MM: '%d months',
                    y: 'a year',
                    yy: '%d years'
                },
                ordinalParse: /\d{1,2}(st|nd|rd|th)/,
                ordinal: function (number) {
                    var b = number % 10,
                        output = (~~(number % 100 / 10) === 1) ? 'th' :
                            (b === 1) ? 'st' :
                                (b === 2) ? 'nd' :
                                    (b === 3) ? 'rd' : 'th';
                    return number + output;
                }
            });

            return enCa;

        })));


        /***/
    },
    /* 26 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (United Kingdom) [en-gb]
//! author : Chris Gedrim : https://github.com/chrisgedrim

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var enGb = moment.defineLocale('en-gb', {
                months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
                monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
                weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
                weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
                weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY HH:mm',
                    LLLL: 'dddd, D MMMM YYYY HH:mm'
                },
                calendar: {
                    sameDay: '[Today at] LT',
                    nextDay: '[Tomorrow at] LT',
                    nextWeek: 'dddd [at] LT',
                    lastDay: '[Yesterday at] LT',
                    lastWeek: '[Last] dddd [at] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'in %s',
                    past: '%s ago',
                    s: 'a few seconds',
                    m: 'a minute',
                    mm: '%d minutes',
                    h: 'an hour',
                    hh: '%d hours',
                    d: 'a day',
                    dd: '%d days',
                    M: 'a month',
                    MM: '%d months',
                    y: 'a year',
                    yy: '%d years'
                },
                ordinalParse: /\d{1,2}(st|nd|rd|th)/,
                ordinal: function (number) {
                    var b = number % 10,
                        output = (~~(number % 100 / 10) === 1) ? 'th' :
                            (b === 1) ? 'st' :
                                (b === 2) ? 'nd' :
                                    (b === 3) ? 'rd' : 'th';
                    return number + output;
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4  // The week that contains Jan 4th is the first week of the year.
                }
            });

            return enGb;

        })));


        /***/
    },
    /* 27 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (Ireland) [en-ie]
//! author : Chris Cartlidge : https://github.com/chriscartlidge

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var enIe = moment.defineLocale('en-ie', {
                months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
                monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
                weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
                weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
                weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD-MM-YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY HH:mm',
                    LLLL: 'dddd D MMMM YYYY HH:mm'
                },
                calendar: {
                    sameDay: '[Today at] LT',
                    nextDay: '[Tomorrow at] LT',
                    nextWeek: 'dddd [at] LT',
                    lastDay: '[Yesterday at] LT',
                    lastWeek: '[Last] dddd [at] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'in %s',
                    past: '%s ago',
                    s: 'a few seconds',
                    m: 'a minute',
                    mm: '%d minutes',
                    h: 'an hour',
                    hh: '%d hours',
                    d: 'a day',
                    dd: '%d days',
                    M: 'a month',
                    MM: '%d months',
                    y: 'a year',
                    yy: '%d years'
                },
                ordinalParse: /\d{1,2}(st|nd|rd|th)/,
                ordinal: function (number) {
                    var b = number % 10,
                        output = (~~(number % 100 / 10) === 1) ? 'th' :
                            (b === 1) ? 'st' :
                                (b === 2) ? 'nd' :
                                    (b === 3) ? 'rd' : 'th';
                    return number + output;
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4  // The week that contains Jan 4th is the first week of the year.
                }
            });

            return enIe;

        })));


        /***/
    },
    /* 28 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (New Zealand) [en-nz]
//! author : Luke McGregor : https://github.com/lukemcgregor

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var enNz = moment.defineLocale('en-nz', {
                months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
                monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
                weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
                weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
                weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
                longDateFormat: {
                    LT: 'h:mm A',
                    LTS: 'h:mm:ss A',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY h:mm A',
                    LLLL: 'dddd, D MMMM YYYY h:mm A'
                },
                calendar: {
                    sameDay: '[Today at] LT',
                    nextDay: '[Tomorrow at] LT',
                    nextWeek: 'dddd [at] LT',
                    lastDay: '[Yesterday at] LT',
                    lastWeek: '[Last] dddd [at] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'in %s',
                    past: '%s ago',
                    s: 'a few seconds',
                    m: 'a minute',
                    mm: '%d minutes',
                    h: 'an hour',
                    hh: '%d hours',
                    d: 'a day',
                    dd: '%d days',
                    M: 'a month',
                    MM: '%d months',
                    y: 'a year',
                    yy: '%d years'
                },
                ordinalParse: /\d{1,2}(st|nd|rd|th)/,
                ordinal: function (number) {
                    var b = number % 10,
                        output = (~~(number % 100 / 10) === 1) ? 'th' :
                            (b === 1) ? 'st' :
                                (b === 2) ? 'nd' :
                                    (b === 3) ? 'rd' : 'th';
                    return number + output;
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4  // The week that contains Jan 4th is the first week of the year.
                }
            });

            return enNz;

        })));


        /***/
    },
    /* 29 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Esperanto [eo]
//! author : Colin Dean : https://github.com/colindean
//! komento: Mi estas malcerta se mi korekte traktis akuzativojn en tiu traduko.
//!          Se ne, bonvolu korekti kaj avizi min por ke mi povas lerni!

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var eo = moment.defineLocale('eo', {
                months: 'januaro_februaro_marto_aprilo_majo_junio_julio_agusto_septembro_oktobro_novembro_decembro'.split('_'),
                monthsShort: 'jan_feb_mar_apr_maj_jun_jul_ag_sep_okt_nov_dec'.split('_'),
                weekdays: 'Dimano_Lundo_Mardo_Merkredo_ado_Vendredo_Sabato'.split('_'),
                weekdaysShort: 'Dim_Lun_Mard_Merk_a_Ven_Sab'.split('_'),
                weekdaysMin: 'Di_Lu_Ma_Me_a_Ve_Sa'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'YYYY-MM-DD',
                    LL: 'D[-an de] MMMM, YYYY',
                    LLL: 'D[-an de] MMMM, YYYY HH:mm',
                    LLLL: 'dddd, [la] D[-an de] MMMM, YYYY HH:mm'
                },
                meridiemParse: /[ap]\.t\.m/i,
                isPM: function (input) {
                    return input.charAt(0).toLowerCase() === 'p';
                },
                meridiem: function (hours, minutes, isLower) {
                    if (hours > 11) {
                        return isLower ? 'p.t.m.' : 'P.T.M.';
                    } else {
                        return isLower ? 'a.t.m.' : 'A.T.M.';
                    }
                },
                calendar: {
                    sameDay: '[Hodia je] LT',
                    nextDay: '[Morga je] LT',
                    nextWeek: 'dddd [je] LT',
                    lastDay: '[Hiera je] LT',
                    lastWeek: '[pasinta] dddd [je] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'je %s',
                    past: 'anta %s',
                    s: 'sekundoj',
                    m: 'minuto',
                    mm: '%d minutoj',
                    h: 'horo',
                    hh: '%d horoj',
                    d: 'tago',//ne 'diurno', ar estas uzita por proksimumo
                    dd: '%d tagoj',
                    M: 'monato',
                    MM: '%d monatoj',
                    y: 'jaro',
                    yy: '%d jaroj'
                },
                ordinalParse: /\d{1,2}a/,
                ordinal: '%da',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7  // The week that contains Jan 1st is the first week of the year.
                }
            });

            return eo;

        })));


        /***/
    },
    /* 30 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Spanish (Dominican Republic) [es-do]

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_');
            var monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

            var esDo = moment.defineLocale('es-do', {
                months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
                monthsShort: function (m, format) {
                    if (/-MMM-/.test(format)) {
                        return monthsShort[m.month()];
                    } else {
                        return monthsShortDot[m.month()];
                    }
                },
                monthsParseExact: true,
                weekdays: 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
                weekdaysShort: 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
                weekdaysMin: 'do_lu_ma_mi_ju_vi_s'.split('_'),
                weekdaysParseExact: true,
                longDateFormat: {
                    LT: 'h:mm A',
                    LTS: 'h:mm:ss A',
                    L: 'DD/MM/YYYY',
                    LL: 'D [de] MMMM [de] YYYY',
                    LLL: 'D [de] MMMM [de] YYYY h:mm A',
                    LLLL: 'dddd, D [de] MMMM [de] YYYY h:mm A'
                },
                calendar: {
                    sameDay: function () {
                        return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
                    },
                    nextDay: function () {
                        return '[maana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
                    },
                    nextWeek: function () {
                        return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
                    },
                    lastDay: function () {
                        return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
                    },
                    lastWeek: function () {
                        return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
                    },
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'en %s',
                    past: 'hace %s',
                    s: 'unos segundos',
                    m: 'un minuto',
                    mm: '%d minutos',
                    h: 'una hora',
                    hh: '%d horas',
                    d: 'un da',
                    dd: '%d das',
                    M: 'un mes',
                    MM: '%d meses',
                    y: 'un ao',
                    yy: '%d aos'
                },
                ordinalParse: /\d{1,2}/,
                ordinal: '%d',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4  // The week that contains Jan 4th is the first week of the year.
                }
            });

            return esDo;

        })));


        /***/
    },
    /* 31 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Spanish [es]
//! author : Julio Napur : https://github.com/julionc

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_');
            var monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

            var es = moment.defineLocale('es', {
                months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
                monthsShort: function (m, format) {
                    if (/-MMM-/.test(format)) {
                        return monthsShort[m.month()];
                    } else {
                        return monthsShortDot[m.month()];
                    }
                },
                monthsParseExact: true,
                weekdays: 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
                weekdaysShort: 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
                weekdaysMin: 'do_lu_ma_mi_ju_vi_s'.split('_'),
                weekdaysParseExact: true,
                longDateFormat: {
                    LT: 'H:mm',
                    LTS: 'H:mm:ss',
                    L: 'DD/MM/YYYY',
                    LL: 'D [de] MMMM [de] YYYY',
                    LLL: 'D [de] MMMM [de] YYYY H:mm',
                    LLLL: 'dddd, D [de] MMMM [de] YYYY H:mm'
                },
                calendar: {
                    sameDay: function () {
                        return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
                    },
                    nextDay: function () {
                        return '[maana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
                    },
                    nextWeek: function () {
                        return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
                    },
                    lastDay: function () {
                        return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
                    },
                    lastWeek: function () {
                        return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
                    },
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'en %s',
                    past: 'hace %s',
                    s: 'unos segundos',
                    m: 'un minuto',
                    mm: '%d minutos',
                    h: 'una hora',
                    hh: '%d horas',
                    d: 'un da',
                    dd: '%d das',
                    M: 'un mes',
                    MM: '%d meses',
                    y: 'un ao',
                    yy: '%d aos'
                },
                ordinalParse: /\d{1,2}/,
                ordinal: '%d',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4  // The week that contains Jan 4th is the first week of the year.
                }
            });

            return es;

        })));


        /***/
    },
    /* 32 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Estonian [et]
//! author : Henry Kehlmann : https://github.com/madhenry
//! improvements : Illimar Tambek : https://github.com/ragulka

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            function processRelativeTime(number, withoutSuffix, key, isFuture) {
                var format = {
                    's': ['mne sekundi', 'mni sekund', 'paar sekundit'],
                    'm': ['he minuti', 'ks minut'],
                    'mm': [number + ' minuti', number + ' minutit'],
                    'h': ['he tunni', 'tund aega', 'ks tund'],
                    'hh': [number + ' tunni', number + ' tundi'],
                    'd': ['he peva', 'ks pev'],
                    'M': ['kuu aja', 'kuu aega', 'ks kuu'],
                    'MM': [number + ' kuu', number + ' kuud'],
                    'y': ['he aasta', 'aasta', 'ks aasta'],
                    'yy': [number + ' aasta', number + ' aastat']
                };
                if (withoutSuffix) {
                    return format[key][2] ? format[key][2] : format[key][1];
                }
                return isFuture ? format[key][0] : format[key][1];
            }

            var et = moment.defineLocale('et', {
                months: 'jaanuar_veebruar_mrts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split('_'),
                monthsShort: 'jaan_veebr_mrts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split('_'),
                weekdays: 'phapev_esmaspev_teisipev_kolmapev_neljapev_reede_laupev'.split('_'),
                weekdaysShort: 'P_E_T_K_N_R_L'.split('_'),
                weekdaysMin: 'P_E_T_K_N_R_L'.split('_'),
                longDateFormat: {
                    LT: 'H:mm',
                    LTS: 'H:mm:ss',
                    L: 'DD.MM.YYYY',
                    LL: 'D. MMMM YYYY',
                    LLL: 'D. MMMM YYYY H:mm',
                    LLLL: 'dddd, D. MMMM YYYY H:mm'
                },
                calendar: {
                    sameDay: '[Tna,] LT',
                    nextDay: '[Homme,] LT',
                    nextWeek: '[Jrgmine] dddd LT',
                    lastDay: '[Eile,] LT',
                    lastWeek: '[Eelmine] dddd LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: '%s prast',
                    past: '%s tagasi',
                    s: processRelativeTime,
                    m: processRelativeTime,
                    mm: processRelativeTime,
                    h: processRelativeTime,
                    hh: processRelativeTime,
                    d: processRelativeTime,
                    dd: '%d peva',
                    M: processRelativeTime,
                    MM: processRelativeTime,
                    y: processRelativeTime,
                    yy: processRelativeTime
                },
                ordinalParse: /\d{1,2}\./,
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4  // The week that contains Jan 4th is the first week of the year.
                }
            });

            return et;

        })));


        /***/
    },
    /* 33 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Basque [eu]
//! author : Eneko Illarramendi : https://github.com/eillarra

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var eu = moment.defineLocale('eu', {
                months: 'urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua'.split('_'),
                monthsShort: 'urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.'.split('_'),
                monthsParseExact: true,
                weekdays: 'igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata'.split('_'),
                weekdaysShort: 'ig._al._ar._az._og._ol._lr.'.split('_'),
                weekdaysMin: 'ig_al_ar_az_og_ol_lr'.split('_'),
                weekdaysParseExact: true,
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'YYYY-MM-DD',
                    LL: 'YYYY[ko] MMMM[ren] D[a]',
                    LLL: 'YYYY[ko] MMMM[ren] D[a] HH:mm',
                    LLLL: 'dddd, YYYY[ko] MMMM[ren] D[a] HH:mm',
                    l: 'YYYY-M-D',
                    ll: 'YYYY[ko] MMM D[a]',
                    lll: 'YYYY[ko] MMM D[a] HH:mm',
                    llll: 'ddd, YYYY[ko] MMM D[a] HH:mm'
                },
                calendar: {
                    sameDay: '[gaur] LT[etan]',
                    nextDay: '[bihar] LT[etan]',
                    nextWeek: 'dddd LT[etan]',
                    lastDay: '[atzo] LT[etan]',
                    lastWeek: '[aurreko] dddd LT[etan]',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: '%s barru',
                    past: 'duela %s',
                    s: 'segundo batzuk',
                    m: 'minutu bat',
                    mm: '%d minutu',
                    h: 'ordu bat',
                    hh: '%d ordu',
                    d: 'egun bat',
                    dd: '%d egun',
                    M: 'hilabete bat',
                    MM: '%d hilabete',
                    y: 'urte bat',
                    yy: '%d urte'
                },
                ordinalParse: /\d{1,2}\./,
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7  // The week that contains Jan 1st is the first week of the year.
                }
            });

            return eu;

        })));


        /***/
    },
    /* 34 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Persian [fa]
//! author : Ebrahim Byagowi : https://github.com/ebraminio

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var symbolMap = {
                '1': '',
                '2': '',
                '3': '',
                '4': '',
                '5': '',
                '6': '',
                '7': '',
                '8': '',
                '9': '',
                '0': ''
            };
            var numberMap = {
                '': '1',
                '': '2',
                '': '3',
                '': '4',
                '': '5',
                '': '6',
                '': '7',
                '': '8',
                '': '9',
                '': '0'
            };

            var fa = moment.defineLocale('fa', {
                months: '___________'.split('_'),
                monthsShort: '___________'.split('_'),
                weekdays: '\u200c__\u200c__\u200c__'.split('_'),
                weekdaysShort: '\u200c__\u200c__\u200c__'.split('_'),
                weekdaysMin: '______'.split('_'),
                weekdaysParseExact: true,
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY HH:mm',
                    LLLL: 'dddd, D MMMM YYYY HH:mm'
                },
                meridiemParse: /  |  /,
                isPM: function (input) {
                    return /  /.test(input);
                },
                meridiem: function (hour, minute, isLower) {
                    if (hour < 12) {
                        return '  ';
                    } else {
                        return '  ';
                    }
                },
                calendar: {
                    sameDay: '[ ] LT',
                    nextDay: '[ ] LT',
                    nextWeek: 'dddd [] LT',
                    lastDay: '[ ] LT',
                    lastWeek: 'dddd [] [] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: ' %s',
                    past: '%s ',
                    s: ' ',
                    m: ' ',
                    mm: '%d ',
                    h: ' ',
                    hh: '%d ',
                    d: ' ',
                    dd: '%d ',
                    M: ' ',
                    MM: '%d ',
                    y: ' ',
                    yy: '%d '
                },
                preparse: function (string) {
                    return string.replace(/[-]/g, function (match) {
                        return numberMap[match];
                    }).replace(//g, ',');
                },
                postformat: function (string) {
                    return string.replace(/\d/g, function (match) {
                        return symbolMap[match];
                    }).replace(/,/g, '');
                },
                ordinalParse: /\d{1,2}/,
                ordinal: '%d',
                week: {
                    dow: 6, // Saturday is the first day of the week.
                    doy: 12 // The week that contains Jan 1st is the first week of the year.
                }
            });

            return fa;

        })));


        /***/
    },
    /* 35 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Finnish [fi]
//! author : Tarmo Aidantausta : https://github.com/bleadof

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var numbersPast = 'nolla yksi kaksi kolme nelj viisi kuusi seitsemn kahdeksan yhdeksn'.split(' ');
            var numbersFuture = [
                'nolla', 'yhden', 'kahden', 'kolmen', 'neljn', 'viiden', 'kuuden',
                numbersPast[7], numbersPast[8], numbersPast[9]
            ];

            function translate(number, withoutSuffix, key, isFuture) {
                var result = '';
                switch (key) {
                    case 's':
                        return isFuture ? 'muutaman sekunnin' : 'muutama sekunti';
                    case 'm':
                        return isFuture ? 'minuutin' : 'minuutti';
                    case 'mm':
                        result = isFuture ? 'minuutin' : 'minuuttia';
                        break;
                    case 'h':
                        return isFuture ? 'tunnin' : 'tunti';
                    case 'hh':
                        result = isFuture ? 'tunnin' : 'tuntia';
                        break;
                    case 'd':
                        return isFuture ? 'pivn' : 'piv';
                    case 'dd':
                        result = isFuture ? 'pivn' : 'piv';
                        break;
                    case 'M':
                        return isFuture ? 'kuukauden' : 'kuukausi';
                    case 'MM':
                        result = isFuture ? 'kuukauden' : 'kuukautta';
                        break;
                    case 'y':
                        return isFuture ? 'vuoden' : 'vuosi';
                    case 'yy':
                        result = isFuture ? 'vuoden' : 'vuotta';
                        break;
                }
                result = verbalNumber(number, isFuture) + ' ' + result;
                return result;
            }

            function verbalNumber(number, isFuture) {
                return number < 10 ? (isFuture ? numbersFuture[number] : numbersPast[number]) : number;
            }

            var fi = moment.defineLocale('fi', {
                months: 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_keskuu_heinkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split('_'),
                monthsShort: 'tammi_helmi_maalis_huhti_touko_kes_hein_elo_syys_loka_marras_joulu'.split('_'),
                weekdays: 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split('_'),
                weekdaysShort: 'su_ma_ti_ke_to_pe_la'.split('_'),
                weekdaysMin: 'su_ma_ti_ke_to_pe_la'.split('_'),
                longDateFormat: {
                    LT: 'HH.mm',
                    LTS: 'HH.mm.ss',
                    L: 'DD.MM.YYYY',
                    LL: 'Do MMMM[ta] YYYY',
                    LLL: 'Do MMMM[ta] YYYY, [klo] HH.mm',
                    LLLL: 'dddd, Do MMMM[ta] YYYY, [klo] HH.mm',
                    l: 'D.M.YYYY',
                    ll: 'Do MMM YYYY',
                    lll: 'Do MMM YYYY, [klo] HH.mm',
                    llll: 'ddd, Do MMM YYYY, [klo] HH.mm'
                },
                calendar: {
                    sameDay: '[tnn] [klo] LT',
                    nextDay: '[huomenna] [klo] LT',
                    nextWeek: 'dddd [klo] LT',
                    lastDay: '[eilen] [klo] LT',
                    lastWeek: '[viime] dddd[na] [klo] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: '%s pst',
                    past: '%s sitten',
                    s: translate,
                    m: translate,
                    mm: translate,
                    h: translate,
                    hh: translate,
                    d: translate,
                    dd: translate,
                    M: translate,
                    MM: translate,
                    y: translate,
                    yy: translate
                },
                ordinalParse: /\d{1,2}\./,
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4  // The week that contains Jan 4th is the first week of the year.
                }
            });

            return fi;

        })));


        /***/
    },
    /* 36 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Faroese [fo]
//! author : Ragnar Johannesen : https://github.com/ragnar123

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var fo = moment.defineLocale('fo', {
                months: 'januar_februar_mars_aprl_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
                monthsShort: 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
                weekdays: 'sunnudagur_mnadagur_tsdagur_mikudagur_hsdagur_frggjadagur_leygardagur'.split('_'),
                weekdaysShort: 'sun_mn_ts_mik_hs_fr_ley'.split('_'),
                weekdaysMin: 'su_m_t_mi_h_fr_le'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY HH:mm',
                    LLLL: 'dddd D. MMMM, YYYY HH:mm'
                },
                calendar: {
                    sameDay: '[ dag kl.] LT',
                    nextDay: '[ morgin kl.] LT',
                    nextWeek: 'dddd [kl.] LT',
                    lastDay: '[ gjr kl.] LT',
                    lastWeek: '[sstu] dddd [kl] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'um %s',
                    past: '%s sani',
                    s: 'f sekund',
                    m: 'ein minutt',
                    mm: '%d minuttir',
                    h: 'ein tmi',
                    hh: '%d tmar',
                    d: 'ein dagur',
                    dd: '%d dagar',
                    M: 'ein mnai',
                    MM: '%d mnair',
                    y: 'eitt r',
                    yy: '%d r'
                },
                ordinalParse: /\d{1,2}\./,
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4  // The week that contains Jan 4th is the first week of the year.
                }
            });

            return fo;

        })));


        /***/
    },
    /* 37 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : French (Canada) [fr-ca]
//! author : Jonathan Abourbih : https://github.com/jonbca

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var frCa = moment.defineLocale('fr-ca', {
                months: 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
                monthsShort: 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
                monthsParseExact: true,
                weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
                weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
                weekdaysMin: 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
                weekdaysParseExact: true,
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'YYYY-MM-DD',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY HH:mm',
                    LLLL: 'dddd D MMMM YYYY HH:mm'
                },
                calendar: {
                    sameDay: '[Aujourd\'hui ] LT',
                    nextDay: '[Demain ] LT',
                    nextWeek: 'dddd [] LT',
                    lastDay: '[Hier ] LT',
                    lastWeek: 'dddd [dernier ] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'dans %s',
                    past: 'il y a %s',
                    s: 'quelques secondes',
                    m: 'une minute',
                    mm: '%d minutes',
                    h: 'une heure',
                    hh: '%d heures',
                    d: 'un jour',
                    dd: '%d jours',
                    M: 'un mois',
                    MM: '%d mois',
                    y: 'un an',
                    yy: '%d ans'
                },
                ordinalParse: /\d{1,2}(er|e)/,
                ordinal: function (number) {
                    return number + (number === 1 ? 'er' : 'e');
                }
            });

            return frCa;

        })));


        /***/
    },
    /* 38 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : French (Switzerland) [fr-ch]
//! author : Gaspard Bucher : https://github.com/gaspard

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var frCh = moment.defineLocale('fr-ch', {
                months: 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
                monthsShort: 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
                monthsParseExact: true,
                weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
                weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
                weekdaysMin: 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
                weekdaysParseExact: true,
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD.MM.YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY HH:mm',
                    LLLL: 'dddd D MMMM YYYY HH:mm'
                },
                calendar: {
                    sameDay: '[Aujourd\'hui ] LT',
                    nextDay: '[Demain ] LT',
                    nextWeek: 'dddd [] LT',
                    lastDay: '[Hier ] LT',
                    lastWeek: 'dddd [dernier ] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'dans %s',
                    past: 'il y a %s',
                    s: 'quelques secondes',
                    m: 'une minute',
                    mm: '%d minutes',
                    h: 'une heure',
                    hh: '%d heures',
                    d: 'un jour',
                    dd: '%d jours',
                    M: 'un mois',
                    MM: '%d mois',
                    y: 'un an',
                    yy: '%d ans'
                },
                ordinalParse: /\d{1,2}(er|e)/,
                ordinal: function (number) {
                    return number + (number === 1 ? 'er' : 'e');
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4  // The week that contains Jan 4th is the first week of the year.
                }
            });

            return frCh;

        })));


        /***/
    },
    /* 39 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : French [fr]
//! author : John Fischer : https://github.com/jfroffice

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var fr = moment.defineLocale('fr', {
                months: 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
                monthsShort: 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
                monthsParseExact: true,
                weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
                weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
                weekdaysMin: 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
                weekdaysParseExact: true,
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY HH:mm',
                    LLLL: 'dddd D MMMM YYYY HH:mm'
                },
                calendar: {
                    sameDay: '[Aujourd\'hui ] LT',
                    nextDay: '[Demain ] LT',
                    nextWeek: 'dddd [] LT',
                    lastDay: '[Hier ] LT',
                    lastWeek: 'dddd [dernier ] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'dans %s',
                    past: 'il y a %s',
                    s: 'quelques secondes',
                    m: 'une minute',
                    mm: '%d minutes',
                    h: 'une heure',
                    hh: '%d heures',
                    d: 'un jour',
                    dd: '%d jours',
                    M: 'un mois',
                    MM: '%d mois',
                    y: 'un an',
                    yy: '%d ans'
                },
                ordinalParse: /\d{1,2}(er|)/,
                ordinal: function (number) {
                    return number + (number === 1 ? 'er' : '');
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4  // The week that contains Jan 4th is the first week of the year.
                }
            });

            return fr;

        })));


        /***/
    },
    /* 40 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Frisian [fy]
//! author : Robin van der Vliet : https://github.com/robin0van0der0v

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var monthsShortWithDots = 'jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.'.split('_');
            var monthsShortWithoutDots = 'jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_');

            var fy = moment.defineLocale('fy', {
                months: 'jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber'.split('_'),
                monthsShort: function (m, format) {
                    if (/-MMM-/.test(format)) {
                        return monthsShortWithoutDots[m.month()];
                    } else {
                        return monthsShortWithDots[m.month()];
                    }
                },
                monthsParseExact: true,
                weekdays: 'snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon'.split('_'),
                weekdaysShort: 'si._mo._ti._wo._to._fr._so.'.split('_'),
                weekdaysMin: 'Si_Mo_Ti_Wo_To_Fr_So'.split('_'),
                weekdaysParseExact: true,
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD-MM-YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY HH:mm',
                    LLLL: 'dddd D MMMM YYYY HH:mm'
                },
                calendar: {
                    sameDay: '[hjoed om] LT',
                    nextDay: '[moarn om] LT',
                    nextWeek: 'dddd [om] LT',
                    lastDay: '[juster om] LT',
                    lastWeek: '[frne] dddd [om] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'oer %s',
                    past: '%s lyn',
                    s: 'in pear sekonden',
                    m: 'ien mint',
                    mm: '%d minuten',
                    h: 'ien oere',
                    hh: '%d oeren',
                    d: 'ien dei',
                    dd: '%d dagen',
                    M: 'ien moanne',
                    MM: '%d moannen',
                    y: 'ien jier',
                    yy: '%d jierren'
                },
                ordinalParse: /\d{1,2}(ste|de)/,
                ordinal: function (number) {
                    return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4  // The week that contains Jan 4th is the first week of the year.
                }
            });

            return fy;

        })));


        /***/
    },
    /* 41 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Scottish Gaelic [gd]
//! author : Jon Ashdown : https://github.com/jonashdown

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var months = [
                'Am Faoilleach', 'An Gearran', 'Am Mrt', 'An Giblean', 'An Citean', 'An t-gmhios', 'An t-Iuchar', 'An Lnastal', 'An t-Sultain', 'An Dmhair', 'An t-Samhain', 'An Dbhlachd'
            ];

            var monthsShort = ['Faoi', 'Gear', 'Mrt', 'Gibl', 'Cit', 'gmh', 'Iuch', 'Ln', 'Sult', 'Dmh', 'Samh', 'Dbh'];

            var weekdays = ['Didmhnaich', 'Diluain', 'Dimirt', 'Diciadain', 'Diardaoin', 'Dihaoine', 'Disathairne'];

            var weekdaysShort = ['Did', 'Dil', 'Dim', 'Dic', 'Dia', 'Dih', 'Dis'];

            var weekdaysMin = ['D', 'Lu', 'M', 'Ci', 'Ar', 'Ha', 'Sa'];

            var gd = moment.defineLocale('gd', {
                months: months,
                monthsShort: monthsShort,
                monthsParseExact: true,
                weekdays: weekdays,
                weekdaysShort: weekdaysShort,
                weekdaysMin: weekdaysMin,
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY HH:mm',
                    LLLL: 'dddd, D MMMM YYYY HH:mm'
                },
                calendar: {
                    sameDay: '[An-diugh aig] LT',
                    nextDay: '[A-mireach aig] LT',
                    nextWeek: 'dddd [aig] LT',
                    lastDay: '[An-d aig] LT',
                    lastWeek: 'dddd [seo chaidh] [aig] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'ann an %s',
                    past: 'bho chionn %s',
                    s: 'beagan diogan',
                    m: 'mionaid',
                    mm: '%d mionaidean',
                    h: 'uair',
                    hh: '%d uairean',
                    d: 'latha',
                    dd: '%d latha',
                    M: 'mos',
                    MM: '%d mosan',
                    y: 'bliadhna',
                    yy: '%d bliadhna'
                },
                ordinalParse: /\d{1,2}(d|na|mh)/,
                ordinal: function (number) {
                    var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
                    return number + output;
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4  // The week that contains Jan 4th is the first week of the year.
                }
            });

            return gd;

        })));


        /***/
    },
    /* 42 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Galician [gl]
//! author : Juan G. Hurtado : https://github.com/juanghurtado

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var gl = moment.defineLocale('gl', {
                months: 'xaneiro_febreiro_marzo_abril_maio_xuo_xullo_agosto_setembro_outubro_novembro_decembro'.split('_'),
                monthsShort: 'xan._feb._mar._abr._mai._xu._xul._ago._set._out._nov._dec.'.split('_'),
                monthsParseExact: true,
                weekdays: 'domingo_luns_martes_mrcores_xoves_venres_sbado'.split('_'),
                weekdaysShort: 'dom._lun._mar._mr._xov._ven._sb.'.split('_'),
                weekdaysMin: 'do_lu_ma_m_xo_ve_s'.split('_'),
                weekdaysParseExact: true,
                longDateFormat: {
                    LT: 'H:mm',
                    LTS: 'H:mm:ss',
                    L: 'DD/MM/YYYY',
                    LL: 'D [de] MMMM [de] YYYY',
                    LLL: 'D [de] MMMM [de] YYYY H:mm',
                    LLLL: 'dddd, D [de] MMMM [de] YYYY H:mm'
                },
                calendar: {
                    sameDay: function () {
                        return '[hoxe ' + ((this.hours() !== 1) ? 's' : '') + '] LT';
                    },
                    nextDay: function () {
                        return '[ma ' + ((this.hours() !== 1) ? 's' : '') + '] LT';
                    },
                    nextWeek: function () {
                        return 'dddd [' + ((this.hours() !== 1) ? 's' : 'a') + '] LT';
                    },
                    lastDay: function () {
                        return '[onte ' + ((this.hours() !== 1) ? '' : 'a') + '] LT';
                    },
                    lastWeek: function () {
                        return '[o] dddd [pasado ' + ((this.hours() !== 1) ? 's' : 'a') + '] LT';
                    },
                    sameElse: 'L'
                },
                relativeTime: {
                    future: function (str) {
                        if (str.indexOf('un') === 0) {
                            return 'n' + str;
                        }
                        return 'en ' + str;
                    },
                    past: 'hai %s',
                    s: 'uns segundos',
                    m: 'un minuto',
                    mm: '%d minutos',
                    h: 'unha hora',
                    hh: '%d horas',
                    d: 'un da',
                    dd: '%d das',
                    M: 'un mes',
                    MM: '%d meses',
                    y: 'un ano',
                    yy: '%d anos'
                },
                ordinalParse: /\d{1,2}/,
                ordinal: '%d',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4  // The week that contains Jan 4th is the first week of the year.
                }
            });

            return gl;

        })));


        /***/
    },
    /* 43 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Hebrew [he]
//! author : Tomer Cohen : https://github.com/tomer
//! author : Moshe Simantov : https://github.com/DevelopmentIL
//! author : Tal Ater : https://github.com/TalAter

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var he = moment.defineLocale('he', {
                months: '___________'.split('_'),
                monthsShort: '___________'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD/MM/YYYY',
                    LL: 'D []MMMM YYYY',
                    LLL: 'D []MMMM YYYY HH:mm',
                    LLLL: 'dddd, D []MMMM YYYY HH:mm',
                    l: 'D/M/YYYY',
                    ll: 'D MMM YYYY',
                    lll: 'D MMM YYYY HH:mm',
                    llll: 'ddd, D MMM YYYY HH:mm'
                },
                calendar: {
                    sameDay: '[ ]LT',
                    nextDay: '[ ]LT',
                    nextWeek: 'dddd [] LT',
                    lastDay: '[ ]LT',
                    lastWeek: '[] dddd [ ] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: ' %s',
                    past: ' %s',
                    s: ' ',
                    m: '',
                    mm: '%d ',
                    h: '',
                    hh: function (number) {
                        if (number === 2) {
                            return '';
                        }
                        return number + ' ';
                    },
                    d: '',
                    dd: function (number) {
                        if (number === 2) {
                            return '';
                        }
                        return number + ' ';
                    },
                    M: '',
                    MM: function (number) {
                        if (number === 2) {
                            return '';
                        }
                        return number + ' ';
                    },
                    y: '',
                    yy: function (number) {
                        if (number === 2) {
                            return '';
                        } else if (number % 10 === 0 && number !== 10) {
                            return number + ' ';
                        }
                        return number + ' ';
                    }
                },
                meridiemParse: /"|"| | | ||/i,
                isPM: function (input) {
                    return /^("| |)$/.test(input);
                },
                meridiem: function (hour, minute, isLower) {
                    if (hour < 5) {
                        return ' ';
                    } else if (hour < 10) {
                        return '';
                    } else if (hour < 12) {
                        return isLower ? '"' : ' ';
                    } else if (hour < 18) {
                        return isLower ? '"' : ' ';
                    } else {
                        return '';
                    }
                }
            });

            return he;

        })));


        /***/
    },
    /* 44 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Hindi [hi]
//! author : Mayank Singhal : https://github.com/mayanksinghal

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var symbolMap = {
                '1': '',
                '2': '',
                '3': '',
                '4': '',
                '5': '',
                '6': '',
                '7': '',
                '8': '',
                '9': '',
                '0': ''
            };
            var numberMap = {
                '': '1',
                '': '2',
                '': '3',
                '': '4',
                '': '5',
                '': '6',
                '': '7',
                '': '8',
                '': '9',
                '': '0'
            };

            var hi = moment.defineLocale('hi', {
                months: '___________'.split('_'),
                monthsShort: '._.__.___._._._._._.'.split('_'),
                monthsParseExact: true,
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'A h:mm ',
                    LTS: 'A h:mm:ss ',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY, A h:mm ',
                    LLLL: 'dddd, D MMMM YYYY, A h:mm '
                },
                calendar: {
                    sameDay: '[] LT',
                    nextDay: '[] LT',
                    nextWeek: 'dddd, LT',
                    lastDay: '[] LT',
                    lastWeek: '[] dddd, LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: '%s ',
                    past: '%s ',
                    s: '  ',
                    m: ' ',
                    mm: '%d ',
                    h: ' ',
                    hh: '%d ',
                    d: ' ',
                    dd: '%d ',
                    M: ' ',
                    MM: '%d ',
                    y: ' ',
                    yy: '%d '
                },
                preparse: function (string) {
                    return string.replace(/[]/g, function (match) {
                        return numberMap[match];
                    });
                },
                postformat: function (string) {
                    return string.replace(/\d/g, function (match) {
                        return symbolMap[match];
                    });
                },
                // Hindi notation for meridiems are quite fuzzy in practice. While there exists
                // a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.
                meridiemParse: /|||/,
                meridiemHour: function (hour, meridiem) {
                    if (hour === 12) {
                        hour = 0;
                    }
                    if (meridiem === '') {
                        return hour < 4 ? hour : hour + 12;
                    } else if (meridiem === '') {
                        return hour;
                    } else if (meridiem === '') {
                        return hour >= 10 ? hour : hour + 12;
                    } else if (meridiem === '') {
                        return hour + 12;
                    }
                },
                meridiem: function (hour, minute, isLower) {
                    if (hour < 4) {
                        return '';
                    } else if (hour < 10) {
                        return '';
                    } else if (hour < 17) {
                        return '';
                    } else if (hour < 20) {
                        return '';
                    } else {
                        return '';
                    }
                },
                week: {
                    dow: 0, // Sunday is the first day of the week.
                    doy: 6  // The week that contains Jan 1st is the first week of the year.
                }
            });

            return hi;

        })));


        /***/
    },
    /* 45 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Croatian [hr]
//! author : Bojan Markovi : https://github.com/bmarkovic

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            function translate(number, withoutSuffix, key) {
                var result = number + ' ';
                switch (key) {
                    case 'm':
                        return withoutSuffix ? 'jedna minuta' : 'jedne minute';
                    case 'mm':
                        if (number === 1) {
                            result += 'minuta';
                        } else if (number === 2 || number === 3 || number === 4) {
                            result += 'minute';
                        } else {
                            result += 'minuta';
                        }
                        return result;
                    case 'h':
                        return withoutSuffix ? 'jedan sat' : 'jednog sata';
                    case 'hh':
                        if (number === 1) {
                            result += 'sat';
                        } else if (number === 2 || number === 3 || number === 4) {
                            result += 'sata';
                        } else {
                            result += 'sati';
                        }
                        return result;
                    case 'dd':
                        if (number === 1) {
                            result += 'dan';
                        } else {
                            result += 'dana';
                        }
                        return result;
                    case 'MM':
                        if (number === 1) {
                            result += 'mjesec';
                        } else if (number === 2 || number === 3 || number === 4) {
                            result += 'mjeseca';
                        } else {
                            result += 'mjeseci';
                        }
                        return result;
                    case 'yy':
                        if (number === 1) {
                            result += 'godina';
                        } else if (number === 2 || number === 3 || number === 4) {
                            result += 'godine';
                        } else {
                            result += 'godina';
                        }
                        return result;
                }
            }

            var hr = moment.defineLocale('hr', {
                months: {
                    format: 'sijenja_veljae_oujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca'.split('_'),
                    standalone: 'sijeanj_veljaa_oujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split('_')
                },
                monthsShort: 'sij._velj._ou._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split('_'),
                monthsParseExact: true,
                weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
                weekdaysShort: 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
                weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
                weekdaysParseExact: true,
                longDateFormat: {
                    LT: 'H:mm',
                    LTS: 'H:mm:ss',
                    L: 'DD.MM.YYYY',
                    LL: 'D. MMMM YYYY',
                    LLL: 'D. MMMM YYYY H:mm',
                    LLLL: 'dddd, D. MMMM YYYY H:mm'
                },
                calendar: {
                    sameDay: '[danas u] LT',
                    nextDay: '[sutra u] LT',
                    nextWeek: function () {
                        switch (this.day()) {
                            case 0:
                                return '[u] [nedjelju] [u] LT';
                            case 3:
                                return '[u] [srijedu] [u] LT';
                            case 6:
                                return '[u] [subotu] [u] LT';
                            case 1:
                            case 2:
                            case 4:
                            case 5:
                                return '[u] dddd [u] LT';
                        }
                    },
                    lastDay: '[juer u] LT',
                    lastWeek: function () {
                        switch (this.day()) {
                            case 0:
                            case 3:
                                return '[prolu] dddd [u] LT';
                            case 6:
                                return '[prole] [subote] [u] LT';
                            case 1:
                            case 2:
                            case 4:
                            case 5:
                                return '[proli] dddd [u] LT';
                        }
                    },
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'za %s',
                    past: 'prije %s',
                    s: 'par sekundi',
                    m: translate,
                    mm: translate,
                    h: translate,
                    hh: translate,
                    d: 'dan',
                    dd: translate,
                    M: 'mjesec',
                    MM: translate,
                    y: 'godinu',
                    yy: translate
                },
                ordinalParse: /\d{1,2}\./,
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7  // The week that contains Jan 1st is the first week of the year.
                }
            });

            return hr;

        })));


        /***/
    },
    /* 46 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Hungarian [hu]
//! author : Adam Brunner : https://github.com/adambrunner

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var weekEndings = 'vasrnap htfn kedden szerdn cstrtkn pnteken szombaton'.split(' ');

            function translate(number, withoutSuffix, key, isFuture) {
                var num = number,
                    suffix;
                switch (key) {
                    case 's':
                        return (isFuture || withoutSuffix) ? 'nhny msodperc' : 'nhny msodperce';
                    case 'm':
                        return 'egy' + (isFuture || withoutSuffix ? ' perc' : ' perce');
                    case 'mm':
                        return num + (isFuture || withoutSuffix ? ' perc' : ' perce');
                    case 'h':
                        return 'egy' + (isFuture || withoutSuffix ? ' ra' : ' rja');
                    case 'hh':
                        return num + (isFuture || withoutSuffix ? ' ra' : ' rja');
                    case 'd':
                        return 'egy' + (isFuture || withoutSuffix ? ' nap' : ' napja');
                    case 'dd':
                        return num + (isFuture || withoutSuffix ? ' nap' : ' napja');
                    case 'M':
                        return 'egy' + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');
                    case 'MM':
                        return num + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');
                    case 'y':
                        return 'egy' + (isFuture || withoutSuffix ? ' v' : ' ve');
                    case 'yy':
                        return num + (isFuture || withoutSuffix ? ' v' : ' ve');
                }
                return '';
            }

            function week(isFuture) {
                return (isFuture ? '' : '[mlt] ') + '[' + weekEndings[this.day()] + '] LT[-kor]';
            }

            var hu = moment.defineLocale('hu', {
                months: 'janur_februr_mrcius_prilis_mjus_jnius_jlius_augusztus_szeptember_oktber_november_december'.split('_'),
                monthsShort: 'jan_feb_mrc_pr_mj_jn_jl_aug_szept_okt_nov_dec'.split('_'),
                weekdays: 'vasrnap_htf_kedd_szerda_cstrtk_pntek_szombat'.split('_'),
                weekdaysShort: 'vas_ht_kedd_sze_cst_pn_szo'.split('_'),
                weekdaysMin: 'v_h_k_sze_cs_p_szo'.split('_'),
                longDateFormat: {
                    LT: 'H:mm',
                    LTS: 'H:mm:ss',
                    L: 'YYYY.MM.DD.',
                    LL: 'YYYY. MMMM D.',
                    LLL: 'YYYY. MMMM D. H:mm',
                    LLLL: 'YYYY. MMMM D., dddd H:mm'
                },
                meridiemParse: /de|du/i,
                isPM: function (input) {
                    return input.charAt(1).toLowerCase() === 'u';
                },
                meridiem: function (hours, minutes, isLower) {
                    if (hours < 12) {
                        return isLower === true ? 'de' : 'DE';
                    } else {
                        return isLower === true ? 'du' : 'DU';
                    }
                },
                calendar: {
                    sameDay: '[ma] LT[-kor]',
                    nextDay: '[holnap] LT[-kor]',
                    nextWeek: function () {
                        return week.call(this, true);
                    },
                    lastDay: '[tegnap] LT[-kor]',
                    lastWeek: function () {
                        return week.call(this, false);
                    },
                    sameElse: 'L'
                },
                relativeTime: {
                    future: '%s mlva',
                    past: '%s',
                    s: translate,
                    m: translate,
                    mm: translate,
                    h: translate,
                    hh: translate,
                    d: translate,
                    dd: translate,
                    M: translate,
                    MM: translate,
                    y: translate,
                    yy: translate
                },
                ordinalParse: /\d{1,2}\./,
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4  // The week that contains Jan 4th is the first week of the year.
                }
            });

            return hu;

        })));


        /***/
    },
    /* 47 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Armenian [hy-am]
//! author : Armendarabyan : https://github.com/armendarabyan

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var hyAm = moment.defineLocale('hy-am', {
                months: {
                    format: '___________'.split('_'),
                    standalone: '___________'.split('_')
                },
                monthsShort: '___________'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD.MM.YYYY',
                    LL: 'D MMMM YYYY .',
                    LLL: 'D MMMM YYYY ., HH:mm',
                    LLLL: 'dddd, D MMMM YYYY ., HH:mm'
                },
                calendar: {
                    sameDay: '[] LT',
                    nextDay: '[] LT',
                    lastDay: '[] LT',
                    nextWeek: function () {
                        return 'dddd [ ] LT';
                    },
                    lastWeek: function () {
                        return '[] dddd [ ] LT';
                    },
                    sameElse: 'L'
                },
                relativeTime: {
                    future: '%s ',
                    past: '%s ',
                    s: '  ',
                    m: '',
                    mm: '%d ',
                    h: '',
                    hh: '%d ',
                    d: '',
                    dd: '%d ',
                    M: '',
                    MM: '%d ',
                    y: '',
                    yy: '%d '
                },
                meridiemParse: /|||/,
                isPM: function (input) {
                    return /^(|)$/.test(input);
                },
                meridiem: function (hour) {
                    if (hour < 4) {
                        return '';
                    } else if (hour < 12) {
                        return '';
                    } else if (hour < 17) {
                        return '';
                    } else {
                        return '';
                    }
                },
                ordinalParse: /\d{1,2}|\d{1,2}-(|)/,
                ordinal: function (number, period) {
                    switch (period) {
                        case 'DDD':
                        case 'w':
                        case 'W':
                        case 'DDDo':
                            if (number === 1) {
                                return number + '-';
                            }
                            return number + '-';
                        default:
                            return number;
                    }
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7  // The week that contains Jan 1st is the first week of the year.
                }
            });

            return hyAm;

        })));


        /***/
    },
    /* 48 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Indonesian [id]
//! author : Mohammad Satrio Utomo : https://github.com/tyok
//! reference: http://id.wikisource.org/wiki/Pedoman_Umum_Ejaan_Bahasa_Indonesia_yang_Disempurnakan

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var id = moment.defineLocale('id', {
                months: 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split('_'),
                monthsShort: 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nov_Des'.split('_'),
                weekdays: 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),
                weekdaysShort: 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),
                weekdaysMin: 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),
                longDateFormat: {
                    LT: 'HH.mm',
                    LTS: 'HH.mm.ss',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY [pukul] HH.mm',
                    LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm'
                },
                meridiemParse: /pagi|siang|sore|malam/,
                meridiemHour: function (hour, meridiem) {
                    if (hour === 12) {
                        hour = 0;
                    }
                    if (meridiem === 'pagi') {
                        return hour;
                    } else if (meridiem === 'siang') {
                        return hour >= 11 ? hour : hour + 12;
                    } else if (meridiem === 'sore' || meridiem === 'malam') {
                        return hour + 12;
                    }
                },
                meridiem: function (hours, minutes, isLower) {
                    if (hours < 11) {
                        return 'pagi';
                    } else if (hours < 15) {
                        return 'siang';
                    } else if (hours < 19) {
                        return 'sore';
                    } else {
                        return 'malam';
                    }
                },
                calendar: {
                    sameDay: '[Hari ini pukul] LT',
                    nextDay: '[Besok pukul] LT',
                    nextWeek: 'dddd [pukul] LT',
                    lastDay: '[Kemarin pukul] LT',
                    lastWeek: 'dddd [lalu pukul] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'dalam %s',
                    past: '%s yang lalu',
                    s: 'beberapa detik',
                    m: 'semenit',
                    mm: '%d menit',
                    h: 'sejam',
                    hh: '%d jam',
                    d: 'sehari',
                    dd: '%d hari',
                    M: 'sebulan',
                    MM: '%d bulan',
                    y: 'setahun',
                    yy: '%d tahun'
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7  // The week that contains Jan 1st is the first week of the year.
                }
            });

            return id;

        })));


        /***/
    },
    /* 49 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Icelandic [is]
//! author : Hinrik rn Sigursson : https://github.com/hinrik

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            function plural(n) {
                if (n % 100 === 11) {
                    return true;
                } else if (n % 10 === 1) {
                    return false;
                }
                return true;
            }

            function translate(number, withoutSuffix, key, isFuture) {
                var result = number + ' ';
                switch (key) {
                    case 's':
                        return withoutSuffix || isFuture ? 'nokkrar sekndur' : 'nokkrum sekndum';
                    case 'm':
                        return withoutSuffix ? 'mnta' : 'mntu';
                    case 'mm':
                        if (plural(number)) {
                            return result + (withoutSuffix || isFuture ? 'mntur' : 'mntum');
                        } else if (withoutSuffix) {
                            return result + 'mnta';
                        }
                        return result + 'mntu';
                    case 'hh':
                        if (plural(number)) {
                            return result + (withoutSuffix || isFuture ? 'klukkustundir' : 'klukkustundum');
                        }
                        return result + 'klukkustund';
                    case 'd':
                        if (withoutSuffix) {
                            return 'dagur';
                        }
                        return isFuture ? 'dag' : 'degi';
                    case 'dd':
                        if (plural(number)) {
                            if (withoutSuffix) {
                                return result + 'dagar';
                            }
                            return result + (isFuture ? 'daga' : 'dgum');
                        } else if (withoutSuffix) {
                            return result + 'dagur';
                        }
                        return result + (isFuture ? 'dag' : 'degi');
                    case 'M':
                        if (withoutSuffix) {
                            return 'mnuur';
                        }
                        return isFuture ? 'mnu' : 'mnui';
                    case 'MM':
                        if (plural(number)) {
                            if (withoutSuffix) {
                                return result + 'mnuir';
                            }
                            return result + (isFuture ? 'mnui' : 'mnuum');
                        } else if (withoutSuffix) {
                            return result + 'mnuur';
                        }
                        return result + (isFuture ? 'mnu' : 'mnui');
                    case 'y':
                        return withoutSuffix || isFuture ? 'r' : 'ri';
                    case 'yy':
                        if (plural(number)) {
                            return result + (withoutSuffix || isFuture ? 'r' : 'rum');
                        }
                        return result + (withoutSuffix || isFuture ? 'r' : 'ri');
                }
            }

            var is = moment.defineLocale('is', {
                months: 'janar_febrar_mars_aprl_ma_jn_jl_gst_september_oktber_nvember_desember'.split('_'),
                monthsShort: 'jan_feb_mar_apr_ma_jn_jl_g_sep_okt_nv_des'.split('_'),
                weekdays: 'sunnudagur_mnudagur_rijudagur_mivikudagur_fimmtudagur_fstudagur_laugardagur'.split('_'),
                weekdaysShort: 'sun_mn_ri_mi_fim_fs_lau'.split('_'),
                weekdaysMin: 'Su_M_r_Mi_Fi_F_La'.split('_'),
                longDateFormat: {
                    LT: 'H:mm',
                    LTS: 'H:mm:ss',
                    L: 'DD.MM.YYYY',
                    LL: 'D. MMMM YYYY',
                    LLL: 'D. MMMM YYYY [kl.] H:mm',
                    LLLL: 'dddd, D. MMMM YYYY [kl.] H:mm'
                },
                calendar: {
                    sameDay: '[ dag kl.] LT',
                    nextDay: '[ morgun kl.] LT',
                    nextWeek: 'dddd [kl.] LT',
                    lastDay: '[ gr kl.] LT',
                    lastWeek: '[sasta] dddd [kl.] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'eftir %s',
                    past: 'fyrir %s san',
                    s: translate,
                    m: translate,
                    mm: translate,
                    h: 'klukkustund',
                    hh: translate,
                    d: translate,
                    dd: translate,
                    M: translate,
                    MM: translate,
                    y: translate,
                    yy: translate
                },
                ordinalParse: /\d{1,2}\./,
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4  // The week that contains Jan 4th is the first week of the year.
                }
            });

            return is;

        })));


        /***/
    },
    /* 50 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Italian [it]
//! author : Lorenzo : https://github.com/aliem
//! author: Mattia Larentis: https://github.com/nostalgiaz

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var it = moment.defineLocale('it', {
                months: 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
                monthsShort: 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
                weekdays: 'Domenica_Luned_Marted_Mercoled_Gioved_Venerd_Sabato'.split('_'),
                weekdaysShort: 'Dom_Lun_Mar_Mer_Gio_Ven_Sab'.split('_'),
                weekdaysMin: 'Do_Lu_Ma_Me_Gi_Ve_Sa'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY HH:mm',
                    LLLL: 'dddd, D MMMM YYYY HH:mm'
                },
                calendar: {
                    sameDay: '[Oggi alle] LT',
                    nextDay: '[Domani alle] LT',
                    nextWeek: 'dddd [alle] LT',
                    lastDay: '[Ieri alle] LT',
                    lastWeek: function () {
                        switch (this.day()) {
                            case 0:
                                return '[la scorsa] dddd [alle] LT';
                            default:
                                return '[lo scorso] dddd [alle] LT';
                        }
                    },
                    sameElse: 'L'
                },
                relativeTime: {
                    future: function (s) {
                        return ((/^[0-9].+$/).test(s) ? 'tra' : 'in') + ' ' + s;
                    },
                    past: '%s fa',
                    s: 'alcuni secondi',
                    m: 'un minuto',
                    mm: '%d minuti',
                    h: 'un\'ora',
                    hh: '%d ore',
                    d: 'un giorno',
                    dd: '%d giorni',
                    M: 'un mese',
                    MM: '%d mesi',
                    y: 'un anno',
                    yy: '%d anni'
                },
                ordinalParse: /\d{1,2}/,
                ordinal: '%d',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4  // The week that contains Jan 4th is the first week of the year.
                }
            });

            return it;

        })));


        /***/
    },
    /* 51 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Japanese [ja]
//! author : LI Long : https://github.com/baryon

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var ja = moment.defineLocale('ja', {
                months: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
                monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'Ahm',
                    LTS: 'Ahms',
                    L: 'YYYY/MM/DD',
                    LL: 'YYYYMD',
                    LLL: 'YYYYMDAhm',
                    LLLL: 'YYYYMDAhm dddd'
                },
                meridiemParse: /|/i,
                isPM: function (input) {
                    return input === '';
                },
                meridiem: function (hour, minute, isLower) {
                    if (hour < 12) {
                        return '';
                    } else {
                        return '';
                    }
                },
                calendar: {
                    sameDay: '[] LT',
                    nextDay: '[] LT',
                    nextWeek: '[]dddd LT',
                    lastDay: '[] LT',
                    lastWeek: '[]dddd LT',
                    sameElse: 'L'
                },
                ordinalParse: /\d{1,2}/,
                ordinal: function (number, period) {
                    switch (period) {
                        case 'd':
                        case 'D':
                        case 'DDD':
                            return number + '';
                        default:
                            return number;
                    }
                },
                relativeTime: {
                    future: '%s',
                    past: '%s',
                    s: '',
                    m: '1',
                    mm: '%d',
                    h: '1',
                    hh: '%d',
                    d: '1',
                    dd: '%d',
                    M: '1',
                    MM: '%d',
                    y: '1',
                    yy: '%d'
                }
            });

            return ja;

        })));


        /***/
    },
    /* 52 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Javanese [jv]
//! author : Rony Lantip : https://github.com/lantip
//! reference: http://jv.wikipedia.org/wiki/Basa_Jawa

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var jv = moment.defineLocale('jv', {
                months: 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember'.split('_'),
                monthsShort: 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des'.split('_'),
                weekdays: 'Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu'.split('_'),
                weekdaysShort: 'Min_Sen_Sel_Reb_Kem_Jem_Sep'.split('_'),
                weekdaysMin: 'Mg_Sn_Sl_Rb_Km_Jm_Sp'.split('_'),
                longDateFormat: {
                    LT: 'HH.mm',
                    LTS: 'HH.mm.ss',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY [pukul] HH.mm',
                    LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm'
                },
                meridiemParse: /enjing|siyang|sonten|ndalu/,
                meridiemHour: function (hour, meridiem) {
                    if (hour === 12) {
                        hour = 0;
                    }
                    if (meridiem === 'enjing') {
                        return hour;
                    } else if (meridiem === 'siyang') {
                        return hour >= 11 ? hour : hour + 12;
                    } else if (meridiem === 'sonten' || meridiem === 'ndalu') {
                        return hour + 12;
                    }
                },
                meridiem: function (hours, minutes, isLower) {
                    if (hours < 11) {
                        return 'enjing';
                    } else if (hours < 15) {
                        return 'siyang';
                    } else if (hours < 19) {
                        return 'sonten';
                    } else {
                        return 'ndalu';
                    }
                },
                calendar: {
                    sameDay: '[Dinten puniko pukul] LT',
                    nextDay: '[Mbenjang pukul] LT',
                    nextWeek: 'dddd [pukul] LT',
                    lastDay: '[Kala wingi pukul] LT',
                    lastWeek: 'dddd [kepengker pukul] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'wonten ing %s',
                    past: '%s ingkang kepengker',
                    s: 'sawetawis detik',
                    m: 'setunggal menit',
                    mm: '%d menit',
                    h: 'setunggal jam',
                    hh: '%d jam',
                    d: 'sedinten',
                    dd: '%d dinten',
                    M: 'sewulan',
                    MM: '%d wulan',
                    y: 'setaun',
                    yy: '%d taun'
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7  // The week that contains Jan 1st is the first week of the year.
                }
            });

            return jv;

        })));


        /***/
    },
    /* 53 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Georgian [ka]
//! author : Irakli Janiashvili : https://github.com/irakli-janiashvili

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var ka = moment.defineLocale('ka', {
                months: {
                    standalone: '___________'.split('_'),
                    format: '___________'.split('_')
                },
                monthsShort: '___________'.split('_'),
                weekdays: {
                    standalone: '______'.split('_'),
                    format: '______'.split('_'),
                    isFormat: /(|)/
                },
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'h:mm A',
                    LTS: 'h:mm:ss A',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY h:mm A',
                    LLLL: 'dddd, D MMMM YYYY h:mm A'
                },
                calendar: {
                    sameDay: '[] LT[-]',
                    nextDay: '[] LT[-]',
                    lastDay: '[] LT[-]',
                    nextWeek: '[] dddd LT[-]',
                    lastWeek: '[] dddd LT-',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: function (s) {
                        return (/(|||)/).test(s) ?
                            s.replace(/$/, '') :
                            s + '';
                    },
                    past: function (s) {
                        if ((/(||||)/).test(s)) {
                            return s.replace(/(|)$/, ' ');
                        }
                        if ((//).test(s)) {
                            return s.replace(/$/, ' ');
                        }
                    },
                    s: ' ',
                    m: '',
                    mm: '%d ',
                    h: '',
                    hh: '%d ',
                    d: '',
                    dd: '%d ',
                    M: '',
                    MM: '%d ',
                    y: '',
                    yy: '%d '
                },
                ordinalParse: /0|1-|-\d{1,2}|\d{1,2}-/,
                ordinal: function (number) {
                    if (number === 0) {
                        return number;
                    }
                    if (number === 1) {
                        return number + '-';
                    }
                    if ((number < 20) || (number <= 100 && (number % 20 === 0)) || (number % 100 === 0)) {
                        return '-' + number;
                    }
                    return number + '-';
                },
                week: {
                    dow: 1,
                    doy: 7
                }
            });

            return ka;

        })));


        /***/
    },
    /* 54 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Kazakh [kk]
//! authors : Nurlan Rakhimzhanov : https://github.com/nurlan

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var suffixes = {
                0: '-',
                1: '-',
                2: '-',
                3: '-',
                4: '-',
                5: '-',
                6: '-',
                7: '-',
                8: '-',
                9: '-',
                10: '-',
                20: '-',
                30: '-',
                40: '-',
                50: '-',
                60: '-',
                70: '-',
                80: '-',
                90: '-',
                100: '-'
            };

            var kk = moment.defineLocale('kk', {
                months: '___________'.split('_'),
                monthsShort: '___________'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD.MM.YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY HH:mm',
                    LLLL: 'dddd, D MMMM YYYY HH:mm'
                },
                calendar: {
                    sameDay: '[ ] LT',
                    nextDay: '[ ] LT',
                    nextWeek: 'dddd [] LT',
                    lastDay: '[ ] LT',
                    lastWeek: '[ ] dddd [] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: '%s ',
                    past: '%s ',
                    s: ' ',
                    m: ' ',
                    mm: '%d ',
                    h: ' ',
                    hh: '%d ',
                    d: ' ',
                    dd: '%d ',
                    M: ' ',
                    MM: '%d ',
                    y: ' ',
                    yy: '%d '
                },
                ordinalParse: /\d{1,2}-(|)/,
                ordinal: function (number) {
                    var a = number % 10,
                        b = number >= 100 ? 100 : null;
                    return number + (suffixes[number] || suffixes[a] || suffixes[b]);
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7  // The week that contains Jan 1st is the first week of the year.
                }
            });

            return kk;

        })));


        /***/
    },
    /* 55 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Cambodian [km]
//! author : Kruy Vanna : https://github.com/kruyvanna

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var km = moment.defineLocale('km', {
                months: '___________'.split('_'),
                monthsShort: '___________'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY HH:mm',
                    LLLL: 'dddd, D MMMM YYYY HH:mm'
                },
                calendar: {
                    sameDay: '[ ] LT',
                    nextDay: '[ ] LT',
                    nextWeek: 'dddd [] LT',
                    lastDay: '[ ] LT',
                    lastWeek: 'dddd [] [] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: '%s',
                    past: '%s',
                    s: '',
                    m: '',
                    mm: '%d ',
                    h: '',
                    hh: '%d ',
                    d: '',
                    dd: '%d ',
                    M: '',
                    MM: '%d ',
                    y: '',
                    yy: '%d '
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4 // The week that contains Jan 4th is the first week of the year.
                }
            });

            return km;

        })));


        /***/
    },
    /* 56 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Korean [ko]
//! author : Kyungwook, Park : https://github.com/kyungw00k
//! author : Jeeeyul Lee <jeeeyul@gmail.com>

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var ko = moment.defineLocale('ko', {
                months: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
                monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'A h m',
                    LTS: 'A h m s',
                    L: 'YYYY.MM.DD',
                    LL: 'YYYY MMMM D',
                    LLL: 'YYYY MMMM D A h m',
                    LLLL: 'YYYY MMMM D dddd A h m'
                },
                calendar: {
                    sameDay: ' LT',
                    nextDay: ' LT',
                    nextWeek: 'dddd LT',
                    lastDay: ' LT',
                    lastWeek: ' dddd LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: '%s ',
                    past: '%s ',
                    s: ' ',
                    ss: '%d',
                    m: '',
                    mm: '%d',
                    h: ' ',
                    hh: '%d',
                    d: '',
                    dd: '%d',
                    M: ' ',
                    MM: '%d',
                    y: ' ',
                    yy: '%d'
                },
                ordinalParse: /\d{1,2}/,
                ordinal: '%d',
                meridiemParse: /|/,
                isPM: function (token) {
                    return token === '';
                },
                meridiem: function (hour, minute, isUpper) {
                    return hour < 12 ? '' : '';
                }
            });

            return ko;

        })));


        /***/
    },
    /* 57 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Kyrgyz [ky]
//! author : Chyngyz Arystan uulu : https://github.com/chyngyz

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var suffixes = {
                0: '-',
                1: '-',
                2: '-',
                3: '-',
                4: '-',
                5: '-',
                6: '-',
                7: '-',
                8: '-',
                9: '-',
                10: '-',
                20: '-',
                30: '-',
                40: '-',
                50: '-',
                60: '-',
                70: '-',
                80: '-',
                90: '-',
                100: '-'
            };

            var ky = moment.defineLocale('ky', {
                months: '___________'.split('_'),
                monthsShort: '___________'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD.MM.YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY HH:mm',
                    LLLL: 'dddd, D MMMM YYYY HH:mm'
                },
                calendar: {
                    sameDay: '[ ] LT',
                    nextDay: '[ ] LT',
                    nextWeek: 'dddd [] LT',
                    lastDay: '[ ] LT',
                    lastWeek: '[ ] dddd [] [] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: '%s ',
                    past: '%s ',
                    s: ' ',
                    m: ' ',
                    mm: '%d ',
                    h: ' ',
                    hh: '%d ',
                    d: ' ',
                    dd: '%d ',
                    M: ' ',
                    MM: '%d ',
                    y: ' ',
                    yy: '%d '
                },
                ordinalParse: /\d{1,2}-(|||)/,
                ordinal: function (number) {
                    var a = number % 10,
                        b = number >= 100 ? 100 : null;
                    return number + (suffixes[number] || suffixes[a] || suffixes[b]);
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7  // The week that contains Jan 1st is the first week of the year.
                }
            });

            return ky;

        })));


        /***/
    },
    /* 58 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Luxembourgish [lb]
//! author : mweimerskirch : https://github.com/mweimerskirch
//! author : David Raison : https://github.com/kwisatz

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            function processRelativeTime(number, withoutSuffix, key, isFuture) {
                var format = {
                    'm': ['eng Minutt', 'enger Minutt'],
                    'h': ['eng Stonn', 'enger Stonn'],
                    'd': ['een Dag', 'engem Dag'],
                    'M': ['ee Mount', 'engem Mount'],
                    'y': ['ee Joer', 'engem Joer']
                };
                return withoutSuffix ? format[key][0] : format[key][1];
            }

            function processFutureTime(string) {
                var number = string.substr(0, string.indexOf(' '));
                if (eifelerRegelAppliesToNumber(number)) {
                    return 'a ' + string;
                }
                return 'an ' + string;
            }

            function processPastTime(string) {
                var number = string.substr(0, string.indexOf(' '));
                if (eifelerRegelAppliesToNumber(number)) {
                    return 'viru ' + string;
                }
                return 'virun ' + string;
            }

            /**
             * Returns true if the word before the given number loses the '-n' ending.
             * e.g. 'an 10 Deeg' but 'a 5 Deeg'
             *
             * @param number {integer}
             * @returns {boolean}
             */
            function eifelerRegelAppliesToNumber(number) {
                number = parseInt(number, 10);
                if (isNaN(number)) {
                    return false;
                }
                if (number < 0) {
                    // Negative Number --> always true
                    return true;
                } else if (number < 10) {
                    // Only 1 digit
                    if (4 <= number && number <= 7) {
                        return true;
                    }
                    return false;
                } else if (number < 100) {
                    // 2 digits
                    var lastDigit = number % 10, firstDigit = number / 10;
                    if (lastDigit === 0) {
                        return eifelerRegelAppliesToNumber(firstDigit);
                    }
                    return eifelerRegelAppliesToNumber(lastDigit);
                } else if (number < 10000) {
                    // 3 or 4 digits --> recursively check first digit
                    while (number >= 10) {
                        number = number / 10;
                    }
                    return eifelerRegelAppliesToNumber(number);
                } else {
                    // Anything larger than 4 digits: recursively check first n-3 digits
                    number = number / 1000;
                    return eifelerRegelAppliesToNumber(number);
                }
            }

            var lb = moment.defineLocale('lb', {
                months: 'Januar_Februar_Merz_Abrll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
                monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
                monthsParseExact: true,
                weekdays: 'Sonndeg_Mindeg_Dnschdeg_Mttwoch_Donneschdeg_Freideg_Samschdeg'.split('_'),
                weekdaysShort: 'So._M._D._M._Do._Fr._Sa.'.split('_'),
                weekdaysMin: 'So_M_D_M_Do_Fr_Sa'.split('_'),
                weekdaysParseExact: true,
                longDateFormat: {
                    LT: 'H:mm [Auer]',
                    LTS: 'H:mm:ss [Auer]',
                    L: 'DD.MM.YYYY',
                    LL: 'D. MMMM YYYY',
                    LLL: 'D. MMMM YYYY H:mm [Auer]',
                    LLLL: 'dddd, D. MMMM YYYY H:mm [Auer]'
                },
                calendar: {
                    sameDay: '[Haut um] LT',
                    sameElse: 'L',
                    nextDay: '[Muer um] LT',
                    nextWeek: 'dddd [um] LT',
                    lastDay: '[Gschter um] LT',
                    lastWeek: function () {
                        // Different date string for 'Dnschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule
                        switch (this.day()) {
                            case 2:
                            case 4:
                                return '[Leschten] dddd [um] LT';
                            default:
                                return '[Leschte] dddd [um] LT';
                        }
                    }
                },
                relativeTime: {
                    future: processFutureTime,
                    past: processPastTime,
                    s: 'e puer Sekonnen',
                    m: processRelativeTime,
                    mm: '%d Minutten',
                    h: processRelativeTime,
                    hh: '%d Stonnen',
                    d: processRelativeTime,
                    dd: '%d Deeg',
                    M: processRelativeTime,
                    MM: '%d Mint',
                    y: processRelativeTime,
                    yy: '%d Joer'
                },
                ordinalParse: /\d{1,2}\./,
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4  // The week that contains Jan 4th is the first week of the year.
                }
            });

            return lb;

        })));


        /***/
    },
    /* 59 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Lao [lo]
//! author : Ryan Hart : https://github.com/ryanhart2

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var lo = moment.defineLocale('lo', {
                months: '___________'.split('_'),
                monthsShort: '___________'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                weekdaysParseExact: true,
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY HH:mm',
                    LLLL: 'dddd D MMMM YYYY HH:mm'
                },
                meridiemParse: /|/,
                isPM: function (input) {
                    return input === '';
                },
                meridiem: function (hour, minute, isLower) {
                    if (hour < 12) {
                        return '';
                    } else {
                        return '';
                    }
                },
                calendar: {
                    sameDay: '[] LT',
                    nextDay: '[] LT',
                    nextWeek: '[]dddd[] LT',
                    lastDay: '[] LT',
                    lastWeek: '[]dddd[] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: ' %s',
                    past: '%s',
                    s: '',
                    m: '1 ',
                    mm: '%d ',
                    h: '1 ',
                    hh: '%d ',
                    d: '1 ',
                    dd: '%d ',
                    M: '1 ',
                    MM: '%d ',
                    y: '1 ',
                    yy: '%d '
                },
                ordinalParse: /()\d{1,2}/,
                ordinal: function (number) {
                    return '' + number;
                }
            });

            return lo;

        })));


        /***/
    },
    /* 60 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Lithuanian [lt]
//! author : Mindaugas Mozras : https://github.com/mmozuras

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var units = {
                'm': 'minut_minuts_minut',
                'mm': 'minuts_minui_minutes',
                'h': 'valanda_valandos_valand',
                'hh': 'valandos_valand_valandas',
                'd': 'diena_dienos_dien',
                'dd': 'dienos_dien_dienas',
                'M': 'mnuo_mnesio_mnes',
                'MM': 'mnesiai_mnesi_mnesius',
                'y': 'metai_met_metus',
                'yy': 'metai_met_metus'
            };

            function translateSeconds(number, withoutSuffix, key, isFuture) {
                if (withoutSuffix) {
                    return 'kelios sekunds';
                } else {
                    return isFuture ? 'keli sekundi' : 'kelias sekundes';
                }
            }

            function translateSingular(number, withoutSuffix, key, isFuture) {
                return withoutSuffix ? forms(key)[0] : (isFuture ? forms(key)[1] : forms(key)[2]);
            }

            function special(number) {
                return number % 10 === 0 || (number > 10 && number < 20);
            }

            function forms(key) {
                return units[key].split('_');
            }

            function translate(number, withoutSuffix, key, isFuture) {
                var result = number + ' ';
                if (number === 1) {
                    return result + translateSingular(number, withoutSuffix, key[0], isFuture);
                } else if (withoutSuffix) {
                    return result + (special(number) ? forms(key)[1] : forms(key)[0]);
                } else {
                    if (isFuture) {
                        return result + forms(key)[1];
                    } else {
                        return result + (special(number) ? forms(key)[1] : forms(key)[2]);
                    }
                }
            }

            var lt = moment.defineLocale('lt', {
                months: {
                    format: 'sausio_vasario_kovo_balandio_gegus_birelio_liepos_rugpjio_rugsjo_spalio_lapkriio_gruodio'.split('_'),
                    standalone: 'sausis_vasaris_kovas_balandis_gegu_birelis_liepa_rugpjtis_rugsjis_spalis_lapkritis_gruodis'.split('_'),
                    isFormat: /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/
                },
                monthsShort: 'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),
                weekdays: {
                    format: 'sekmadien_pirmadien_antradien_treiadien_ketvirtadien_penktadien_etadien'.split('_'),
                    standalone: 'sekmadienis_pirmadienis_antradienis_treiadienis_ketvirtadienis_penktadienis_etadienis'.split('_'),
                    isFormat: /dddd HH:mm/
                },
                weekdaysShort: 'Sek_Pir_Ant_Tre_Ket_Pen_e'.split('_'),
                weekdaysMin: 'S_P_A_T_K_Pn_'.split('_'),
                weekdaysParseExact: true,
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'YYYY-MM-DD',
                    LL: 'YYYY [m.] MMMM D [d.]',
                    LLL: 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
                    LLLL: 'YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]',
                    l: 'YYYY-MM-DD',
                    ll: 'YYYY [m.] MMMM D [d.]',
                    lll: 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
                    llll: 'YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]'
                },
                calendar: {
                    sameDay: '[iandien] LT',
                    nextDay: '[Rytoj] LT',
                    nextWeek: 'dddd LT',
                    lastDay: '[Vakar] LT',
                    lastWeek: '[Prajus] dddd LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'po %s',
                    past: 'prie %s',
                    s: translateSeconds,
                    m: translateSingular,
                    mm: translate,
                    h: translateSingular,
                    hh: translate,
                    d: translateSingular,
                    dd: translate,
                    M: translateSingular,
                    MM: translate,
                    y: translateSingular,
                    yy: translate
                },
                ordinalParse: /\d{1,2}-oji/,
                ordinal: function (number) {
                    return number + '-oji';
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4  // The week that contains Jan 4th is the first week of the year.
                }
            });

            return lt;

        })));


        /***/
    },
    /* 61 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Latvian [lv]
//! author : Kristaps Karlsons : https://github.com/skakri
//! author : Jnis Elmeris : https://github.com/JanisE

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var units = {
                'm': 'mintes_mintm_minte_mintes'.split('_'),
                'mm': 'mintes_mintm_minte_mintes'.split('_'),
                'h': 'stundas_stundm_stunda_stundas'.split('_'),
                'hh': 'stundas_stundm_stunda_stundas'.split('_'),
                'd': 'dienas_dienm_diena_dienas'.split('_'),
                'dd': 'dienas_dienm_diena_dienas'.split('_'),
                'M': 'mnea_mneiem_mnesis_mnei'.split('_'),
                'MM': 'mnea_mneiem_mnesis_mnei'.split('_'),
                'y': 'gada_gadiem_gads_gadi'.split('_'),
                'yy': 'gada_gadiem_gads_gadi'.split('_')
            };

            /**
             * @param withoutSuffix boolean true = a length of time; false = before/after a period of time.
             */
            function format(forms, number, withoutSuffix) {
                if (withoutSuffix) {
                    // E.g. "21 minte", "3 mintes".
                    return number % 10 === 1 && number % 100 !== 11 ? forms[2] : forms[3];
                } else {
                    // E.g. "21 mintes" as in "pc 21 mintes".
                    // E.g. "3 mintm" as in "pc 3 mintm".
                    return number % 10 === 1 && number % 100 !== 11 ? forms[0] : forms[1];
                }
            }

            function relativeTimeWithPlural(number, withoutSuffix, key) {
                return number + ' ' + format(units[key], number, withoutSuffix);
            }

            function relativeTimeWithSingular(number, withoutSuffix, key) {
                return format(units[key], number, withoutSuffix);
            }

            function relativeSeconds(number, withoutSuffix) {
                return withoutSuffix ? 'daas sekundes' : 'dam sekundm';
            }

            var lv = moment.defineLocale('lv', {
                months: 'janvris_februris_marts_aprlis_maijs_jnijs_jlijs_augusts_septembris_oktobris_novembris_decembris'.split('_'),
                monthsShort: 'jan_feb_mar_apr_mai_jn_jl_aug_sep_okt_nov_dec'.split('_'),
                weekdays: 'svtdiena_pirmdiena_otrdiena_trediena_ceturtdiena_piektdiena_sestdiena'.split('_'),
                weekdaysShort: 'Sv_P_O_T_C_Pk_S'.split('_'),
                weekdaysMin: 'Sv_P_O_T_C_Pk_S'.split('_'),
                weekdaysParseExact: true,
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD.MM.YYYY.',
                    LL: 'YYYY. [gada] D. MMMM',
                    LLL: 'YYYY. [gada] D. MMMM, HH:mm',
                    LLLL: 'YYYY. [gada] D. MMMM, dddd, HH:mm'
                },
                calendar: {
                    sameDay: '[odien pulksten] LT',
                    nextDay: '[Rt pulksten] LT',
                    nextWeek: 'dddd [pulksten] LT',
                    lastDay: '[Vakar pulksten] LT',
                    lastWeek: '[Pagju] dddd [pulksten] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'pc %s',
                    past: 'pirms %s',
                    s: relativeSeconds,
                    m: relativeTimeWithSingular,
                    mm: relativeTimeWithPlural,
                    h: relativeTimeWithSingular,
                    hh: relativeTimeWithPlural,
                    d: relativeTimeWithSingular,
                    dd: relativeTimeWithPlural,
                    M: relativeTimeWithSingular,
                    MM: relativeTimeWithPlural,
                    y: relativeTimeWithSingular,
                    yy: relativeTimeWithPlural
                },
                ordinalParse: /\d{1,2}\./,
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4  // The week that contains Jan 4th is the first week of the year.
                }
            });

            return lv;

        })));


        /***/
    },
    /* 62 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Montenegrin [me]
//! author : Miodrag Nika <miodrag@restartit.me> : https://github.com/miodragnikac

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var translator = {
                words: { //Different grammatical cases
                    m: ['jedan minut', 'jednog minuta'],
                    mm: ['minut', 'minuta', 'minuta'],
                    h: ['jedan sat', 'jednog sata'],
                    hh: ['sat', 'sata', 'sati'],
                    dd: ['dan', 'dana', 'dana'],
                    MM: ['mjesec', 'mjeseca', 'mjeseci'],
                    yy: ['godina', 'godine', 'godina']
                },
                correctGrammaticalCase: function (number, wordKey) {
                    return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
                },
                translate: function (number, withoutSuffix, key) {
                    var wordKey = translator.words[key];
                    if (key.length === 1) {
                        return withoutSuffix ? wordKey[0] : wordKey[1];
                    } else {
                        return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
                    }
                }
            };

            var me = moment.defineLocale('me', {
                months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
                monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
                monthsParseExact: true,
                weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
                weekdaysShort: 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
                weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
                weekdaysParseExact: true,
                longDateFormat: {
                    LT: 'H:mm',
                    LTS: 'H:mm:ss',
                    L: 'DD.MM.YYYY',
                    LL: 'D. MMMM YYYY',
                    LLL: 'D. MMMM YYYY H:mm',
                    LLLL: 'dddd, D. MMMM YYYY H:mm'
                },
                calendar: {
                    sameDay: '[danas u] LT',
                    nextDay: '[sjutra u] LT',

                    nextWeek: function () {
                        switch (this.day()) {
                            case 0:
                                return '[u] [nedjelju] [u] LT';
                            case 3:
                                return '[u] [srijedu] [u] LT';
                            case 6:
                                return '[u] [subotu] [u] LT';
                            case 1:
                            case 2:
                            case 4:
                            case 5:
                                return '[u] dddd [u] LT';
                        }
                    },
                    lastDay: '[jue u] LT',
                    lastWeek: function () {
                        var lastWeekDays = [
                            '[prole] [nedjelje] [u] LT',
                            '[prolog] [ponedjeljka] [u] LT',
                            '[prolog] [utorka] [u] LT',
                            '[prole] [srijede] [u] LT',
                            '[prolog] [etvrtka] [u] LT',
                            '[prolog] [petka] [u] LT',
                            '[prole] [subote] [u] LT'
                        ];
                        return lastWeekDays[this.day()];
                    },
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'za %s',
                    past: 'prije %s',
                    s: 'nekoliko sekundi',
                    m: translator.translate,
                    mm: translator.translate,
                    h: translator.translate,
                    hh: translator.translate,
                    d: 'dan',
                    dd: translator.translate,
                    M: 'mjesec',
                    MM: translator.translate,
                    y: 'godinu',
                    yy: translator.translate
                },
                ordinalParse: /\d{1,2}\./,
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7  // The week that contains Jan 1st is the first week of the year.
                }
            });

            return me;

        })));


        /***/
    },
    /* 63 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Maori [mi]
//! author : John Corrigan <robbiecloset@gmail.com> : https://github.com/johnideal

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var mi = moment.defineLocale('mi', {
                months: 'Kohi-tte_Hui-tanguru_Pout-te-rangi_Paenga-whwh_Haratua_Pipiri_Hngoingoi_Here-turi-kk_Mahuru_Whiringa--nuku_Whiringa--rangi_Hakihea'.split('_'),
                monthsShort: 'Kohi_Hui_Pou_Pae_Hara_Pipi_Hngoi_Here_Mahu_Whi-nu_Whi-ra_Haki'.split('_'),
                monthsRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
                monthsStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
                monthsShortRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
                monthsShortStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,2}/i,
                weekdays: 'Rtapu_Mane_Trei_Wenerei_Tite_Paraire_Htarei'.split('_'),
                weekdaysShort: 'Ta_Ma_T_We_Ti_Pa_H'.split('_'),
                weekdaysMin: 'Ta_Ma_T_We_Ti_Pa_H'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY [i] HH:mm',
                    LLLL: 'dddd, D MMMM YYYY [i] HH:mm'
                },
                calendar: {
                    sameDay: '[i teie mahana, i] LT',
                    nextDay: '[apopo i] LT',
                    nextWeek: 'dddd [i] LT',
                    lastDay: '[inanahi i] LT',
                    lastWeek: 'dddd [whakamutunga i] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'i roto i %s',
                    past: '%s i mua',
                    s: 'te hkona ruarua',
                    m: 'he meneti',
                    mm: '%d meneti',
                    h: 'te haora',
                    hh: '%d haora',
                    d: 'he ra',
                    dd: '%d ra',
                    M: 'he marama',
                    MM: '%d marama',
                    y: 'he tau',
                    yy: '%d tau'
                },
                ordinalParse: /\d{1,2}/,
                ordinal: '%d',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4  // The week that contains Jan 4th is the first week of the year.
                }
            });

            return mi;

        })));


        /***/
    },
    /* 64 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Macedonian [mk]
//! author : Borislav Mickov : https://github.com/B0k0

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var mk = moment.defineLocale('mk', {
                months: '___________'.split('_'),
                monthsShort: '___________'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: 'e_o_____a'.split('_'),
                longDateFormat: {
                    LT: 'H:mm',
                    LTS: 'H:mm:ss',
                    L: 'D.MM.YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY H:mm',
                    LLLL: 'dddd, D MMMM YYYY H:mm'
                },
                calendar: {
                    sameDay: '[ ] LT',
                    nextDay: '[ ] LT',
                    nextWeek: '[] dddd [] LT',
                    lastDay: '[ ] LT',
                    lastWeek: function () {
                        switch (this.day()) {
                            case 0:
                            case 3:
                            case 6:
                                return '[] dddd [] LT';
                            case 1:
                            case 2:
                            case 4:
                            case 5:
                                return '[] dddd [] LT';
                        }
                    },
                    sameElse: 'L'
                },
                relativeTime: {
                    future: ' %s',
                    past: ' %s',
                    s: ' ',
                    m: '',
                    mm: '%d ',
                    h: '',
                    hh: '%d ',
                    d: '',
                    dd: '%d ',
                    M: '',
                    MM: '%d ',
                    y: '',
                    yy: '%d '
                },
                ordinalParse: /\d{1,2}-(|||||)/,
                ordinal: function (number) {
                    var lastDigit = number % 10,
                        last2Digits = number % 100;
                    if (number === 0) {
                        return number + '-';
                    } else if (last2Digits === 0) {
                        return number + '-';
                    } else if (last2Digits > 10 && last2Digits < 20) {
                        return number + '-';
                    } else if (lastDigit === 1) {
                        return number + '-';
                    } else if (lastDigit === 2) {
                        return number + '-';
                    } else if (lastDigit === 7 || lastDigit === 8) {
                        return number + '-';
                    } else {
                        return number + '-';
                    }
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7  // The week that contains Jan 1st is the first week of the year.
                }
            });

            return mk;

        })));


        /***/
    },
    /* 65 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Malayalam [ml]
//! author : Floyd Pink : https://github.com/floydpink

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var ml = moment.defineLocale('ml', {
                months: '___________'.split('_'),
                monthsShort: '._._._.___._._._._._.'.split('_'),
                monthsParseExact: true,
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'A h:mm -',
                    LTS: 'A h:mm:ss -',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY, A h:mm -',
                    LLLL: 'dddd, D MMMM YYYY, A h:mm -'
                },
                calendar: {
                    sameDay: '[] LT',
                    nextDay: '[] LT',
                    nextWeek: 'dddd, LT',
                    lastDay: '[] LT',
                    lastWeek: '[] dddd, LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: '%s ',
                    past: '%s ',
                    s: ' ',
                    m: ' ',
                    mm: '%d ',
                    h: ' ',
                    hh: '%d ',
                    d: ' ',
                    dd: '%d ',
                    M: ' ',
                    MM: '%d ',
                    y: ' ',
                    yy: '%d '
                },
                meridiemParse: /|| ||/i,
                meridiemHour: function (hour, meridiem) {
                    if (hour === 12) {
                        hour = 0;
                    }
                    if ((meridiem === '' && hour >= 4) ||
                        meridiem === ' ' ||
                        meridiem === '') {
                        return hour + 12;
                    } else {
                        return hour;
                    }
                },
                meridiem: function (hour, minute, isLower) {
                    if (hour < 4) {
                        return '';
                    } else if (hour < 12) {
                        return '';
                    } else if (hour < 17) {
                        return ' ';
                    } else if (hour < 20) {
                        return '';
                    } else {
                        return '';
                    }
                }
            });

            return ml;

        })));


        /***/
    },
    /* 66 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Marathi [mr]
//! author : Harshad Kale : https://github.com/kalehv
//! author : Vivek Athalye : https://github.com/vnathalye

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var symbolMap = {
                '1': '',
                '2': '',
                '3': '',
                '4': '',
                '5': '',
                '6': '',
                '7': '',
                '8': '',
                '9': '',
                '0': ''
            };
            var numberMap = {
                '': '1',
                '': '2',
                '': '3',
                '': '4',
                '': '5',
                '': '6',
                '': '7',
                '': '8',
                '': '9',
                '': '0'
            };

            function relativeTimeMr(number, withoutSuffix, string, isFuture) {
                var output = '';
                if (withoutSuffix) {
                    switch (string) {
                        case 's':
                            output = ' ';
                            break;
                        case 'm':
                            output = ' ';
                            break;
                        case 'mm':
                            output = '%d ';
                            break;
                        case 'h':
                            output = ' ';
                            break;
                        case 'hh':
                            output = '%d ';
                            break;
                        case 'd':
                            output = ' ';
                            break;
                        case 'dd':
                            output = '%d ';
                            break;
                        case 'M':
                            output = ' ';
                            break;
                        case 'MM':
                            output = '%d ';
                            break;
                        case 'y':
                            output = ' ';
                            break;
                        case 'yy':
                            output = '%d ';
                            break;
                    }
                }
                else {
                    switch (string) {
                        case 's':
                            output = ' ';
                            break;
                        case 'm':
                            output = ' ';
                            break;
                        case 'mm':
                            output = '%d ';
                            break;
                        case 'h':
                            output = ' ';
                            break;
                        case 'hh':
                            output = '%d ';
                            break;
                        case 'd':
                            output = ' ';
                            break;
                        case 'dd':
                            output = '%d ';
                            break;
                        case 'M':
                            output = ' ';
                            break;
                        case 'MM':
                            output = '%d ';
                            break;
                        case 'y':
                            output = ' ';
                            break;
                        case 'yy':
                            output = '%d ';
                            break;
                    }
                }
                return output.replace(/%d/i, number);
            }

            var mr = moment.defineLocale('mr', {
                months: '___________'.split('_'),
                monthsShort: '._._._._._._._._._._._.'.split('_'),
                monthsParseExact: true,
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'A h:mm ',
                    LTS: 'A h:mm:ss ',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY, A h:mm ',
                    LLLL: 'dddd, D MMMM YYYY, A h:mm '
                },
                calendar: {
                    sameDay: '[] LT',
                    nextDay: '[] LT',
                    nextWeek: 'dddd, LT',
                    lastDay: '[] LT',
                    lastWeek: '[] dddd, LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: '%s',
                    past: '%s',
                    s: relativeTimeMr,
                    m: relativeTimeMr,
                    mm: relativeTimeMr,
                    h: relativeTimeMr,
                    hh: relativeTimeMr,
                    d: relativeTimeMr,
                    dd: relativeTimeMr,
                    M: relativeTimeMr,
                    MM: relativeTimeMr,
                    y: relativeTimeMr,
                    yy: relativeTimeMr
                },
                preparse: function (string) {
                    return string.replace(/[]/g, function (match) {
                        return numberMap[match];
                    });
                },
                postformat: function (string) {
                    return string.replace(/\d/g, function (match) {
                        return symbolMap[match];
                    });
                },
                meridiemParse: /|||/,
                meridiemHour: function (hour, meridiem) {
                    if (hour === 12) {
                        hour = 0;
                    }
                    if (meridiem === '') {
                        return hour < 4 ? hour : hour + 12;
                    } else if (meridiem === '') {
                        return hour;
                    } else if (meridiem === '') {
                        return hour >= 10 ? hour : hour + 12;
                    } else if (meridiem === '') {
                        return hour + 12;
                    }
                },
                meridiem: function (hour, minute, isLower) {
                    if (hour < 4) {
                        return '';
                    } else if (hour < 10) {
                        return '';
                    } else if (hour < 17) {
                        return '';
                    } else if (hour < 20) {
                        return '';
                    } else {
                        return '';
                    }
                },
                week: {
                    dow: 0, // Sunday is the first day of the week.
                    doy: 6  // The week that contains Jan 1st is the first week of the year.
                }
            });

            return mr;

        })));


        /***/
    },
    /* 67 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Malay [ms-my]
//! note : DEPRECATED, the correct one is [ms]
//! author : Weldan Jamili : https://github.com/weldan

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var msMy = moment.defineLocale('ms-my', {
                months: 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
                monthsShort: 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
                weekdays: 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
                weekdaysShort: 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
                weekdaysMin: 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
                longDateFormat: {
                    LT: 'HH.mm',
                    LTS: 'HH.mm.ss',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY [pukul] HH.mm',
                    LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm'
                },
                meridiemParse: /pagi|tengahari|petang|malam/,
                meridiemHour: function (hour, meridiem) {
                    if (hour === 12) {
                        hour = 0;
                    }
                    if (meridiem === 'pagi') {
                        return hour;
                    } else if (meridiem === 'tengahari') {
                        return hour >= 11 ? hour : hour + 12;
                    } else if (meridiem === 'petang' || meridiem === 'malam') {
                        return hour + 12;
                    }
                },
                meridiem: function (hours, minutes, isLower) {
                    if (hours < 11) {
                        return 'pagi';
                    } else if (hours < 15) {
                        return 'tengahari';
                    } else if (hours < 19) {
                        return 'petang';
                    } else {
                        return 'malam';
                    }
                },
                calendar: {
                    sameDay: '[Hari ini pukul] LT',
                    nextDay: '[Esok pukul] LT',
                    nextWeek: 'dddd [pukul] LT',
                    lastDay: '[Kelmarin pukul] LT',
                    lastWeek: 'dddd [lepas pukul] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'dalam %s',
                    past: '%s yang lepas',
                    s: 'beberapa saat',
                    m: 'seminit',
                    mm: '%d minit',
                    h: 'sejam',
                    hh: '%d jam',
                    d: 'sehari',
                    dd: '%d hari',
                    M: 'sebulan',
                    MM: '%d bulan',
                    y: 'setahun',
                    yy: '%d tahun'
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7  // The week that contains Jan 1st is the first week of the year.
                }
            });

            return msMy;

        })));


        /***/
    },
    /* 68 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Malay [ms]
//! author : Weldan Jamili : https://github.com/weldan

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var ms = moment.defineLocale('ms', {
                months: 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
                monthsShort: 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
                weekdays: 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
                weekdaysShort: 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
                weekdaysMin: 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
                longDateFormat: {
                    LT: 'HH.mm',
                    LTS: 'HH.mm.ss',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY [pukul] HH.mm',
                    LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm'
                },
                meridiemParse: /pagi|tengahari|petang|malam/,
                meridiemHour: function (hour, meridiem) {
                    if (hour === 12) {
                        hour = 0;
                    }
                    if (meridiem === 'pagi') {
                        return hour;
                    } else if (meridiem === 'tengahari') {
                        return hour >= 11 ? hour : hour + 12;
                    } else if (meridiem === 'petang' || meridiem === 'malam') {
                        return hour + 12;
                    }
                },
                meridiem: function (hours, minutes, isLower) {
                    if (hours < 11) {
                        return 'pagi';
                    } else if (hours < 15) {
                        return 'tengahari';
                    } else if (hours < 19) {
                        return 'petang';
                    } else {
                        return 'malam';
                    }
                },
                calendar: {
                    sameDay: '[Hari ini pukul] LT',
                    nextDay: '[Esok pukul] LT',
                    nextWeek: 'dddd [pukul] LT',
                    lastDay: '[Kelmarin pukul] LT',
                    lastWeek: 'dddd [lepas pukul] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'dalam %s',
                    past: '%s yang lepas',
                    s: 'beberapa saat',
                    m: 'seminit',
                    mm: '%d minit',
                    h: 'sejam',
                    hh: '%d jam',
                    d: 'sehari',
                    dd: '%d hari',
                    M: 'sebulan',
                    MM: '%d bulan',
                    y: 'setahun',
                    yy: '%d tahun'
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7  // The week that contains Jan 1st is the first week of the year.
                }
            });

            return ms;

        })));


        /***/
    },
    /* 69 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Burmese [my]
//! author : Squar team, mysquar.com
//! author : David Rossellat : https://github.com/gholadr
//! author : Tin Aung Lin : https://github.com/thanyawzinmin

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var symbolMap = {
                '1': '',
                '2': '',
                '3': '',
                '4': '',
                '5': '',
                '6': '',
                '7': '',
                '8': '',
                '9': '',
                '0': ''
            };
            var numberMap = {
                '': '1',
                '': '2',
                '': '3',
                '': '4',
                '': '5',
                '': '6',
                '': '7',
                '': '8',
                '': '9',
                '': '0'
            };

            var my = moment.defineLocale('my', {
                months: '___________'.split('_'),
                monthsShort: '___________'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),

                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY HH:mm',
                    LLLL: 'dddd D MMMM YYYY HH:mm'
                },
                calendar: {
                    sameDay: '[.] LT []',
                    nextDay: '[] LT []',
                    nextWeek: 'dddd LT []',
                    lastDay: '[.] LT []',
                    lastWeek: '[] dddd LT []',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: ' %s ',
                    past: ' %s ',
                    s: '.',
                    m: '',
                    mm: '%d ',
                    h: '',
                    hh: '%d ',
                    d: '',
                    dd: '%d ',
                    M: '',
                    MM: '%d ',
                    y: '',
                    yy: '%d '
                },
                preparse: function (string) {
                    return string.replace(/[]/g, function (match) {
                        return numberMap[match];
                    });
                },
                postformat: function (string) {
                    return string.replace(/\d/g, function (match) {
                        return symbolMap[match];
                    });
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4 // The week that contains Jan 1st is the first week of the year.
                }
            });

            return my;

        })));


        /***/
    },
    /* 70 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Norwegian Bokml [nb]
//! authors : Espen Hovlandsdal : https://github.com/rexxars
//!           Sigurd Gartmann : https://github.com/sigurdga

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var nb = moment.defineLocale('nb', {
                months: 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
                monthsShort: 'jan._feb._mars_april_mai_juni_juli_aug._sep._okt._nov._des.'.split('_'),
                monthsParseExact: true,
                weekdays: 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
                weekdaysShort: 's._ma._ti._on._to._fr._l.'.split('_'),
                weekdaysMin: 's_ma_ti_on_to_fr_l'.split('_'),
                weekdaysParseExact: true,
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD.MM.YYYY',
                    LL: 'D. MMMM YYYY',
                    LLL: 'D. MMMM YYYY [kl.] HH:mm',
                    LLLL: 'dddd D. MMMM YYYY [kl.] HH:mm'
                },
                calendar: {
                    sameDay: '[i dag kl.] LT',
                    nextDay: '[i morgen kl.] LT',
                    nextWeek: 'dddd [kl.] LT',
                    lastDay: '[i gr kl.] LT',
                    lastWeek: '[forrige] dddd [kl.] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'om %s',
                    past: '%s siden',
                    s: 'noen sekunder',
                    m: 'ett minutt',
                    mm: '%d minutter',
                    h: 'en time',
                    hh: '%d timer',
                    d: 'en dag',
                    dd: '%d dager',
                    M: 'en mned',
                    MM: '%d mneder',
                    y: 'ett r',
                    yy: '%d r'
                },
                ordinalParse: /\d{1,2}\./,
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4  // The week that contains Jan 4th is the first week of the year.
                }
            });

            return nb;

        })));


        /***/
    },
    /* 71 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Nepalese [ne]
//! author : suvash : https://github.com/suvash

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var symbolMap = {
                '1': '',
                '2': '',
                '3': '',
                '4': '',
                '5': '',
                '6': '',
                '7': '',
                '8': '',
                '9': '',
                '0': ''
            };
            var numberMap = {
                '': '1',
                '': '2',
                '': '3',
                '': '4',
                '': '5',
                '': '6',
                '': '7',
                '': '8',
                '': '9',
                '': '0'
            };

            var ne = moment.defineLocale('ne', {
                months: '___________'.split('_'),
                monthsShort: '._.__.___._._._._._.'.split('_'),
                monthsParseExact: true,
                weekdays: '______'.split('_'),
                weekdaysShort: '._._._._._._.'.split('_'),
                weekdaysMin: '._._._._._._.'.split('_'),
                weekdaysParseExact: true,
                longDateFormat: {
                    LT: 'A h:mm ',
                    LTS: 'A h:mm:ss ',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY, A h:mm ',
                    LLLL: 'dddd, D MMMM YYYY, A h:mm '
                },
                preparse: function (string) {
                    return string.replace(/[]/g, function (match) {
                        return numberMap[match];
                    });
                },
                postformat: function (string) {
                    return string.replace(/\d/g, function (match) {
                        return symbolMap[match];
                    });
                },
                meridiemParse: /|||/,
                meridiemHour: function (hour, meridiem) {
                    if (hour === 12) {
                        hour = 0;
                    }
                    if (meridiem === '') {
                        return hour < 4 ? hour : hour + 12;
                    } else if (meridiem === '') {
                        return hour;
                    } else if (meridiem === '') {
                        return hour >= 10 ? hour : hour + 12;
                    } else if (meridiem === '') {
                        return hour + 12;
                    }
                },
                meridiem: function (hour, minute, isLower) {
                    if (hour < 3) {
                        return '';
                    } else if (hour < 12) {
                        return '';
                    } else if (hour < 16) {
                        return '';
                    } else if (hour < 20) {
                        return '';
                    } else {
                        return '';
                    }
                },
                calendar: {
                    sameDay: '[] LT',
                    nextDay: '[] LT',
                    nextWeek: '[] dddd[,] LT',
                    lastDay: '[] LT',
                    lastWeek: '[] dddd[,] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: '%s',
                    past: '%s ',
                    s: ' ',
                    m: ' ',
                    mm: '%d ',
                    h: ' ',
                    hh: '%d ',
                    d: ' ',
                    dd: '%d ',
                    M: ' ',
                    MM: '%d ',
                    y: ' ',
                    yy: '%d '
                },
                week: {
                    dow: 0, // Sunday is the first day of the week.
                    doy: 6  // The week that contains Jan 1st is the first week of the year.
                }
            });

            return ne;

        })));


        /***/
    },
    /* 72 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Dutch (Belgium) [nl-be]
//! author : Joris Rling : https://github.com/jorisroling
//! author : Jacob Middag : https://github.com/middagj

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_');
            var monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');

            var monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];
            var monthsRegex = /^(januari|februari|maart|april|mei|april|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;

            var nlBe = moment.defineLocale('nl-be', {
                months: 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
                monthsShort: function (m, format) {
                    if (/-MMM-/.test(format)) {
                        return monthsShortWithoutDots[m.month()];
                    } else {
                        return monthsShortWithDots[m.month()];
                    }
                },

                monthsRegex: monthsRegex,
                monthsShortRegex: monthsRegex,
                monthsStrictRegex: /^(januari|februari|maart|mei|ju[nl]i|april|augustus|september|oktober|november|december)/i,
                monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,

                monthsParse: monthsParse,
                longMonthsParse: monthsParse,
                shortMonthsParse: monthsParse,

                weekdays: 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
                weekdaysShort: 'zo._ma._di._wo._do._vr._za.'.split('_'),
                weekdaysMin: 'Zo_Ma_Di_Wo_Do_Vr_Za'.split('_'),
                weekdaysParseExact: true,
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY HH:mm',
                    LLLL: 'dddd D MMMM YYYY HH:mm'
                },
                calendar: {
                    sameDay: '[vandaag om] LT',
                    nextDay: '[morgen om] LT',
                    nextWeek: 'dddd [om] LT',
                    lastDay: '[gisteren om] LT',
                    lastWeek: '[afgelopen] dddd [om] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'over %s',
                    past: '%s geleden',
                    s: 'een paar seconden',
                    m: 'n minuut',
                    mm: '%d minuten',
                    h: 'n uur',
                    hh: '%d uur',
                    d: 'n dag',
                    dd: '%d dagen',
                    M: 'n maand',
                    MM: '%d maanden',
                    y: 'n jaar',
                    yy: '%d jaar'
                },
                ordinalParse: /\d{1,2}(ste|de)/,
                ordinal: function (number) {
                    return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4  // The week that contains Jan 4th is the first week of the year.
                }
            });

            return nlBe;

        })));


        /***/
    },
    /* 73 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Dutch [nl]
//! author : Joris Rling : https://github.com/jorisroling
//! author : Jacob Middag : https://github.com/middagj

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_');
            var monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');

            var monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];
            var monthsRegex = /^(januari|februari|maart|april|mei|april|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;

            var nl = moment.defineLocale('nl', {
                months: 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
                monthsShort: function (m, format) {
                    if (/-MMM-/.test(format)) {
                        return monthsShortWithoutDots[m.month()];
                    } else {
                        return monthsShortWithDots[m.month()];
                    }
                },

                monthsRegex: monthsRegex,
                monthsShortRegex: monthsRegex,
                monthsStrictRegex: /^(januari|februari|maart|mei|ju[nl]i|april|augustus|september|oktober|november|december)/i,
                monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,

                monthsParse: monthsParse,
                longMonthsParse: monthsParse,
                shortMonthsParse: monthsParse,

                weekdays: 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
                weekdaysShort: 'zo._ma._di._wo._do._vr._za.'.split('_'),
                weekdaysMin: 'Zo_Ma_Di_Wo_Do_Vr_Za'.split('_'),
                weekdaysParseExact: true,
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD-MM-YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY HH:mm',
                    LLLL: 'dddd D MMMM YYYY HH:mm'
                },
                calendar: {
                    sameDay: '[vandaag om] LT',
                    nextDay: '[morgen om] LT',
                    nextWeek: 'dddd [om] LT',
                    lastDay: '[gisteren om] LT',
                    lastWeek: '[afgelopen] dddd [om] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'over %s',
                    past: '%s geleden',
                    s: 'een paar seconden',
                    m: 'n minuut',
                    mm: '%d minuten',
                    h: 'n uur',
                    hh: '%d uur',
                    d: 'n dag',
                    dd: '%d dagen',
                    M: 'n maand',
                    MM: '%d maanden',
                    y: 'n jaar',
                    yy: '%d jaar'
                },
                ordinalParse: /\d{1,2}(ste|de)/,
                ordinal: function (number) {
                    return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4  // The week that contains Jan 4th is the first week of the year.
                }
            });

            return nl;

        })));


        /***/
    },
    /* 74 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Nynorsk [nn]
//! author : https://github.com/mechuwind

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var nn = moment.defineLocale('nn', {
                months: 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
                monthsShort: 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
                weekdays: 'sundag_mndag_tysdag_onsdag_torsdag_fredag_laurdag'.split('_'),
                weekdaysShort: 'sun_mn_tys_ons_tor_fre_lau'.split('_'),
                weekdaysMin: 'su_m_ty_on_to_fr_l'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD.MM.YYYY',
                    LL: 'D. MMMM YYYY',
                    LLL: 'D. MMMM YYYY [kl.] H:mm',
                    LLLL: 'dddd D. MMMM YYYY [kl.] HH:mm'
                },
                calendar: {
                    sameDay: '[I dag klokka] LT',
                    nextDay: '[I morgon klokka] LT',
                    nextWeek: 'dddd [klokka] LT',
                    lastDay: '[I gr klokka] LT',
                    lastWeek: '[Fregande] dddd [klokka] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'om %s',
                    past: '%s sidan',
                    s: 'nokre sekund',
                    m: 'eit minutt',
                    mm: '%d minutt',
                    h: 'ein time',
                    hh: '%d timar',
                    d: 'ein dag',
                    dd: '%d dagar',
                    M: 'ein mnad',
                    MM: '%d mnader',
                    y: 'eit r',
                    yy: '%d r'
                },
                ordinalParse: /\d{1,2}\./,
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4  // The week that contains Jan 4th is the first week of the year.
                }
            });

            return nn;

        })));


        /***/
    },
    /* 75 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Punjabi (India) [pa-in]
//! author : Harpreet Singh : https://github.com/harpreetkhalsagtbit

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var symbolMap = {
                '1': '',
                '2': '',
                '3': '',
                '4': '',
                '5': '',
                '6': '',
                '7': '',
                '8': '',
                '9': '',
                '0': ''
            };
            var numberMap = {
                '': '1',
                '': '2',
                '': '3',
                '': '4',
                '': '5',
                '': '6',
                '': '7',
                '': '8',
                '': '9',
                '': '0'
            };

            var paIn = moment.defineLocale('pa-in', {
                // There are months name as per Nanakshahi Calender but they are not used as rigidly in modern Punjabi.
                months: '___________'.split('_'),
                monthsShort: '___________'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'A h:mm ',
                    LTS: 'A h:mm:ss ',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY, A h:mm ',
                    LLLL: 'dddd, D MMMM YYYY, A h:mm '
                },
                calendar: {
                    sameDay: '[] LT',
                    nextDay: '[] LT',
                    nextWeek: 'dddd, LT',
                    lastDay: '[] LT',
                    lastWeek: '[] dddd, LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: '%s ',
                    past: '%s ',
                    s: ' ',
                    m: ' ',
                    mm: '%d ',
                    h: ' ',
                    hh: '%d ',
                    d: ' ',
                    dd: '%d ',
                    M: ' ',
                    MM: '%d ',
                    y: ' ',
                    yy: '%d '
                },
                preparse: function (string) {
                    return string.replace(/[]/g, function (match) {
                        return numberMap[match];
                    });
                },
                postformat: function (string) {
                    return string.replace(/\d/g, function (match) {
                        return symbolMap[match];
                    });
                },
                // Punjabi notation for meridiems are quite fuzzy in practice. While there exists
                // a rigid notion of a 'Pahar' it is not used as rigidly in modern Punjabi.
                meridiemParse: /|||/,
                meridiemHour: function (hour, meridiem) {
                    if (hour === 12) {
                        hour = 0;
                    }
                    if (meridiem === '') {
                        return hour < 4 ? hour : hour + 12;
                    } else if (meridiem === '') {
                        return hour;
                    } else if (meridiem === '') {
                        return hour >= 10 ? hour : hour + 12;
                    } else if (meridiem === '') {
                        return hour + 12;
                    }
                },
                meridiem: function (hour, minute, isLower) {
                    if (hour < 4) {
                        return '';
                    } else if (hour < 10) {
                        return '';
                    } else if (hour < 17) {
                        return '';
                    } else if (hour < 20) {
                        return '';
                    } else {
                        return '';
                    }
                },
                week: {
                    dow: 0, // Sunday is the first day of the week.
                    doy: 6  // The week that contains Jan 1st is the first week of the year.
                }
            });

            return paIn;

        })));


        /***/
    },
    /* 76 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Polish [pl]
//! author : Rafal Hirsz : https://github.com/evoL

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var monthsNominative = 'stycze_luty_marzec_kwiecie_maj_czerwiec_lipiec_sierpie_wrzesie_padziernik_listopad_grudzie'.split('_');
            var monthsSubjective = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_wrzenia_padziernika_listopada_grudnia'.split('_');

            function plural(n) {
                return (n % 10 < 5) && (n % 10 > 1) && ((~~(n / 10) % 10) !== 1);
            }

            function translate(number, withoutSuffix, key) {
                var result = number + ' ';
                switch (key) {
                    case 'm':
                        return withoutSuffix ? 'minuta' : 'minut';
                    case 'mm':
                        return result + (plural(number) ? 'minuty' : 'minut');
                    case 'h':
                        return withoutSuffix ? 'godzina' : 'godzin';
                    case 'hh':
                        return result + (plural(number) ? 'godziny' : 'godzin');
                    case 'MM':
                        return result + (plural(number) ? 'miesice' : 'miesicy');
                    case 'yy':
                        return result + (plural(number) ? 'lata' : 'lat');
                }
            }

            var pl = moment.defineLocale('pl', {
                months: function (momentToFormat, format) {
                    if (format === '') {
                        // Hack: if format empty we know this is used to generate
                        // RegExp by moment. Give then back both valid forms of months
                        // in RegExp ready format.
                        return '(' + monthsSubjective[momentToFormat.month()] + '|' + monthsNominative[momentToFormat.month()] + ')';
                    } else if (/D MMMM/.test(format)) {
                        return monthsSubjective[momentToFormat.month()];
                    } else {
                        return monthsNominative[momentToFormat.month()];
                    }
                },
                monthsShort: 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_pa_lis_gru'.split('_'),
                weekdays: 'niedziela_poniedziaek_wtorek_roda_czwartek_pitek_sobota'.split('_'),
                weekdaysShort: 'ndz_pon_wt_r_czw_pt_sob'.split('_'),
                weekdaysMin: 'Nd_Pn_Wt_r_Cz_Pt_So'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD.MM.YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY HH:mm',
                    LLLL: 'dddd, D MMMM YYYY HH:mm'
                },
                calendar: {
                    sameDay: '[Dzi o] LT',
                    nextDay: '[Jutro o] LT',
                    nextWeek: '[W] dddd [o] LT',
                    lastDay: '[Wczoraj o] LT',
                    lastWeek: function () {
                        switch (this.day()) {
                            case 0:
                                return '[W zesz niedziel o] LT';
                            case 3:
                                return '[W zesz rod o] LT';
                            case 6:
                                return '[W zesz sobot o] LT';
                            default:
                                return '[W zeszy] dddd [o] LT';
                        }
                    },
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'za %s',
                    past: '%s temu',
                    s: 'kilka sekund',
                    m: translate,
                    mm: translate,
                    h: translate,
                    hh: translate,
                    d: '1 dzie',
                    dd: '%d dni',
                    M: 'miesic',
                    MM: translate,
                    y: 'rok',
                    yy: translate
                },
                ordinalParse: /\d{1,2}\./,
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4  // The week that contains Jan 4th is the first week of the year.
                }
            });

            return pl;

        })));


        /***/
    },
    /* 77 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Portuguese (Brazil) [pt-br]
//! author : Caio Ribeiro Pereira : https://github.com/caio-ribeiro-pereira

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var ptBr = moment.defineLocale('pt-br', {
                months: 'Janeiro_Fevereiro_Maro_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
                monthsShort: 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
                weekdays: 'Domingo_Segunda-feira_Tera-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sbado'.split('_'),
                weekdaysShort: 'Dom_Seg_Ter_Qua_Qui_Sex_Sb'.split('_'),
                weekdaysMin: 'Dom_2_3_4_5_6_Sb'.split('_'),
                weekdaysParseExact: true,
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD/MM/YYYY',
                    LL: 'D [de] MMMM [de] YYYY',
                    LLL: 'D [de] MMMM [de] YYYY [s] HH:mm',
                    LLLL: 'dddd, D [de] MMMM [de] YYYY [s] HH:mm'
                },
                calendar: {
                    sameDay: '[Hoje s] LT',
                    nextDay: '[Amanh s] LT',
                    nextWeek: 'dddd [s] LT',
                    lastDay: '[Ontem s] LT',
                    lastWeek: function () {
                        return (this.day() === 0 || this.day() === 6) ?
                            '[ltimo] dddd [s] LT' : // Saturday + Sunday
                            '[ltima] dddd [s] LT'; // Monday - Friday
                    },
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'em %s',
                    past: '%s atrs',
                    s: 'poucos segundos',
                    m: 'um minuto',
                    mm: '%d minutos',
                    h: 'uma hora',
                    hh: '%d horas',
                    d: 'um dia',
                    dd: '%d dias',
                    M: 'um ms',
                    MM: '%d meses',
                    y: 'um ano',
                    yy: '%d anos'
                },
                ordinalParse: /\d{1,2}/,
                ordinal: '%d'
            });

            return ptBr;

        })));


        /***/
    },
    /* 78 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Portuguese [pt]
//! author : Jefferson : https://github.com/jalex79

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var pt = moment.defineLocale('pt', {
                months: 'Janeiro_Fevereiro_Maro_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
                monthsShort: 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
                weekdays: 'Domingo_Segunda-Feira_Tera-Feira_Quarta-Feira_Quinta-Feira_Sexta-Feira_Sbado'.split('_'),
                weekdaysShort: 'Dom_Seg_Ter_Qua_Qui_Sex_Sb'.split('_'),
                weekdaysMin: 'Dom_2_3_4_5_6_Sb'.split('_'),
                weekdaysParseExact: true,
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD/MM/YYYY',
                    LL: 'D [de] MMMM [de] YYYY',
                    LLL: 'D [de] MMMM [de] YYYY HH:mm',
                    LLLL: 'dddd, D [de] MMMM [de] YYYY HH:mm'
                },
                calendar: {
                    sameDay: '[Hoje s] LT',
                    nextDay: '[Amanh s] LT',
                    nextWeek: 'dddd [s] LT',
                    lastDay: '[Ontem s] LT',
                    lastWeek: function () {
                        return (this.day() === 0 || this.day() === 6) ?
                            '[ltimo] dddd [s] LT' : // Saturday + Sunday
                            '[ltima] dddd [s] LT'; // Monday - Friday
                    },
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'em %s',
                    past: 'h %s',
                    s: 'segundos',
                    m: 'um minuto',
                    mm: '%d minutos',
                    h: 'uma hora',
                    hh: '%d horas',
                    d: 'um dia',
                    dd: '%d dias',
                    M: 'um ms',
                    MM: '%d meses',
                    y: 'um ano',
                    yy: '%d anos'
                },
                ordinalParse: /\d{1,2}/,
                ordinal: '%d',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4  // The week that contains Jan 4th is the first week of the year.
                }
            });

            return pt;

        })));


        /***/
    },
    /* 79 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Romanian [ro]
//! author : Vlad Gurdiga : https://github.com/gurdiga
//! author : Valentin Agachi : https://github.com/avaly

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            function relativeTimeWithPlural(number, withoutSuffix, key) {
                var format = {
                        'mm': 'minute',
                        'hh': 'ore',
                        'dd': 'zile',
                        'MM': 'luni',
                        'yy': 'ani'
                    },
                    separator = ' ';
                if (number % 100 >= 20 || (number >= 100 && number % 100 === 0)) {
                    separator = ' de ';
                }
                return number + separator + format[key];
            }

            var ro = moment.defineLocale('ro', {
                months: 'ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie'.split('_'),
                monthsShort: 'ian._febr._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.'.split('_'),
                monthsParseExact: true,
                weekdays: 'duminic_luni_mari_miercuri_joi_vineri_smbt'.split('_'),
                weekdaysShort: 'Dum_Lun_Mar_Mie_Joi_Vin_Sm'.split('_'),
                weekdaysMin: 'Du_Lu_Ma_Mi_Jo_Vi_S'.split('_'),
                longDateFormat: {
                    LT: 'H:mm',
                    LTS: 'H:mm:ss',
                    L: 'DD.MM.YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY H:mm',
                    LLLL: 'dddd, D MMMM YYYY H:mm'
                },
                calendar: {
                    sameDay: '[azi la] LT',
                    nextDay: '[mine la] LT',
                    nextWeek: 'dddd [la] LT',
                    lastDay: '[ieri la] LT',
                    lastWeek: '[fosta] dddd [la] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'peste %s',
                    past: '%s n urm',
                    s: 'cteva secunde',
                    m: 'un minut',
                    mm: relativeTimeWithPlural,
                    h: 'o or',
                    hh: relativeTimeWithPlural,
                    d: 'o zi',
                    dd: relativeTimeWithPlural,
                    M: 'o lun',
                    MM: relativeTimeWithPlural,
                    y: 'un an',
                    yy: relativeTimeWithPlural
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7  // The week that contains Jan 1st is the first week of the year.
                }
            });

            return ro;

        })));


        /***/
    },
    /* 80 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Russian [ru]
//! author : Viktorminator : https://github.com/Viktorminator
//! Author : Menelion Elensle : https://github.com/Oire
//! author :   : https://github.com/socketpair

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            function plural(word, num) {
                var forms = word.split('_');
                return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
            }

            function relativeTimeWithPlural(number, withoutSuffix, key) {
                var format = {
                    'mm': withoutSuffix ? '__' : '__',
                    'hh': '__',
                    'dd': '__',
                    'MM': '__',
                    'yy': '__'
                };
                if (key === 'm') {
                    return withoutSuffix ? '' : '';
                }
                else {
                    return number + ' ' + plural(format[key], +number);
                }
            }

            var monthsParse = [/^/i, /^/i, /^/i, /^/i, /^[]/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i];

// http://new.gramota.ru/spravka/rules/139-prop :  103
//  : http://new.gramota.ru/spravka/buro/search-answer?s=242637
// CLDR data:          http://www.unicode.org/cldr/charts/28/summary/ru.html#1753
            var ru = moment.defineLocale('ru', {
                months: {
                    format: '___________'.split('_'),
                    standalone: '___________'.split('_')
                },
                monthsShort: {
                    //  CLDR  "."  ".",        ?
                    format: '._._._.____._._._._.'.split('_'),
                    standalone: '._.__.____._._._._.'.split('_')
                },
                weekdays: {
                    standalone: '______'.split('_'),
                    format: '______'.split('_'),
                    isFormat: /\[ ?[] ?(?:||)? ?\] ?dddd/
                },
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                monthsParse: monthsParse,
                longMonthsParse: monthsParse,
                shortMonthsParse: monthsParse,

                //    ,   ,  ,  4 ,      
                monthsRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,

                //  
                monthsShortRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,

                //    
                monthsStrictRegex: /^([]|[]|?|[]|[]|[]|[]|?|[]|[]|[]|[])/i,

                // ,     
                monthsShortStrictRegex: /^(\.|?\.|[.]|\.|[]|[.]|[.]|\.|?\.|\.|?\.|\.)/i,
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD.MM.YYYY',
                    LL: 'D MMMM YYYY .',
                    LLL: 'D MMMM YYYY ., HH:mm',
                    LLLL: 'dddd, D MMMM YYYY ., HH:mm'
                },
                calendar: {
                    sameDay: '[ ] LT',
                    nextDay: '[ ] LT',
                    lastDay: '[ ] LT',
                    nextWeek: function (now) {
                        if (now.week() !== this.week()) {
                            switch (this.day()) {
                                case 0:
                                    return '[ ] dddd [] LT';
                                case 1:
                                case 2:
                                case 4:
                                    return '[ ] dddd [] LT';
                                case 3:
                                case 5:
                                case 6:
                                    return '[ ] dddd [] LT';
                            }
                        } else {
                            if (this.day() === 2) {
                                return '[] dddd [] LT';
                            } else {
                                return '[] dddd [] LT';
                            }
                        }
                    },
                    lastWeek: function (now) {
                        if (now.week() !== this.week()) {
                            switch (this.day()) {
                                case 0:
                                    return '[ ] dddd [] LT';
                                case 1:
                                case 2:
                                case 4:
                                    return '[ ] dddd [] LT';
                                case 3:
                                case 5:
                                case 6:
                                    return '[ ] dddd [] LT';
                            }
                        } else {
                            if (this.day() === 2) {
                                return '[] dddd [] LT';
                            } else {
                                return '[] dddd [] LT';
                            }
                        }
                    },
                    sameElse: 'L'
                },
                relativeTime: {
                    future: ' %s',
                    past: '%s ',
                    s: ' ',
                    m: relativeTimeWithPlural,
                    mm: relativeTimeWithPlural,
                    h: '',
                    hh: relativeTimeWithPlural,
                    d: '',
                    dd: relativeTimeWithPlural,
                    M: '',
                    MM: relativeTimeWithPlural,
                    y: '',
                    yy: relativeTimeWithPlural
                },
                meridiemParse: /|||/i,
                isPM: function (input) {
                    return /^(|)$/.test(input);
                },
                meridiem: function (hour, minute, isLower) {
                    if (hour < 4) {
                        return '';
                    } else if (hour < 12) {
                        return '';
                    } else if (hour < 17) {
                        return '';
                    } else {
                        return '';
                    }
                },
                ordinalParse: /\d{1,2}-(||)/,
                ordinal: function (number, period) {
                    switch (period) {
                        case 'M':
                        case 'd':
                        case 'DDD':
                            return number + '-';
                        case 'D':
                            return number + '-';
                        case 'w':
                        case 'W':
                            return number + '-';
                        default:
                            return number;
                    }
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7  // The week that contains Jan 1st is the first week of the year.
                }
            });

            return ru;

        })));


        /***/
    },
    /* 81 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Northern Sami [se]
//! authors : Brd Rolstad Henriksen : https://github.com/karamell

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var se = moment.defineLocale('se', {
                months: 'oajagemnnu_guovvamnnu_njukamnnu_cuoomnnu_miessemnnu_geassemnnu_suoidnemnnu_borgemnnu_akamnnu_golggotmnnu_skbmamnnu_juovlamnnu'.split('_'),
                monthsShort: 'oj_guov_njuk_cuo_mies_geas_suoi_borg_ak_golg_skb_juov'.split('_'),
                weekdays: 'sotnabeaivi_vuossrga_maebrga_gaskavahkku_duorastat_bearjadat_lvvardat'.split('_'),
                weekdaysShort: 'sotn_vuos_ma_gask_duor_bear_lv'.split('_'),
                weekdaysMin: 's_v_m_g_d_b_L'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD.MM.YYYY',
                    LL: 'MMMM D. [b.] YYYY',
                    LLL: 'MMMM D. [b.] YYYY [ti.] HH:mm',
                    LLLL: 'dddd, MMMM D. [b.] YYYY [ti.] HH:mm'
                },
                calendar: {
                    sameDay: '[otne ti] LT',
                    nextDay: '[ihttin ti] LT',
                    nextWeek: 'dddd [ti] LT',
                    lastDay: '[ikte ti] LT',
                    lastWeek: '[ovddit] dddd [ti] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: '%s geaes',
                    past: 'mait %s',
                    s: 'moadde sekunddat',
                    m: 'okta minuhta',
                    mm: '%d minuhtat',
                    h: 'okta diimmu',
                    hh: '%d diimmut',
                    d: 'okta beaivi',
                    dd: '%d beaivvit',
                    M: 'okta mnnu',
                    MM: '%d mnut',
                    y: 'okta jahki',
                    yy: '%d jagit'
                },
                ordinalParse: /\d{1,2}\./,
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4  // The week that contains Jan 4th is the first week of the year.
                }
            });

            return se;

        })));


        /***/
    },
    /* 82 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Sinhalese [si]
//! author : Sampath Sitinamaluwa : https://github.com/sampathsris

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            /*jshint -W100*/
            var si = moment.defineLocale('si', {
                months: '___________'.split('_'),
                monthsShort: '___________'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                weekdaysParseExact: true,
                longDateFormat: {
                    LT: 'a h:mm',
                    LTS: 'a h:mm:ss',
                    L: 'YYYY/MM/DD',
                    LL: 'YYYY MMMM D',
                    LLL: 'YYYY MMMM D, a h:mm',
                    LLLL: 'YYYY MMMM D [] dddd, a h:mm:ss'
                },
                calendar: {
                    sameDay: '[] LT[]',
                    nextDay: '[] LT[]',
                    nextWeek: 'dddd LT[]',
                    lastDay: '[] LT[]',
                    lastWeek: '[] dddd LT[]',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: '%s',
                    past: '%s ',
                    s: ' ',
                    m: '',
                    mm: ' %d',
                    h: '',
                    hh: ' %d',
                    d: '',
                    dd: ' %d',
                    M: '',
                    MM: ' %d',
                    y: '',
                    yy: ' %d'
                },
                ordinalParse: /\d{1,2} /,
                ordinal: function (number) {
                    return number + ' ';
                },
                meridiemParse: / | |.|../,
                isPM: function (input) {
                    return input === '..' || input === ' ';
                },
                meridiem: function (hours, minutes, isLower) {
                    if (hours > 11) {
                        return isLower ? '..' : ' ';
                    } else {
                        return isLower ? '..' : ' ';
                    }
                }
            });

            return si;

        })));


        /***/
    },
    /* 83 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Slovak [sk]
//! author : Martin Minka : https://github.com/k2s
//! based on work of petrbela : https://github.com/petrbela

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var months = 'janur_februr_marec_aprl_mj_jn_jl_august_september_oktber_november_december'.split('_');
            var monthsShort = 'jan_feb_mar_apr_mj_jn_jl_aug_sep_okt_nov_dec'.split('_');

            function plural(n) {
                return (n > 1) && (n < 5);
            }

            function translate(number, withoutSuffix, key, isFuture) {
                var result = number + ' ';
                switch (key) {
                    case 's':  // a few seconds / in a few seconds / a few seconds ago
                        return (withoutSuffix || isFuture) ? 'pr seknd' : 'pr sekundami';
                    case 'm':  // a minute / in a minute / a minute ago
                        return withoutSuffix ? 'minta' : (isFuture ? 'mintu' : 'mintou');
                    case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
                        if (withoutSuffix || isFuture) {
                            return result + (plural(number) ? 'minty' : 'mint');
                        } else {
                            return result + 'mintami';
                        }
                        break;
                    case 'h':  // an hour / in an hour / an hour ago
                        return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
                    case 'hh': // 9 hours / in 9 hours / 9 hours ago
                        if (withoutSuffix || isFuture) {
                            return result + (plural(number) ? 'hodiny' : 'hodn');
                        } else {
                            return result + 'hodinami';
                        }
                        break;
                    case 'd':  // a day / in a day / a day ago
                        return (withoutSuffix || isFuture) ? 'de' : 'dom';
                    case 'dd': // 9 days / in 9 days / 9 days ago
                        if (withoutSuffix || isFuture) {
                            return result + (plural(number) ? 'dni' : 'dn');
                        } else {
                            return result + 'dami';
                        }
                        break;
                    case 'M':  // a month / in a month / a month ago
                        return (withoutSuffix || isFuture) ? 'mesiac' : 'mesiacom';
                    case 'MM': // 9 months / in 9 months / 9 months ago
                        if (withoutSuffix || isFuture) {
                            return result + (plural(number) ? 'mesiace' : 'mesiacov');
                        } else {
                            return result + 'mesiacmi';
                        }
                        break;
                    case 'y':  // a year / in a year / a year ago
                        return (withoutSuffix || isFuture) ? 'rok' : 'rokom';
                    case 'yy': // 9 years / in 9 years / 9 years ago
                        if (withoutSuffix || isFuture) {
                            return result + (plural(number) ? 'roky' : 'rokov');
                        } else {
                            return result + 'rokmi';
                        }
                        break;
                }
            }

            var sk = moment.defineLocale('sk', {
                months: months,
                monthsShort: monthsShort,
                weekdays: 'nedea_pondelok_utorok_streda_tvrtok_piatok_sobota'.split('_'),
                weekdaysShort: 'ne_po_ut_st_t_pi_so'.split('_'),
                weekdaysMin: 'ne_po_ut_st_t_pi_so'.split('_'),
                longDateFormat: {
                    LT: 'H:mm',
                    LTS: 'H:mm:ss',
                    L: 'DD.MM.YYYY',
                    LL: 'D. MMMM YYYY',
                    LLL: 'D. MMMM YYYY H:mm',
                    LLLL: 'dddd D. MMMM YYYY H:mm'
                },
                calendar: {
                    sameDay: '[dnes o] LT',
                    nextDay: '[zajtra o] LT',
                    nextWeek: function () {
                        switch (this.day()) {
                            case 0:
                                return '[v nedeu o] LT';
                            case 1:
                            case 2:
                                return '[v] dddd [o] LT';
                            case 3:
                                return '[v stredu o] LT';
                            case 4:
                                return '[vo tvrtok o] LT';
                            case 5:
                                return '[v piatok o] LT';
                            case 6:
                                return '[v sobotu o] LT';
                        }
                    },
                    lastDay: '[vera o] LT',
                    lastWeek: function () {
                        switch (this.day()) {
                            case 0:
                                return '[minul nedeu o] LT';
                            case 1:
                            case 2:
                                return '[minul] dddd [o] LT';
                            case 3:
                                return '[minul stredu o] LT';
                            case 4:
                            case 5:
                                return '[minul] dddd [o] LT';
                            case 6:
                                return '[minul sobotu o] LT';
                        }
                    },
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'za %s',
                    past: 'pred %s',
                    s: translate,
                    m: translate,
                    mm: translate,
                    h: translate,
                    hh: translate,
                    d: translate,
                    dd: translate,
                    M: translate,
                    MM: translate,
                    y: translate,
                    yy: translate
                },
                ordinalParse: /\d{1,2}\./,
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4  // The week that contains Jan 4th is the first week of the year.
                }
            });

            return sk;

        })));


        /***/
    },
    /* 84 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Slovenian [sl]
//! author : Robert Sedovek : https://github.com/sedovsek

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            function processRelativeTime(number, withoutSuffix, key, isFuture) {
                var result = number + ' ';
                switch (key) {
                    case 's':
                        return withoutSuffix || isFuture ? 'nekaj sekund' : 'nekaj sekundami';
                    case 'm':
                        return withoutSuffix ? 'ena minuta' : 'eno minuto';
                    case 'mm':
                        if (number === 1) {
                            result += withoutSuffix ? 'minuta' : 'minuto';
                        } else if (number === 2) {
                            result += withoutSuffix || isFuture ? 'minuti' : 'minutama';
                        } else if (number < 5) {
                            result += withoutSuffix || isFuture ? 'minute' : 'minutami';
                        } else {
                            result += withoutSuffix || isFuture ? 'minut' : 'minutami';
                        }
                        return result;
                    case 'h':
                        return withoutSuffix ? 'ena ura' : 'eno uro';
                    case 'hh':
                        if (number === 1) {
                            result += withoutSuffix ? 'ura' : 'uro';
                        } else if (number === 2) {
                            result += withoutSuffix || isFuture ? 'uri' : 'urama';
                        } else if (number < 5) {
                            result += withoutSuffix || isFuture ? 'ure' : 'urami';
                        } else {
                            result += withoutSuffix || isFuture ? 'ur' : 'urami';
                        }
                        return result;
                    case 'd':
                        return withoutSuffix || isFuture ? 'en dan' : 'enim dnem';
                    case 'dd':
                        if (number === 1) {
                            result += withoutSuffix || isFuture ? 'dan' : 'dnem';
                        } else if (number === 2) {
                            result += withoutSuffix || isFuture ? 'dni' : 'dnevoma';
                        } else {
                            result += withoutSuffix || isFuture ? 'dni' : 'dnevi';
                        }
                        return result;
                    case 'M':
                        return withoutSuffix || isFuture ? 'en mesec' : 'enim mesecem';
                    case 'MM':
                        if (number === 1) {
                            result += withoutSuffix || isFuture ? 'mesec' : 'mesecem';
                        } else if (number === 2) {
                            result += withoutSuffix || isFuture ? 'meseca' : 'mesecema';
                        } else if (number < 5) {
                            result += withoutSuffix || isFuture ? 'mesece' : 'meseci';
                        } else {
                            result += withoutSuffix || isFuture ? 'mesecev' : 'meseci';
                        }
                        return result;
                    case 'y':
                        return withoutSuffix || isFuture ? 'eno leto' : 'enim letom';
                    case 'yy':
                        if (number === 1) {
                            result += withoutSuffix || isFuture ? 'leto' : 'letom';
                        } else if (number === 2) {
                            result += withoutSuffix || isFuture ? 'leti' : 'letoma';
                        } else if (number < 5) {
                            result += withoutSuffix || isFuture ? 'leta' : 'leti';
                        } else {
                            result += withoutSuffix || isFuture ? 'let' : 'leti';
                        }
                        return result;
                }
            }

            var sl = moment.defineLocale('sl', {
                months: 'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split('_'),
                monthsShort: 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split('_'),
                monthsParseExact: true,
                weekdays: 'nedelja_ponedeljek_torek_sreda_etrtek_petek_sobota'.split('_'),
                weekdaysShort: 'ned._pon._tor._sre._et._pet._sob.'.split('_'),
                weekdaysMin: 'ne_po_to_sr_e_pe_so'.split('_'),
                weekdaysParseExact: true,
                longDateFormat: {
                    LT: 'H:mm',
                    LTS: 'H:mm:ss',
                    L: 'DD.MM.YYYY',
                    LL: 'D. MMMM YYYY',
                    LLL: 'D. MMMM YYYY H:mm',
                    LLLL: 'dddd, D. MMMM YYYY H:mm'
                },
                calendar: {
                    sameDay: '[danes ob] LT',
                    nextDay: '[jutri ob] LT',

                    nextWeek: function () {
                        switch (this.day()) {
                            case 0:
                                return '[v] [nedeljo] [ob] LT';
                            case 3:
                                return '[v] [sredo] [ob] LT';
                            case 6:
                                return '[v] [soboto] [ob] LT';
                            case 1:
                            case 2:
                            case 4:
                            case 5:
                                return '[v] dddd [ob] LT';
                        }
                    },
                    lastDay: '[veraj ob] LT',
                    lastWeek: function () {
                        switch (this.day()) {
                            case 0:
                                return '[prejnjo] [nedeljo] [ob] LT';
                            case 3:
                                return '[prejnjo] [sredo] [ob] LT';
                            case 6:
                                return '[prejnjo] [soboto] [ob] LT';
                            case 1:
                            case 2:
                            case 4:
                            case 5:
                                return '[prejnji] dddd [ob] LT';
                        }
                    },
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'ez %s',
                    past: 'pred %s',
                    s: processRelativeTime,
                    m: processRelativeTime,
                    mm: processRelativeTime,
                    h: processRelativeTime,
                    hh: processRelativeTime,
                    d: processRelativeTime,
                    dd: processRelativeTime,
                    M: processRelativeTime,
                    MM: processRelativeTime,
                    y: processRelativeTime,
                    yy: processRelativeTime
                },
                ordinalParse: /\d{1,2}\./,
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7  // The week that contains Jan 1st is the first week of the year.
                }
            });

            return sl;

        })));


        /***/
    },
    /* 85 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Albanian [sq]
//! author : Flakrim Ismani : https://github.com/flakerimi
//! author : Menelion Elensle : https://github.com/Oire
//! author : Oerd Cukalla : https://github.com/oerd

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var sq = moment.defineLocale('sq', {
                months: 'Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nntor_Dhjetor'.split('_'),
                monthsShort: 'Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nn_Dhj'.split('_'),
                weekdays: 'E Diel_E Hn_E Mart_E Mrkur_E Enjte_E Premte_E Shtun'.split('_'),
                weekdaysShort: 'Die_Hn_Mar_Mr_Enj_Pre_Sht'.split('_'),
                weekdaysMin: 'D_H_Ma_M_E_P_Sh'.split('_'),
                weekdaysParseExact: true,
                meridiemParse: /PD|MD/,
                isPM: function (input) {
                    return input.charAt(0) === 'M';
                },
                meridiem: function (hours, minutes, isLower) {
                    return hours < 12 ? 'PD' : 'MD';
                },
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY HH:mm',
                    LLLL: 'dddd, D MMMM YYYY HH:mm'
                },
                calendar: {
                    sameDay: '[Sot n] LT',
                    nextDay: '[Nesr n] LT',
                    nextWeek: 'dddd [n] LT',
                    lastDay: '[Dje n] LT',
                    lastWeek: 'dddd [e kaluar n] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'n %s',
                    past: '%s m par',
                    s: 'disa sekonda',
                    m: 'nj minut',
                    mm: '%d minuta',
                    h: 'nj or',
                    hh: '%d or',
                    d: 'nj dit',
                    dd: '%d dit',
                    M: 'nj muaj',
                    MM: '%d muaj',
                    y: 'nj vit',
                    yy: '%d vite'
                },
                ordinalParse: /\d{1,2}\./,
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4  // The week that contains Jan 4th is the first week of the year.
                }
            });

            return sq;

        })));


        /***/
    },
    /* 86 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Serbian Cyrillic [sr-cyrl]
//! author : Milan Janakovi<milanjanackovic@gmail.com> : https://github.com/milan-j

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var translator = {
                words: { //Different grammatical cases
                    m: [' ', ' '],
                    mm: ['', '', ''],
                    h: [' ', ' '],
                    hh: ['', '', ''],
                    dd: ['', '', ''],
                    MM: ['', '', ''],
                    yy: ['', '', '']
                },
                correctGrammaticalCase: function (number, wordKey) {
                    return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
                },
                translate: function (number, withoutSuffix, key) {
                    var wordKey = translator.words[key];
                    if (key.length === 1) {
                        return withoutSuffix ? wordKey[0] : wordKey[1];
                    } else {
                        return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
                    }
                }
            };

            var srCyrl = moment.defineLocale('sr-cyrl', {
                months: '___________'.split('_'),
                monthsShort: '._._._.____._._._._.'.split('_'),
                monthsParseExact: true,
                weekdays: '______'.split('_'),
                weekdaysShort: '._._._._._._.'.split('_'),
                weekdaysMin: '______'.split('_'),
                weekdaysParseExact: true,
                longDateFormat: {
                    LT: 'H:mm',
                    LTS: 'H:mm:ss',
                    L: 'DD.MM.YYYY',
                    LL: 'D. MMMM YYYY',
                    LLL: 'D. MMMM YYYY H:mm',
                    LLLL: 'dddd, D. MMMM YYYY H:mm'
                },
                calendar: {
                    sameDay: '[ ] LT',
                    nextDay: '[ ] LT',
                    nextWeek: function () {
                        switch (this.day()) {
                            case 0:
                                return '[] [] [] LT';
                            case 3:
                                return '[] [] [] LT';
                            case 6:
                                return '[] [] [] LT';
                            case 1:
                            case 2:
                            case 4:
                            case 5:
                                return '[] dddd [] LT';
                        }
                    },
                    lastDay: '[ ] LT',
                    lastWeek: function () {
                        var lastWeekDays = [
                            '[] [] [] LT',
                            '[] [] [] LT',
                            '[] [] [] LT',
                            '[] [] [] LT',
                            '[] [] [] LT',
                            '[] [] [] LT',
                            '[] [] [] LT'
                        ];
                        return lastWeekDays[this.day()];
                    },
                    sameElse: 'L'
                },
                relativeTime: {
                    future: ' %s',
                    past: ' %s',
                    s: ' ',
                    m: translator.translate,
                    mm: translator.translate,
                    h: translator.translate,
                    hh: translator.translate,
                    d: '',
                    dd: translator.translate,
                    M: '',
                    MM: translator.translate,
                    y: '',
                    yy: translator.translate
                },
                ordinalParse: /\d{1,2}\./,
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7  // The week that contains Jan 1st is the first week of the year.
                }
            });

            return srCyrl;

        })));


        /***/
    },
    /* 87 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Serbian [sr]
//! author : Milan Janakovi<milanjanackovic@gmail.com> : https://github.com/milan-j

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var translator = {
                words: { //Different grammatical cases
                    m: ['jedan minut', 'jedne minute'],
                    mm: ['minut', 'minute', 'minuta'],
                    h: ['jedan sat', 'jednog sata'],
                    hh: ['sat', 'sata', 'sati'],
                    dd: ['dan', 'dana', 'dana'],
                    MM: ['mesec', 'meseca', 'meseci'],
                    yy: ['godina', 'godine', 'godina']
                },
                correctGrammaticalCase: function (number, wordKey) {
                    return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
                },
                translate: function (number, withoutSuffix, key) {
                    var wordKey = translator.words[key];
                    if (key.length === 1) {
                        return withoutSuffix ? wordKey[0] : wordKey[1];
                    } else {
                        return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
                    }
                }
            };

            var sr = moment.defineLocale('sr', {
                months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
                monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
                monthsParseExact: true,
                weekdays: 'nedelja_ponedeljak_utorak_sreda_etvrtak_petak_subota'.split('_'),
                weekdaysShort: 'ned._pon._uto._sre._et._pet._sub.'.split('_'),
                weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
                weekdaysParseExact: true,
                longDateFormat: {
                    LT: 'H:mm',
                    LTS: 'H:mm:ss',
                    L: 'DD.MM.YYYY',
                    LL: 'D. MMMM YYYY',
                    LLL: 'D. MMMM YYYY H:mm',
                    LLLL: 'dddd, D. MMMM YYYY H:mm'
                },
                calendar: {
                    sameDay: '[danas u] LT',
                    nextDay: '[sutra u] LT',
                    nextWeek: function () {
                        switch (this.day()) {
                            case 0:
                                return '[u] [nedelju] [u] LT';
                            case 3:
                                return '[u] [sredu] [u] LT';
                            case 6:
                                return '[u] [subotu] [u] LT';
                            case 1:
                            case 2:
                            case 4:
                            case 5:
                                return '[u] dddd [u] LT';
                        }
                    },
                    lastDay: '[jue u] LT',
                    lastWeek: function () {
                        var lastWeekDays = [
                            '[prole] [nedelje] [u] LT',
                            '[prolog] [ponedeljka] [u] LT',
                            '[prolog] [utorka] [u] LT',
                            '[prole] [srede] [u] LT',
                            '[prolog] [etvrtka] [u] LT',
                            '[prolog] [petka] [u] LT',
                            '[prole] [subote] [u] LT'
                        ];
                        return lastWeekDays[this.day()];
                    },
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'za %s',
                    past: 'pre %s',
                    s: 'nekoliko sekundi',
                    m: translator.translate,
                    mm: translator.translate,
                    h: translator.translate,
                    hh: translator.translate,
                    d: 'dan',
                    dd: translator.translate,
                    M: 'mesec',
                    MM: translator.translate,
                    y: 'godinu',
                    yy: translator.translate
                },
                ordinalParse: /\d{1,2}\./,
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7  // The week that contains Jan 1st is the first week of the year.
                }
            });

            return sr;

        })));


        /***/
    },
    /* 88 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : siSwati [ss]
//! author : Nicolai Davies<mail@nicolai.io> : https://github.com/nicolaidavies

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var ss = moment.defineLocale('ss', {
                months: "Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split('_'),
                monthsShort: 'Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo'.split('_'),
                weekdays: 'Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo'.split('_'),
                weekdaysShort: 'Lis_Umb_Lsb_Les_Lsi_Lsh_Umg'.split('_'),
                weekdaysMin: 'Li_Us_Lb_Lt_Ls_Lh_Ug'.split('_'),
                weekdaysParseExact: true,
                longDateFormat: {
                    LT: 'h:mm A',
                    LTS: 'h:mm:ss A',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY h:mm A',
                    LLLL: 'dddd, D MMMM YYYY h:mm A'
                },
                calendar: {
                    sameDay: '[Namuhla nga] LT',
                    nextDay: '[Kusasa nga] LT',
                    nextWeek: 'dddd [nga] LT',
                    lastDay: '[Itolo nga] LT',
                    lastWeek: 'dddd [leliphelile] [nga] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'nga %s',
                    past: 'wenteka nga %s',
                    s: 'emizuzwana lomcane',
                    m: 'umzuzu',
                    mm: '%d emizuzu',
                    h: 'lihora',
                    hh: '%d emahora',
                    d: 'lilanga',
                    dd: '%d emalanga',
                    M: 'inyanga',
                    MM: '%d tinyanga',
                    y: 'umnyaka',
                    yy: '%d iminyaka'
                },
                meridiemParse: /ekuseni|emini|entsambama|ebusuku/,
                meridiem: function (hours, minutes, isLower) {
                    if (hours < 11) {
                        return 'ekuseni';
                    } else if (hours < 15) {
                        return 'emini';
                    } else if (hours < 19) {
                        return 'entsambama';
                    } else {
                        return 'ebusuku';
                    }
                },
                meridiemHour: function (hour, meridiem) {
                    if (hour === 12) {
                        hour = 0;
                    }
                    if (meridiem === 'ekuseni') {
                        return hour;
                    } else if (meridiem === 'emini') {
                        return hour >= 11 ? hour : hour + 12;
                    } else if (meridiem === 'entsambama' || meridiem === 'ebusuku') {
                        if (hour === 0) {
                            return 0;
                        }
                        return hour + 12;
                    }
                },
                ordinalParse: /\d{1,2}/,
                ordinal: '%d',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4  // The week that contains Jan 4th is the first week of the year.
                }
            });

            return ss;

        })));


        /***/
    },
    /* 89 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Swedish [sv]
//! author : Jens Alm : https://github.com/ulmus

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var sv = moment.defineLocale('sv', {
                months: 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split('_'),
                monthsShort: 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
                weekdays: 'sndag_mndag_tisdag_onsdag_torsdag_fredag_lrdag'.split('_'),
                weekdaysShort: 'sn_mn_tis_ons_tor_fre_lr'.split('_'),
                weekdaysMin: 's_m_ti_on_to_fr_l'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'YYYY-MM-DD',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY [kl.] HH:mm',
                    LLLL: 'dddd D MMMM YYYY [kl.] HH:mm',
                    lll: 'D MMM YYYY HH:mm',
                    llll: 'ddd D MMM YYYY HH:mm'
                },
                calendar: {
                    sameDay: '[Idag] LT',
                    nextDay: '[Imorgon] LT',
                    lastDay: '[Igr] LT',
                    nextWeek: '[P] dddd LT',
                    lastWeek: '[I] dddd[s] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'om %s',
                    past: 'fr %s sedan',
                    s: 'ngra sekunder',
                    m: 'en minut',
                    mm: '%d minuter',
                    h: 'en timme',
                    hh: '%d timmar',
                    d: 'en dag',
                    dd: '%d dagar',
                    M: 'en mnad',
                    MM: '%d mnader',
                    y: 'ett r',
                    yy: '%d r'
                },
                ordinalParse: /\d{1,2}(e|a)/,
                ordinal: function (number) {
                    var b = number % 10,
                        output = (~~(number % 100 / 10) === 1) ? 'e' :
                            (b === 1) ? 'a' :
                                (b === 2) ? 'a' :
                                    (b === 3) ? 'e' : 'e';
                    return number + output;
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4  // The week that contains Jan 4th is the first week of the year.
                }
            });

            return sv;

        })));


        /***/
    },
    /* 90 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Swahili [sw]
//! author : Fahad Kassim : https://github.com/fadsel

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var sw = moment.defineLocale('sw', {
                months: 'Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba'.split('_'),
                monthsShort: 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des'.split('_'),
                weekdays: 'Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi'.split('_'),
                weekdaysShort: 'Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos'.split('_'),
                weekdaysMin: 'J2_J3_J4_J5_Al_Ij_J1'.split('_'),
                weekdaysParseExact: true,
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD.MM.YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY HH:mm',
                    LLLL: 'dddd, D MMMM YYYY HH:mm'
                },
                calendar: {
                    sameDay: '[leo saa] LT',
                    nextDay: '[kesho saa] LT',
                    nextWeek: '[wiki ijayo] dddd [saat] LT',
                    lastDay: '[jana] LT',
                    lastWeek: '[wiki iliyopita] dddd [saat] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: '%s baadaye',
                    past: 'tokea %s',
                    s: 'hivi punde',
                    m: 'dakika moja',
                    mm: 'dakika %d',
                    h: 'saa limoja',
                    hh: 'masaa %d',
                    d: 'siku moja',
                    dd: 'masiku %d',
                    M: 'mwezi mmoja',
                    MM: 'miezi %d',
                    y: 'mwaka mmoja',
                    yy: 'miaka %d'
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7  // The week that contains Jan 1st is the first week of the year.
                }
            });

            return sw;

        })));


        /***/
    },
    /* 91 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Tamil [ta]
//! author : Arjunkumar Krishnamoorthy : https://github.com/tk120404

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var symbolMap = {
                '1': '',
                '2': '',
                '3': '',
                '4': '',
                '5': '',
                '6': '',
                '7': '',
                '8': '',
                '9': '',
                '0': ''
            };
            var numberMap = {
                '': '1',
                '': '2',
                '': '3',
                '': '4',
                '': '5',
                '': '6',
                '': '7',
                '': '8',
                '': '9',
                '': '0'
            };

            var ta = moment.defineLocale('ta', {
                months: '___________'.split('_'),
                monthsShort: '___________'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY, HH:mm',
                    LLLL: 'dddd, D MMMM YYYY, HH:mm'
                },
                calendar: {
                    sameDay: '[] LT',
                    nextDay: '[] LT',
                    nextWeek: 'dddd, LT',
                    lastDay: '[] LT',
                    lastWeek: '[ ] dddd, LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: '%s ',
                    past: '%s ',
                    s: '  ',
                    m: ' ',
                    mm: '%d ',
                    h: '  ',
                    hh: '%d  ',
                    d: ' ',
                    dd: '%d ',
                    M: ' ',
                    MM: '%d ',
                    y: ' ',
                    yy: '%d '
                },
                ordinalParse: /\d{1,2}/,
                ordinal: function (number) {
                    return number + '';
                },
                preparse: function (string) {
                    return string.replace(/[]/g, function (match) {
                        return numberMap[match];
                    });
                },
                postformat: function (string) {
                    return string.replace(/\d/g, function (match) {
                        return symbolMap[match];
                    });
                },
                // refer http://ta.wikipedia.org/s/1er1
                meridiemParse: /|||||/,
                meridiem: function (hour, minute, isLower) {
                    if (hour < 2) {
                        return ' ';
                    } else if (hour < 6) {
                        return ' ';  // 
                    } else if (hour < 10) {
                        return ' '; // 
                    } else if (hour < 14) {
                        return ' '; // 
                    } else if (hour < 18) {
                        return ' '; // 
                    } else if (hour < 22) {
                        return ' '; // 
                    } else {
                        return ' ';
                    }
                },
                meridiemHour: function (hour, meridiem) {
                    if (hour === 12) {
                        hour = 0;
                    }
                    if (meridiem === '') {
                        return hour < 2 ? hour : hour + 12;
                    } else if (meridiem === '' || meridiem === '') {
                        return hour;
                    } else if (meridiem === '') {
                        return hour >= 10 ? hour : hour + 12;
                    } else {
                        return hour + 12;
                    }
                },
                week: {
                    dow: 0, // Sunday is the first day of the week.
                    doy: 6  // The week that contains Jan 1st is the first week of the year.
                }
            });

            return ta;

        })));


        /***/
    },
    /* 92 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Telugu [te]
//! author : Krishna Chaitanya Thota : https://github.com/kcthota

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var te = moment.defineLocale('te', {
                months: '___________'.split('_'),
                monthsShort: '._.__.____._._._._.'.split('_'),
                monthsParseExact: true,
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'A h:mm',
                    LTS: 'A h:mm:ss',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY, A h:mm',
                    LLLL: 'dddd, D MMMM YYYY, A h:mm'
                },
                calendar: {
                    sameDay: '[] LT',
                    nextDay: '[] LT',
                    nextWeek: 'dddd, LT',
                    lastDay: '[] LT',
                    lastWeek: '[] dddd, LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: '%s ',
                    past: '%s ',
                    s: ' ',
                    m: ' ',
                    mm: '%d ',
                    h: ' ',
                    hh: '%d ',
                    d: ' ',
                    dd: '%d ',
                    M: ' ',
                    MM: '%d ',
                    y: ' ',
                    yy: '%d '
                },
                ordinalParse: /\d{1,2}/,
                ordinal: '%d',
                meridiemParse: /|||/,
                meridiemHour: function (hour, meridiem) {
                    if (hour === 12) {
                        hour = 0;
                    }
                    if (meridiem === '') {
                        return hour < 4 ? hour : hour + 12;
                    } else if (meridiem === '') {
                        return hour;
                    } else if (meridiem === '') {
                        return hour >= 10 ? hour : hour + 12;
                    } else if (meridiem === '') {
                        return hour + 12;
                    }
                },
                meridiem: function (hour, minute, isLower) {
                    if (hour < 4) {
                        return '';
                    } else if (hour < 10) {
                        return '';
                    } else if (hour < 17) {
                        return '';
                    } else if (hour < 20) {
                        return '';
                    } else {
                        return '';
                    }
                },
                week: {
                    dow: 0, // Sunday is the first day of the week.
                    doy: 6  // The week that contains Jan 1st is the first week of the year.
                }
            });

            return te;

        })));


        /***/
    },
    /* 93 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Tetun Dili (East Timor) [tet]
//! author : Joshua Brooks : https://github.com/joshbrooks
//! author : Onorio De J. Afonso : https://github.com/marobo

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var tet = moment.defineLocale('tet', {
                months: 'Janeiru_Fevereiru_Marsu_Abril_Maiu_Juniu_Juliu_Augustu_Setembru_Outubru_Novembru_Dezembru'.split('_'),
                monthsShort: 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Aug_Set_Out_Nov_Dez'.split('_'),
                weekdays: 'Domingu_Segunda_Tersa_Kuarta_Kinta_Sexta_Sabadu'.split('_'),
                weekdaysShort: 'Dom_Seg_Ters_Kua_Kint_Sext_Sab'.split('_'),
                weekdaysMin: 'Do_Seg_Te_Ku_Ki_Sex_Sa'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY HH:mm',
                    LLLL: 'dddd, D MMMM YYYY HH:mm'
                },
                calendar: {
                    sameDay: '[Ohin iha] LT',
                    nextDay: '[Aban iha] LT',
                    nextWeek: 'dddd [iha] LT',
                    lastDay: '[Horiseik iha] LT',
                    lastWeek: 'dddd [semana kotuk] [iha] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'iha %s',
                    past: '%s liuba',
                    s: 'minutu balun',
                    m: 'minutu ida',
                    mm: 'minutus %d',
                    h: 'horas ida',
                    hh: 'horas %d',
                    d: 'loron ida',
                    dd: 'loron %d',
                    M: 'fulan ida',
                    MM: 'fulan %d',
                    y: 'tinan ida',
                    yy: 'tinan %d'
                },
                ordinalParse: /\d{1,2}(st|nd|rd|th)/,
                ordinal: function (number) {
                    var b = number % 10,
                        output = (~~(number % 100 / 10) === 1) ? 'th' :
                            (b === 1) ? 'st' :
                                (b === 2) ? 'nd' :
                                    (b === 3) ? 'rd' : 'th';
                    return number + output;
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4  // The week that contains Jan 4th is the first week of the year.
                }
            });

            return tet;

        })));


        /***/
    },
    /* 94 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Thai [th]
//! author : Kridsada Thanabulpong : https://github.com/sirn

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var th = moment.defineLocale('th', {
                months: '___________'.split('_'),
                monthsShort: '.._.._.._.._.._.._.._.._.._.._.._..'.split('_'),
                monthsParseExact: true,
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'), // yes, three characters difference
                weekdaysMin: '._._._._._._.'.split('_'),
                weekdaysParseExact: true,
                longDateFormat: {
                    LT: 'H:mm',
                    LTS: 'H:mm:ss',
                    L: 'YYYY/MM/DD',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY  H:mm',
                    LLLL: 'dddd D MMMM YYYY  H:mm'
                },
                meridiemParse: /|/,
                isPM: function (input) {
                    return input === '';
                },
                meridiem: function (hour, minute, isLower) {
                    if (hour < 12) {
                        return '';
                    } else {
                        return '';
                    }
                },
                calendar: {
                    sameDay: '[ ] LT',
                    nextDay: '[ ] LT',
                    nextWeek: 'dddd[ ] LT',
                    lastDay: '[ ] LT',
                    lastWeek: '[]dddd[ ] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: ' %s',
                    past: '%s',
                    s: '',
                    m: '1 ',
                    mm: '%d ',
                    h: '1 ',
                    hh: '%d ',
                    d: '1 ',
                    dd: '%d ',
                    M: '1 ',
                    MM: '%d ',
                    y: '1 ',
                    yy: '%d '
                }
            });

            return th;

        })));


        /***/
    },
    /* 95 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Tagalog (Philippines) [tl-ph]
//! author : Dan Hagman : https://github.com/hagmandan

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var tlPh = moment.defineLocale('tl-ph', {
                months: 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split('_'),
                monthsShort: 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
                weekdays: 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split('_'),
                weekdaysShort: 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
                weekdaysMin: 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'MM/D/YYYY',
                    LL: 'MMMM D, YYYY',
                    LLL: 'MMMM D, YYYY HH:mm',
                    LLLL: 'dddd, MMMM DD, YYYY HH:mm'
                },
                calendar: {
                    sameDay: 'LT [ngayong araw]',
                    nextDay: '[Bukas ng] LT',
                    nextWeek: 'LT [sa susunod na] dddd',
                    lastDay: 'LT [kahapon]',
                    lastWeek: 'LT [noong nakaraang] dddd',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'sa loob ng %s',
                    past: '%s ang nakalipas',
                    s: 'ilang segundo',
                    m: 'isang minuto',
                    mm: '%d minuto',
                    h: 'isang oras',
                    hh: '%d oras',
                    d: 'isang araw',
                    dd: '%d araw',
                    M: 'isang buwan',
                    MM: '%d buwan',
                    y: 'isang taon',
                    yy: '%d taon'
                },
                ordinalParse: /\d{1,2}/,
                ordinal: function (number) {
                    return number;
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4  // The week that contains Jan 4th is the first week of the year.
                }
            });

            return tlPh;

        })));


        /***/
    },
    /* 96 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Klingon [tlh]
//! author : Dominika Kruk : https://github.com/amaranthrose

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var numbersNouns = 'pagh_wa_cha_wej_loS_vagh_jav_Soch_chorgh_Hut'.split('_');

            function translateFuture(output) {
                var time = output;
                time = (output.indexOf('jaj') !== -1) ?
                    time.slice(0, -3) + 'leS' :
                    (output.indexOf('jar') !== -1) ?
                        time.slice(0, -3) + 'waQ' :
                        (output.indexOf('DIS') !== -1) ?
                            time.slice(0, -3) + 'nem' :
                            time + ' pIq';
                return time;
            }

            function translatePast(output) {
                var time = output;
                time = (output.indexOf('jaj') !== -1) ?
                    time.slice(0, -3) + 'Hu' :
                    (output.indexOf('jar') !== -1) ?
                        time.slice(0, -3) + 'wen' :
                        (output.indexOf('DIS') !== -1) ?
                            time.slice(0, -3) + 'ben' :
                            time + ' ret';
                return time;
            }

            function translate(number, withoutSuffix, string, isFuture) {
                var numberNoun = numberAsNoun(number);
                switch (string) {
                    case 'mm':
                        return numberNoun + ' tup';
                    case 'hh':
                        return numberNoun + ' rep';
                    case 'dd':
                        return numberNoun + ' jaj';
                    case 'MM':
                        return numberNoun + ' jar';
                    case 'yy':
                        return numberNoun + ' DIS';
                }
            }

            function numberAsNoun(number) {
                var hundred = Math.floor((number % 1000) / 100),
                    ten = Math.floor((number % 100) / 10),
                    one = number % 10,
                    word = '';
                if (hundred > 0) {
                    word += numbersNouns[hundred] + 'vatlh';
                }
                if (ten > 0) {
                    word += ((word !== '') ? ' ' : '') + numbersNouns[ten] + 'maH';
                }
                if (one > 0) {
                    word += ((word !== '') ? ' ' : '') + numbersNouns[one];
                }
                return (word === '') ? 'pagh' : word;
            }

            var tlh = moment.defineLocale('tlh', {
                months: 'tera jar wa_tera jar cha_tera jar wej_tera jar loS_tera jar vagh_tera jar jav_tera jar Soch_tera jar chorgh_tera jar Hut_tera jar wamaH_tera jar wamaH wa_tera jar wamaH cha'.split('_'),
                monthsShort: 'jar wa_jar cha_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wamaH_jar wamaH wa_jar wamaH cha'.split('_'),
                monthsParseExact: true,
                weekdays: 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
                weekdaysShort: 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
                weekdaysMin: 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD.MM.YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY HH:mm',
                    LLLL: 'dddd, D MMMM YYYY HH:mm'
                },
                calendar: {
                    sameDay: '[DaHjaj] LT',
                    nextDay: '[waleS] LT',
                    nextWeek: 'LLL',
                    lastDay: '[waHu] LT',
                    lastWeek: 'LLL',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: translateFuture,
                    past: translatePast,
                    s: 'puS lup',
                    m: 'wa tup',
                    mm: translate,
                    h: 'wa rep',
                    hh: translate,
                    d: 'wa jaj',
                    dd: translate,
                    M: 'wa jar',
                    MM: translate,
                    y: 'wa DIS',
                    yy: translate
                },
                ordinalParse: /\d{1,2}\./,
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4  // The week that contains Jan 4th is the first week of the year.
                }
            });

            return tlh;

        })));


        /***/
    },
    /* 97 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Turkish [tr]
//! authors : Erhan Gundogan : https://github.com/erhangundogan,
//!           Burak Yiit Kaya: https://github.com/BYK

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var suffixes = {
                1: '\'inci',
                5: '\'inci',
                8: '\'inci',
                70: '\'inci',
                80: '\'inci',
                2: '\'nci',
                7: '\'nci',
                20: '\'nci',
                50: '\'nci',
                3: '\'nc',
                4: '\'nc',
                100: '\'nc',
                6: '\'nc',
                9: '\'uncu',
                10: '\'uncu',
                30: '\'uncu',
                60: '\'nc',
                90: '\'nc'
            };

            var tr = moment.defineLocale('tr', {
                months: 'Ocak_ubat_Mart_Nisan_Mays_Haziran_Temmuz_Austos_Eyll_Ekim_Kasm_Aralk'.split('_'),
                monthsShort: 'Oca_ub_Mar_Nis_May_Haz_Tem_Au_Eyl_Eki_Kas_Ara'.split('_'),
                weekdays: 'Pazar_Pazartesi_Sal_aramba_Perembe_Cuma_Cumartesi'.split('_'),
                weekdaysShort: 'Paz_Pts_Sal_ar_Per_Cum_Cts'.split('_'),
                weekdaysMin: 'Pz_Pt_Sa_a_Pe_Cu_Ct'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD.MM.YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY HH:mm',
                    LLLL: 'dddd, D MMMM YYYY HH:mm'
                },
                calendar: {
                    sameDay: '[bugn saat] LT',
                    nextDay: '[yarn saat] LT',
                    nextWeek: '[haftaya] dddd [saat] LT',
                    lastDay: '[dn] LT',
                    lastWeek: '[geen hafta] dddd [saat] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: '%s sonra',
                    past: '%s nce',
                    s: 'birka saniye',
                    m: 'bir dakika',
                    mm: '%d dakika',
                    h: 'bir saat',
                    hh: '%d saat',
                    d: 'bir gn',
                    dd: '%d gn',
                    M: 'bir ay',
                    MM: '%d ay',
                    y: 'bir yl',
                    yy: '%d yl'
                },
                ordinalParse: /\d{1,2}'(inci|nci|nc|nc|uncu|nc)/,
                ordinal: function (number) {
                    if (number === 0) {  // special case for zero
                        return number + '\'nc';
                    }
                    var a = number % 10,
                        b = number % 100 - a,
                        c = number >= 100 ? 100 : null;
                    return number + (suffixes[a] || suffixes[b] || suffixes[c]);
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7  // The week that contains Jan 1st is the first week of the year.
                }
            });

            return tr;

        })));


        /***/
    },
    /* 98 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Talossan [tzl]
//! author : Robin van der Vliet : https://github.com/robin0van0der0v
//! author : Iust Canun

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


// After the year there should be a slash and the amount of years since December 26, 1979 in Roman numerals.
// This is currently too difficult (maybe even impossible) to add.
            var tzl = moment.defineLocale('tzl', {
                months: 'Januar_Fevraglh_Mar_Avru_Mai_Gn_Julia_Guscht_Setemvar_Listopts_Noemvar_Zecemvar'.split('_'),
                monthsShort: 'Jan_Fev_Mar_Avr_Mai_Gn_Jul_Gus_Set_Lis_Noe_Zec'.split('_'),
                weekdays: 'Sladi_Lnei_Maitzi_Mrcuri_Xhadi_Vineri_Sturi'.split('_'),
                weekdaysShort: 'Sl_Ln_Mai_Mr_Xh_Vi_St'.split('_'),
                weekdaysMin: 'S_L_Ma_M_Xh_Vi_S'.split('_'),
                longDateFormat: {
                    LT: 'HH.mm',
                    LTS: 'HH.mm.ss',
                    L: 'DD.MM.YYYY',
                    LL: 'D. MMMM [dallas] YYYY',
                    LLL: 'D. MMMM [dallas] YYYY HH.mm',
                    LLLL: 'dddd, [li] D. MMMM [dallas] YYYY HH.mm'
                },
                meridiemParse: /d\'o|d\'a/i,
                isPM: function (input) {
                    return 'd\'o' === input.toLowerCase();
                },
                meridiem: function (hours, minutes, isLower) {
                    if (hours > 11) {
                        return isLower ? 'd\'o' : 'D\'O';
                    } else {
                        return isLower ? 'd\'a' : 'D\'A';
                    }
                },
                calendar: {
                    sameDay: '[oxhi ] LT',
                    nextDay: '[dem ] LT',
                    nextWeek: 'dddd [] LT',
                    lastDay: '[ieiri ] LT',
                    lastWeek: '[sr el] dddd [lasteu ] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'osprei %s',
                    past: 'ja%s',
                    s: processRelativeTime,
                    m: processRelativeTime,
                    mm: processRelativeTime,
                    h: processRelativeTime,
                    hh: processRelativeTime,
                    d: processRelativeTime,
                    dd: processRelativeTime,
                    M: processRelativeTime,
                    MM: processRelativeTime,
                    y: processRelativeTime,
                    yy: processRelativeTime
                },
                ordinalParse: /\d{1,2}\./,
                ordinal: '%d.',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4  // The week that contains Jan 4th is the first week of the year.
                }
            });

            function processRelativeTime(number, withoutSuffix, key, isFuture) {
                var format = {
                    's': ['viensas secunds', '\'iensas secunds'],
                    'm': ['\'n mut', '\'iens mut'],
                    'mm': [number + ' muts', '' + number + ' muts'],
                    'h': ['\'n ora', '\'iensa ora'],
                    'hh': [number + ' oras', '' + number + ' oras'],
                    'd': ['\'n ziua', '\'iensa ziua'],
                    'dd': [number + ' ziuas', '' + number + ' ziuas'],
                    'M': ['\'n mes', '\'iens mes'],
                    'MM': [number + ' mesen', '' + number + ' mesen'],
                    'y': ['\'n ar', '\'iens ar'],
                    'yy': [number + ' ars', '' + number + ' ars']
                };
                return isFuture ? format[key][0] : (withoutSuffix ? format[key][0] : format[key][1]);
            }

            return tzl;

        })));


        /***/
    },
    /* 99 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Central Atlas Tamazight Latin [tzm-latn]
//! author : Abdel Said : https://github.com/abdelsaid

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var tzmLatn = moment.defineLocale('tzm-latn', {
                months: 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),
                monthsShort: 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),
                weekdays: 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
                weekdaysShort: 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
                weekdaysMin: 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY HH:mm',
                    LLLL: 'dddd D MMMM YYYY HH:mm'
                },
                calendar: {
                    sameDay: '[asdkh g] LT',
                    nextDay: '[aska g] LT',
                    nextWeek: 'dddd [g] LT',
                    lastDay: '[assant g] LT',
                    lastWeek: 'dddd [g] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'dadkh s yan %s',
                    past: 'yan %s',
                    s: 'imik',
                    m: 'minu',
                    mm: '%d minu',
                    h: 'saa',
                    hh: '%d tassain',
                    d: 'ass',
                    dd: '%d ossan',
                    M: 'ayowr',
                    MM: '%d iyyirn',
                    y: 'asgas',
                    yy: '%d isgasn'
                },
                week: {
                    dow: 6, // Saturday is the first day of the week.
                    doy: 12  // The week that contains Jan 1st is the first week of the year.
                }
            });

            return tzmLatn;

        })));


        /***/
    },
    /* 100 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Central Atlas Tamazight [tzm]
//! author : Abdel Said : https://github.com/abdelsaid

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var tzm = moment.defineLocale('tzm', {
                months: '___________'.split('_'),
                monthsShort: '___________'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY HH:mm',
                    LLLL: 'dddd D MMMM YYYY HH:mm'
                },
                calendar: {
                    sameDay: '[ ] LT',
                    nextDay: '[ ] LT',
                    nextWeek: 'dddd [] LT',
                    lastDay: '[ ] LT',
                    lastWeek: 'dddd [] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: '   %s',
                    past: ' %s',
                    s: '',
                    m: '',
                    mm: '%d ',
                    h: '',
                    hh: '%d ',
                    d: '',
                    dd: '%d o',
                    M: 'o',
                    MM: '%d ',
                    y: '',
                    yy: '%d '
                },
                week: {
                    dow: 6, // Saturday is the first day of the week.
                    doy: 12  // The week that contains Jan 1st is the first week of the year.
                }
            });

            return tzm;

        })));


        /***/
    },
    /* 101 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Ukrainian [uk]
//! author : zemlanin : https://github.com/zemlanin
//! Author : Menelion Elensle : https://github.com/Oire

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            function plural(word, num) {
                var forms = word.split('_');
                return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
            }

            function relativeTimeWithPlural(number, withoutSuffix, key) {
                var format = {
                    'mm': withoutSuffix ? '__' : '__',
                    'hh': withoutSuffix ? '__' : '__',
                    'dd': '__',
                    'MM': '__',
                    'yy': '__'
                };
                if (key === 'm') {
                    return withoutSuffix ? '' : '';
                }
                else if (key === 'h') {
                    return withoutSuffix ? '' : '';
                }
                else {
                    return number + ' ' + plural(format[key], +number);
                }
            }

            function weekdaysCaseReplace(m, format) {
                var weekdays = {
                        'nominative': '______'.split('_'),
                        'accusative': '______'.split('_'),
                        'genitive': '______'.split('_')
                    },
                    nounCase = (/(\[[]\]) ?dddd/).test(format) ?
                        'accusative' :
                        ((/\[?(?:|)? ?\] ?dddd/).test(format) ?
                            'genitive' :
                            'nominative');
                return weekdays[nounCase][m.day()];
            }

            function processHoursFunction(str) {
                return function () {
                    return str + '' + (this.hours() === 11 ? '' : '') + '] LT';
                };
            }

            var uk = moment.defineLocale('uk', {
                months: {
                    'format': '___________'.split('_'),
                    'standalone': '___________'.split('_')
                },
                monthsShort: '___________'.split('_'),
                weekdays: weekdaysCaseReplace,
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD.MM.YYYY',
                    LL: 'D MMMM YYYY .',
                    LLL: 'D MMMM YYYY ., HH:mm',
                    LLLL: 'dddd, D MMMM YYYY ., HH:mm'
                },
                calendar: {
                    sameDay: processHoursFunction('[ '),
                    nextDay: processHoursFunction('[ '),
                    lastDay: processHoursFunction('[ '),
                    nextWeek: processHoursFunction('[] dddd ['),
                    lastWeek: function () {
                        switch (this.day()) {
                            case 0:
                            case 3:
                            case 5:
                            case 6:
                                return processHoursFunction('[] dddd [').call(this);
                            case 1:
                            case 2:
                            case 4:
                                return processHoursFunction('[] dddd [').call(this);
                        }
                    },
                    sameElse: 'L'
                },
                relativeTime: {
                    future: ' %s',
                    past: '%s ',
                    s: ' ',
                    m: relativeTimeWithPlural,
                    mm: relativeTimeWithPlural,
                    h: '',
                    hh: relativeTimeWithPlural,
                    d: '',
                    dd: relativeTimeWithPlural,
                    M: '',
                    MM: relativeTimeWithPlural,
                    y: '',
                    yy: relativeTimeWithPlural
                },
                // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
                meridiemParse: /|||/,
                isPM: function (input) {
                    return /^(|)$/.test(input);
                },
                meridiem: function (hour, minute, isLower) {
                    if (hour < 4) {
                        return '';
                    } else if (hour < 12) {
                        return '';
                    } else if (hour < 17) {
                        return '';
                    } else {
                        return '';
                    }
                },
                ordinalParse: /\d{1,2}-(|)/,
                ordinal: function (number, period) {
                    switch (period) {
                        case 'M':
                        case 'd':
                        case 'DDD':
                        case 'w':
                        case 'W':
                            return number + '-';
                        case 'D':
                            return number + '-';
                        default:
                            return number;
                    }
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7  // The week that contains Jan 1st is the first week of the year.
                }
            });

            return uk;

        })));


        /***/
    },
    /* 102 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Uzbek [uz]
//! author : Sardor Muminov : https://github.com/muminoff

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var uz = moment.defineLocale('uz', {
                months: '___________'.split('_'),
                monthsShort: '___________'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY HH:mm',
                    LLLL: 'D MMMM YYYY, dddd HH:mm'
                },
                calendar: {
                    sameDay: '[ ] LT []',
                    nextDay: '[] LT []',
                    nextWeek: 'dddd [ ] LT []',
                    lastDay: '[ ] LT []',
                    lastWeek: '[] dddd [ ] LT []',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: ' %s ',
                    past: '  %s ',
                    s: '',
                    m: ' ',
                    mm: '%d ',
                    h: ' ',
                    hh: '%d ',
                    d: ' ',
                    dd: '%d ',
                    M: ' ',
                    MM: '%d ',
                    y: ' ',
                    yy: '%d '
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 7  // The week that contains Jan 4th is the first week of the year.
                }
            });

            return uz;

        })));


        /***/
    },
    /* 103 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Vietnamese [vi]
//! author : Bang Nguyen : https://github.com/bangnk

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var vi = moment.defineLocale('vi', {
                months: 'thng 1_thng 2_thng 3_thng 4_thng 5_thng 6_thng 7_thng 8_thng 9_thng 10_thng 11_thng 12'.split('_'),
                monthsShort: 'Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12'.split('_'),
                monthsParseExact: true,
                weekdays: 'ch nht_th hai_th ba_th t_th nm_th su_th by'.split('_'),
                weekdaysShort: 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
                weekdaysMin: 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
                weekdaysParseExact: true,
                meridiemParse: /sa|ch/i,
                isPM: function (input) {
                    return /^ch$/i.test(input);
                },
                meridiem: function (hours, minutes, isLower) {
                    if (hours < 12) {
                        return isLower ? 'sa' : 'SA';
                    } else {
                        return isLower ? 'ch' : 'CH';
                    }
                },
                longDateFormat: {
                    LT: 'HH:mm',
                    LTS: 'HH:mm:ss',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM [nm] YYYY',
                    LLL: 'D MMMM [nm] YYYY HH:mm',
                    LLLL: 'dddd, D MMMM [nm] YYYY HH:mm',
                    l: 'DD/M/YYYY',
                    ll: 'D MMM YYYY',
                    lll: 'D MMM YYYY HH:mm',
                    llll: 'ddd, D MMM YYYY HH:mm'
                },
                calendar: {
                    sameDay: '[Hm nay lc] LT',
                    nextDay: '[Ngy mai lc] LT',
                    nextWeek: 'dddd [tun ti lc] LT',
                    lastDay: '[Hm qua lc] LT',
                    lastWeek: 'dddd [tun ri lc] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: '%s ti',
                    past: '%s trc',
                    s: 'vi giy',
                    m: 'mt pht',
                    mm: '%d pht',
                    h: 'mt gi',
                    hh: '%d gi',
                    d: 'mt ngy',
                    dd: '%d ngy',
                    M: 'mt thng',
                    MM: '%d thng',
                    y: 'mt nm',
                    yy: '%d nm'
                },
                ordinalParse: /\d{1,2}/,
                ordinal: function (number) {
                    return number;
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4  // The week that contains Jan 4th is the first week of the year.
                }
            });

            return vi;

        })));


        /***/
    },
    /* 104 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Pseudo [x-pseudo]
//! author : Andrew Hood : https://github.com/andrewhood125

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var xPseudo = moment.defineLocale('x-pseudo', {
                months: 'J~~r_F~br~r_~Mrc~h_p~rl_~M_~J~_Jl~_~gst~_Sp~tmb~r_~ctb~r_~vm~br_~Dc~mbr'.split('_'),
                monthsShort: 'J~_~Fb_~Mr_~pr_~M_~J_~Jl_~g_~Sp_~ct_~v_~Dc'.split('_'),
                monthsParseExact: true,
                weekdays: 'S~d~_M~d~_T~sd~_Wd~sd~_T~hrs~d_~Frd~_S~tr~d'.split('_'),
                weekdaysShort: 'S~_~M_~T_~Wd_~Th_~Fr_~St'.split('_'),
                weekdaysMin: 'S~_M~_T_~W_T~h_Fr~_S'.split('_'),
                weekdaysParseExact: true,
                longDateFormat: {
                    LT: 'HH:mm',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY HH:mm',
                    LLLL: 'dddd, D MMMM YYYY HH:mm'
                },
                calendar: {
                    sameDay: '[T~d~ t] LT',
                    nextDay: '[T~m~rr~w t] LT',
                    nextWeek: 'dddd [t] LT',
                    lastDay: '[~st~rd~ t] LT',
                    lastWeek: '[L~st] dddd [t] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: '~ %s',
                    past: '%s ~g',
                    s: ' ~fw ~sc~ds',
                    m: ' ~m~t',
                    mm: '%d m~~ts',
                    h: '~ h~r',
                    hh: '%d h~rs',
                    d: ' ~d',
                    dd: '%d d~s',
                    M: ' ~m~th',
                    MM: '%d m~t~hs',
                    y: ' ~r',
                    yy: '%d ~rs'
                },
                ordinalParse: /\d{1,2}(th|st|nd|rd)/,
                ordinal: function (number) {
                    var b = number % 10,
                        output = (~~(number % 100 / 10) === 1) ? 'th' :
                            (b === 1) ? 'st' :
                                (b === 2) ? 'nd' :
                                    (b === 3) ? 'rd' : 'th';
                    return number + output;
                },
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4  // The week that contains Jan 4th is the first week of the year.
                }
            });

            return xPseudo;

        })));


        /***/
    },
    /* 105 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Yoruba Nigeria [yo]
//! author : Atolagbe Abisoye : https://github.com/andela-batolagbe

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var yo = moment.defineLocale('yo', {
                months: 'Sr_Erele_rna_Igbe_Ebibi_Okudu_Agmo_Ogun_Owewe_wara_Belu_p'.split('_'),
                monthsShort: 'Sr_Erl_rn_Igb_Ebi_Oku_Ag_Ogu_Owe_wa_Bel_p'.split('_'),
                weekdays: 'Aiku_Aje_Isgun_jru_jb_ti_Abamta'.split('_'),
                weekdaysShort: 'Aik_Aje_Is_jr_jb_ti_Aba'.split('_'),
                weekdaysMin: 'Ai_Aj_Is_r_b_t_Ab'.split('_'),
                longDateFormat: {
                    LT: 'h:mm A',
                    LTS: 'h:mm:ss A',
                    L: 'DD/MM/YYYY',
                    LL: 'D MMMM YYYY',
                    LLL: 'D MMMM YYYY h:mm A',
                    LLLL: 'dddd, D MMMM YYYY h:mm A'
                },
                calendar: {
                    sameDay: '[Oni ni] LT',
                    nextDay: '[la ni] LT',
                    nextWeek: 'dddd [s ton\'b] [ni] LT',
                    lastDay: '[Ana ni] LT',
                    lastWeek: 'dddd [s tol] [ni] LT',
                    sameElse: 'L'
                },
                relativeTime: {
                    future: 'ni %s',
                    past: '%s kja',
                    s: 'isju aaya die',
                    m: 'isju kan',
                    mm: 'isju %d',
                    h: 'wakati kan',
                    hh: 'wakati %d',
                    d: 'j kan',
                    dd: 'j %d',
                    M: 'osu kan',
                    MM: 'osu %d',
                    y: 'dun kan',
                    yy: 'dun %d'
                },
                ordinalParse: /j\s\d{1,2}/,
                ordinal: 'j %d',
                week: {
                    dow: 1, // Monday is the first day of the week.
                    doy: 4 // The week that contains Jan 4th is the first week of the year.
                }
            });

            return yo;

        })));


        /***/
    },
    /* 106 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Chinese (China) [zh-cn]
//! author : suupic : https://github.com/suupic
//! author : Zeno Zeng : https://github.com/zenozeng

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var zhCn = moment.defineLocale('zh-cn', {
                months: '___________'.split('_'),
                monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'Ahmm',
                    LTS: 'Ahms',
                    L: 'YYYY-MM-DD',
                    LL: 'YYYYMMMD',
                    LLL: 'YYYYMMMDAhmm',
                    LLLL: 'YYYYMMMDddddAhmm',
                    l: 'YYYY-MM-DD',
                    ll: 'YYYYMMMD',
                    lll: 'YYYYMMMDAhmm',
                    llll: 'YYYYMMMDddddAhmm'
                },
                meridiemParse: /|||||/,
                meridiemHour: function (hour, meridiem) {
                    if (hour === 12) {
                        hour = 0;
                    }
                    if (meridiem === '' || meridiem === '' ||
                        meridiem === '') {
                        return hour;
                    } else if (meridiem === '' || meridiem === '') {
                        return hour + 12;
                    } else {
                        // ''
                        return hour >= 11 ? hour : hour + 12;
                    }
                },
                meridiem: function (hour, minute, isLower) {
                    var hm = hour * 100 + minute;
                    if (hm < 600) {
                        return '';
                    } else if (hm < 900) {
                        return '';
                    } else if (hm < 1130) {
                        return '';
                    } else if (hm < 1230) {
                        return '';
                    } else if (hm < 1800) {
                        return '';
                    } else {
                        return '';
                    }
                },
                calendar: {
                    sameDay: function () {
                        return this.minutes() === 0 ? '[]Ah[]' : '[]LT';
                    },
                    nextDay: function () {
                        return this.minutes() === 0 ? '[]Ah[]' : '[]LT';
                    },
                    lastDay: function () {
                        return this.minutes() === 0 ? '[]Ah[]' : '[]LT';
                    },
                    nextWeek: function () {
                        var startOfWeek, prefix;
                        startOfWeek = moment().startOf('week');
                        prefix = this.diff(startOfWeek, 'days') >= 7 ? '[]' : '[]';
                        return this.minutes() === 0 ? prefix + 'dddAh' : prefix + 'dddAhmm';
                    },
                    lastWeek: function () {
                        var startOfWeek, prefix;
                        startOfWeek = moment().startOf('week');
                        prefix = this.unix() < startOfWeek.unix() ? '[]' : '[]';
                        return this.minutes() === 0 ? prefix + 'dddAh' : prefix + 'dddAhmm';
                    },
                    sameElse: 'LL'
                },
                ordinalParse: /\d{1,2}(||)/,
                ordinal: function (number, period) {
                    switch (period) {
                        case 'd':
                        case 'D':
                        case 'DDD':
                            return number + '';
                        case 'M':
                            return number + '';
                        case 'w':
                        case 'W':
                            return number + '';
                        default:
                            return number;
                    }
                },
                relativeTime: {
                    future: '%s',
                    past: '%s',
                    s: '',
                    m: '1 ',
                    mm: '%d ',
                    h: '1 ',
                    hh: '%d ',
                    d: '1 ',
                    dd: '%d ',
                    M: '1 ',
                    MM: '%d ',
                    y: '1 ',
                    yy: '%d '
                },
                week: {
                    // GB/T 7408-1994ISO 8601:1988
                    dow: 1, // Monday is the first day of the week.
                    doy: 4  // The week that contains Jan 4th is the first week of the year.
                }
            });

            return zhCn;

        })));


        /***/
    },
    /* 107 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Chinese (Hong Kong) [zh-hk]
//! author : Ben : https://github.com/ben-lin
//! author : Chris Lam : https://github.com/hehachris
//! author : Konstantin : https://github.com/skfd

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var zhHk = moment.defineLocale('zh-hk', {
                months: '___________'.split('_'),
                monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'Ahmm',
                    LTS: 'Ahms',
                    L: 'YYYYMMMD',
                    LL: 'YYYYMMMD',
                    LLL: 'YYYYMMMDAhmm',
                    LLLL: 'YYYYMMMDddddAhmm',
                    l: 'YYYYMMMD',
                    ll: 'YYYYMMMD',
                    lll: 'YYYYMMMDAhmm',
                    llll: 'YYYYMMMDddddAhmm'
                },
                meridiemParse: /|||||/,
                meridiemHour: function (hour, meridiem) {
                    if (hour === 12) {
                        hour = 0;
                    }
                    if (meridiem === '' || meridiem === '' || meridiem === '') {
                        return hour;
                    } else if (meridiem === '') {
                        return hour >= 11 ? hour : hour + 12;
                    } else if (meridiem === '' || meridiem === '') {
                        return hour + 12;
                    }
                },
                meridiem: function (hour, minute, isLower) {
                    var hm = hour * 100 + minute;
                    if (hm < 600) {
                        return '';
                    } else if (hm < 900) {
                        return '';
                    } else if (hm < 1130) {
                        return '';
                    } else if (hm < 1230) {
                        return '';
                    } else if (hm < 1800) {
                        return '';
                    } else {
                        return '';
                    }
                },
                calendar: {
                    sameDay: '[]LT',
                    nextDay: '[]LT',
                    nextWeek: '[]ddddLT',
                    lastDay: '[]LT',
                    lastWeek: '[]ddddLT',
                    sameElse: 'L'
                },
                ordinalParse: /\d{1,2}(||)/,
                ordinal: function (number, period) {
                    switch (period) {
                        case 'd' :
                        case 'D' :
                        case 'DDD' :
                            return number + '';
                        case 'M' :
                            return number + '';
                        case 'w' :
                        case 'W' :
                            return number + '';
                        default :
                            return number;
                    }
                },
                relativeTime: {
                    future: '%s',
                    past: '%s',
                    s: '',
                    m: '1 ',
                    mm: '%d ',
                    h: '1 ',
                    hh: '%d ',
                    d: '1 ',
                    dd: '%d ',
                    M: '1 ',
                    MM: '%d ',
                    y: '1 ',
                    yy: '%d '
                }
            });

            return zhHk;

        })));


        /***/
    },
    /* 108 */
    /***/ function (module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Chinese (Taiwan) [zh-tw]
//! author : Ben : https://github.com/ben-lin
//! author : Chris Lam : https://github.com/hehachris

        ;(function (global, factory) {
            true ? factory(__webpack_require__(0)) :
                typeof define === 'function' && define.amd ? define(['../moment'], factory) :
                    factory(global.moment)
        }(this, (function (moment) {
            'use strict';


            var zhTw = moment.defineLocale('zh-tw', {
                months: '___________'.split('_'),
                monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
                weekdays: '______'.split('_'),
                weekdaysShort: '______'.split('_'),
                weekdaysMin: '______'.split('_'),
                longDateFormat: {
                    LT: 'Ahmm',
                    LTS: 'Ahms',
                    L: 'YYYYMMMD',
                    LL: 'YYYYMMMD',
                    LLL: 'YYYYMMMDAhmm',
                    LLLL: 'YYYYMMMDddddAhmm',
                    l: 'YYYYMMMD',
                    ll: 'YYYYMMMD',
                    lll: 'YYYYMMMDAhmm',
                    llll: 'YYYYMMMDddddAhmm'
                },
                meridiemParse: /|||||/,
                meridiemHour: function (hour, meridiem) {
                    if (hour === 12) {
                        hour = 0;
                    }
                    if (meridiem === '' || meridiem === '' || meridiem === '') {
                        return hour;
                    } else if (meridiem === '') {
                        return hour >= 11 ? hour : hour + 12;
                    } else if (meridiem === '' || meridiem === '') {
                        return hour + 12;
                    }
                },
                meridiem: function (hour, minute, isLower) {
                    var hm = hour * 100 + minute;
                    if (hm < 600) {
                        return '';
                    } else if (hm < 900) {
                        return '';
                    } else if (hm < 1130) {
                        return '';
                    } else if (hm < 1230) {
                        return '';
                    } else if (hm < 1800) {
                        return '';
                    } else {
                        return '';
                    }
                },
                calendar: {
                    sameDay: '[]LT',
                    nextDay: '[]LT',
                    nextWeek: '[]ddddLT',
                    lastDay: '[]LT',
                    lastWeek: '[]ddddLT',
                    sameElse: 'L'
                },
                ordinalParse: /\d{1,2}(||)/,
                ordinal: function (number, period) {
                    switch (period) {
                        case 'd' :
                        case 'D' :
                        case 'DDD' :
                            return number + '';
                        case 'M' :
                            return number + '';
                        case 'w' :
                        case 'W' :
                            return number + '';
                        default :
                            return number;
                    }
                },
                relativeTime: {
                    future: '%s',
                    past: '%s',
                    s: '',
                    m: '1 ',
                    mm: '%d ',
                    h: '1 ',
                    hh: '%d ',
                    d: '1 ',
                    dd: '%d ',
                    M: '1 ',
                    MM: '%d ',
                    y: '1 ',
                    yy: '%d '
                }
            });

            return zhTw;

        })));


        /***/
    },
    /* 109 */
    /***/ function (module, exports) {

        var g;

// This works in non-strict mode
        g = (function () {
            return this;
        })();

        try {
            // This works if eval is allowed (see CSP)
            g = g || Function("return this")() || (1, eval)("this");
        } catch (e) {
            // This works if the window reference is available
            if (typeof window === "object")
                g = window;
        }

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

        module.exports = g;


        /***/
    },
    /* 110 */
    /***/ function (module, exports, __webpack_require__) {

        "use strict";
        'use strict';

        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.WorkflowApp = undefined;

        var _vue = __webpack_require__(116);

        var _vue2 = _interopRequireDefault(_vue);

        var _vueResource = __webpack_require__(115);

        var _vueResource2 = _interopRequireDefault(_vueResource);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {default: obj};
        }

        var moment = __webpack_require__(0);

        _vue2.default.use(_vueResource2.default);

        _vue2.default.http.headers.common['X-CSRFTOKEN'] = getCookie('csrftoken');

        var WorkflowApp = _vue2.default.extend({
            delimiters: ["@{", "}"]
        });

        WorkflowApp.filter('humanReadableDate', function (value) {
            return moment(value).format("DD MMM YYYY");
        });

        WorkflowApp.filter('humanReadableTime', function (value) {
            return moment(value).format("hh:mm A");
        });

        WorkflowApp.filter('humanReadableDateTime', function (value) {
            return moment(value).format("DD MMM YYYY hh:mm A");
        });

        exports.WorkflowApp = WorkflowApp;

        /***/
    },
    /* 111 */
    /***/ function (module, exports, __webpack_require__) {

        (function (global, factory) {
            true ? module.exports = factory() :
                typeof define === 'function' && define.amd ? define(factory) :
                    (global.VeeValidate = factory());
        }(this, (function () {
            'use strict';

            var alpha = function (value) {
                return /^[a-zA-Z]*$/.test(value);
            };

            var alpha_dash = function (value) {
                return /^[a-zA-Z0-9_-]*$/.test(value);
            };

            var alpha_num = function (value) {
                return /^[a-zA-Z0-9]*$/.test(value);
            };

            var alpha_spaces = function (value) {
                return /^[a-zA-Z\s]*$/.test(value);
            };

            var between = function (value, ref) {
                var min = ref[0];
                var max = ref[1];

                return Number(min) <= value && Number(max) >= value;
            };

            var confirmed = function (value, ref, validatingField) {
                var confirmedField = ref[0];

                var field = confirmedField
                    ? document.querySelector(("input[name='" + confirmedField + "']"))
                    : document.querySelector(("input[name='" + validatingField + "_confirmation']"));

                return !!(field && String(value) === field.value);
            };

            function unwrapExports(x) {
                return x && x.__esModule ? x['default'] : x;
            }

            function createCommonjsModule(fn, module) {
                return module = {exports: {}}, fn(module, module.exports), module.exports;
            }

            var assertString_1 = createCommonjsModule(function (module, exports) {
                'use strict';

                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                exports.default = assertString;

                function assertString(input) {
                    if (typeof input !== 'string') {
                        throw new TypeError('This library (validator.js) validates strings only');
                    }
                }

                module.exports = exports['default'];
            });

            var isCreditCard_1 = createCommonjsModule(function (module, exports) {
                'use strict';

                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                exports.default = isCreditCard;

                var _assertString = assertString_1;

                var _assertString2 = _interopRequireDefault(_assertString);

                function _interopRequireDefault(obj) {
                    return obj && obj.__esModule ? obj : {default: obj};
                }

                /* eslint-disable max-len */
                var creditCard = /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11})|62[0-9]{14}$/;

                /* eslint-enable max-len */

                function isCreditCard(str) {
                    (0, _assertString2.default)(str);
                    var sanitized = str.replace(/[^0-9]+/g, '');
                    if (!creditCard.test(sanitized)) {
                        return false;
                    }
                    var sum = 0;
                    var digit = void 0;
                    var tmpNum = void 0;
                    var shouldDouble = void 0;
                    for (var i = sanitized.length - 1; i >= 0; i--) {
                        digit = sanitized.substring(i, i + 1);
                        tmpNum = parseInt(digit, 10);
                        if (shouldDouble) {
                            tmpNum *= 2;
                            if (tmpNum >= 10) {
                                sum += tmpNum % 10 + 1;
                            } else {
                                sum += tmpNum;
                            }
                        } else {
                            sum += tmpNum;
                        }
                        shouldDouble = !shouldDouble;
                    }
                    return !!(sum % 10 === 0 ? sanitized : false);
                }

                module.exports = exports['default'];
            });

            var isCreditCard = unwrapExports(isCreditCard_1);

            var credit_card = function (value) {
                return isCreditCard(String(value));
            };

            var decimal = function (value, params) {
                var decimals = Array.isArray(params) ? (params[0] || '*') : '*';
                if (Array.isArray(value)) {
                    return false;
                }

                if (value === null || value === undefined || value === '') {
                    return true;
                }

                // if is 0.
                if (Number(decimals) === 0) {
                    return /^-?\d*$/.test(value);
                }

                var regexPart = decimals === '*' ? '+' : ("{1," + decimals + "}");
                var regex = new RegExp(("^-?\\d*(\\.\\d" + regexPart + ")?$"));

                if (!regex.test(value)) {
                    return false;
                }

                var parsedValue = parseFloat(value);

                // eslint-disable-next-line
                return parsedValue === parsedValue;
            };

            var digits = function (value, ref) {
                var length = ref[0];

                var strVal = String(value);

                return /^[0-9]*$/.test(strVal) && strVal.length === Number(length);
            };

            var validateImage = function (file, width, height) {
                var URL = window.URL || window.webkitURL;
                return new Promise(function (resolve) {
                    var image = new Image();
                    image.onerror = function () {
                        return resolve({valid: false});
                    };
                    image.onload = function () {
                        return resolve({
                            valid: image.width === Number(width) && image.height === Number(height)
                        });
                    };

                    image.src = URL.createObjectURL(file);
                });
            };

            var dimensions = function (files, ref) {
                var width = ref[0];
                var height = ref[1];

                var list = [];
                for (var i = 0; i < files.length; i++) {
                    // if file is not an image, reject.
                    if (!/\.(jpg|svg|jpeg|png|bmp|gif)$/i.test(files[i].name)) {
                        return false;
                    }

                    list.push(files[i]);
                }

                return Promise.all(list.map(function (file) {
                    return validateImage(file, width, height);
                }));
            };

            var merge_1 = createCommonjsModule(function (module, exports) {
                'use strict';

                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                exports.default = merge;

                function merge() {
                    var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
                    var defaults = arguments[1];

                    for (var key in defaults) {
                        if (typeof obj[key] === 'undefined') {
                            obj[key] = defaults[key];
                        }
                    }
                    return obj;
                }

                module.exports = exports['default'];
            });

            var isByteLength_1 = createCommonjsModule(function (module, exports) {
                'use strict';

                Object.defineProperty(exports, "__esModule", {
                    value: true
                });

                var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
                    return typeof obj;
                } : function (obj) {
                    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                };

                exports.default = isByteLength;

                var _assertString = assertString_1;

                var _assertString2 = _interopRequireDefault(_assertString);

                function _interopRequireDefault(obj) {
                    return obj && obj.__esModule ? obj : {default: obj};
                }

                /* eslint-disable prefer-rest-params */
                function isByteLength(str, options) {
                    (0, _assertString2.default)(str);
                    var min = void 0;
                    var max = void 0;
                    if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
                        min = options.min || 0;
                        max = options.max;
                    } else {
                        // backwards compatibility: isByteLength(str, min [, max])
                        min = arguments[1];
                        max = arguments[2];
                    }
                    var len = encodeURI(str).split(/%..|./).length - 1;
                    return len >= min && (typeof max === 'undefined' || len <= max);
                }

                module.exports = exports['default'];
            });

            var isFQDN = createCommonjsModule(function (module, exports) {
                'use strict';

                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                exports.default = isFDQN;

                var _assertString = assertString_1;

                var _assertString2 = _interopRequireDefault(_assertString);

                var _merge = merge_1;

                var _merge2 = _interopRequireDefault(_merge);

                function _interopRequireDefault(obj) {
                    return obj && obj.__esModule ? obj : {default: obj};
                }

                var default_fqdn_options = {
                    require_tld: true,
                    allow_underscores: false,
                    allow_trailing_dot: false
                };

                function isFDQN(str, options) {
                    (0, _assertString2.default)(str);
                    options = (0, _merge2.default)(options, default_fqdn_options);

                    /* Remove the optional trailing dot before checking validity */
                    if (options.allow_trailing_dot && str[str.length - 1] === '.') {
                        str = str.substring(0, str.length - 1);
                    }
                    var parts = str.split('.');
                    if (options.require_tld) {
                        var tld = parts.pop();
                        if (!parts.length || !/^([a-z\u00a1-\uffff]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {
                            return false;
                        }
                    }
                    for (var part, i = 0; i < parts.length; i++) {
                        part = parts[i];
                        if (options.allow_underscores) {
                            part = part.replace(/_/g, '');
                        }
                        if (!/^[a-z\u00a1-\uffff0-9-]+$/i.test(part)) {
                            return false;
                        }
                        if (/[\uff01-\uff5e]/.test(part)) {
                            // disallow full-width chars
                            return false;
                        }
                        if (part[0] === '-' || part[part.length - 1] === '-') {
                            return false;
                        }
                    }
                    return true;
                }

                module.exports = exports['default'];
            });

            var isEmail_1 = createCommonjsModule(function (module, exports) {
                'use strict';

                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                exports.default = isEmail;

                var _assertString = assertString_1;

                var _assertString2 = _interopRequireDefault(_assertString);

                var _merge = merge_1;

                var _merge2 = _interopRequireDefault(_merge);

                var _isByteLength = isByteLength_1;

                var _isByteLength2 = _interopRequireDefault(_isByteLength);

                var _isFQDN = isFQDN;

                var _isFQDN2 = _interopRequireDefault(_isFQDN);

                function _interopRequireDefault(obj) {
                    return obj && obj.__esModule ? obj : {default: obj};
                }

                var default_email_options = {
                    allow_display_name: false,
                    allow_utf8_local_part: true,
                    require_tld: true
                };

                /* eslint-disable max-len */
                /* eslint-disable no-control-regex */
                var displayName = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\.\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\.\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF\s]*<(.+)>$/i;
                var emailUserPart = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~]+$/i;
                var quotedEmailUser = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f]))*$/i;
                var emailUserUtf8Part = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/i;
                var quotedEmailUserUtf8 = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*$/i;
                /* eslint-enable max-len */

                /* eslint-enable no-control-regex */

                function isEmail(str, options) {
                    (0, _assertString2.default)(str);
                    options = (0, _merge2.default)(options, default_email_options);

                    if (options.allow_display_name) {
                        var display_email = str.match(displayName);
                        if (display_email) {
                            str = display_email[1];
                        }
                    }

                    var parts = str.split('@');
                    var domain = parts.pop();
                    var user = parts.join('@');

                    var lower_domain = domain.toLowerCase();
                    if (lower_domain === 'gmail.com' || lower_domain === 'googlemail.com') {
                        user = user.replace(/\./g, '').toLowerCase();
                    }

                    if (!(0, _isByteLength2.default)(user, {max: 64}) || !(0, _isByteLength2.default)(domain, {max: 256})) {
                        return false;
                    }

                    if (!(0, _isFQDN2.default)(domain, {require_tld: options.require_tld})) {
                        return false;
                    }

                    if (user[0] === '"') {
                        user = user.slice(1, user.length - 1);
                        return options.allow_utf8_local_part ? quotedEmailUserUtf8.test(user) : quotedEmailUser.test(user);
                    }

                    var pattern = options.allow_utf8_local_part ? emailUserUtf8Part : emailUserPart;

                    var user_parts = user.split('.');
                    for (var i = 0; i < user_parts.length; i++) {
                        if (!pattern.test(user_parts[i])) {
                            return false;
                        }
                    }

                    return true;
                }

                module.exports = exports['default'];
            });

            var isEmail = unwrapExports(isEmail_1);

            var email = function (value) {
                return isEmail(String(value));
            };

            var ext = function (files, extensions) {
                var regex = new RegExp((".(" + (extensions.join('|')) + ")$"), 'i');

                return files.every(function (file) {
                    return regex.test(file.name);
                });
            };

            var image = function (files) {
                return files.every(function (file) {
                        return /\.(jpg|svg|jpeg|png|bmp|gif)$/i.test(file.name);
                    }
                );
            };

            var In = function (value, options) {
                return !!options.filter(function (option) {
                    return option == value;
                }).length;
            }; // eslint-disable-line

            var isIP_1 = createCommonjsModule(function (module, exports) {
                'use strict';

                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                exports.default = isIP;

                var _assertString = assertString_1;

                var _assertString2 = _interopRequireDefault(_assertString);

                function _interopRequireDefault(obj) {
                    return obj && obj.__esModule ? obj : {default: obj};
                }

                var ipv4Maybe = /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/;
                var ipv6Block = /^[0-9A-F]{1,4}$/i;

                function isIP(str) {
                    var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

                    (0, _assertString2.default)(str);
                    version = String(version);
                    if (!version) {
                        return isIP(str, 4) || isIP(str, 6);
                    } else if (version === '4') {
                        if (!ipv4Maybe.test(str)) {
                            return false;
                        }
                        var parts = str.split('.').sort(function (a, b) {
                            return a - b;
                        });
                        return parts[3] <= 255;
                    } else if (version === '6') {
                        var blocks = str.split(':');
                        var foundOmissionBlock = false; // marker to indicate ::

                        // At least some OS accept the last 32 bits of an IPv6 address
                        // (i.e. 2 of the blocks) in IPv4 notation, and RFC 3493 says
                        // that '::ffff:a.b.c.d' is valid for IPv4-mapped IPv6 addresses,
                        // and '::a.b.c.d' is deprecated, but also valid.
                        var foundIPv4TransitionBlock = isIP(blocks[blocks.length - 1], 4);
                        var expectedNumberOfBlocks = foundIPv4TransitionBlock ? 7 : 8;

                        if (blocks.length > expectedNumberOfBlocks) {
                            return false;
                        }
                        // initial or final ::
                        if (str === '::') {
                            return true;
                        } else if (str.substr(0, 2) === '::') {
                            blocks.shift();
                            blocks.shift();
                            foundOmissionBlock = true;
                        } else if (str.substr(str.length - 2) === '::') {
                            blocks.pop();
                            blocks.pop();
                            foundOmissionBlock = true;
                        }

                        for (var i = 0; i < blocks.length; ++i) {
                            // test for a :: which can not be at the string start/end
                            // since those cases have been handled above
                            if (blocks[i] === '' && i > 0 && i < blocks.length - 1) {
                                if (foundOmissionBlock) {
                                    return false; // multiple :: in address
                                }
                                foundOmissionBlock = true;
                            } else if (foundIPv4TransitionBlock && i === blocks.length - 1) {
                                // it has been checked before that the last
                                // block is a valid IPv4 address
                            } else if (!ipv6Block.test(blocks[i])) {
                                return false;
                            }
                        }
                        if (foundOmissionBlock) {
                            return blocks.length >= 1;
                        }
                        return blocks.length === expectedNumberOfBlocks;
                    }
                    return false;
                }

                module.exports = exports['default'];
            });

            var isIP = unwrapExports(isIP_1);

            var ip = function (value, ref) {
                if (ref === void 0) ref = [4];
                var version = ref[0];

                return isIP(value, version);
            };

            var max = function (value, ref) {
                var length = ref[0];

                if (value === undefined || value === null) {
                    return length >= 0;
                }

                return String(value).length <= length;
            };

            var max_value = function (value, ref) {
                var max = ref[0];

                if (Array.isArray(value) || value === null || value === undefined || value === '') {
                    return false;
                }

                return Number(value) <= max;
            };

            var mimes = function (files, mimes) {
                var regex = new RegExp(((mimes.join('|').replace('*', '.+')) + "$"), 'i');

                return files.every(function (file) {
                    return regex.test(file.type);
                });
            };

            var min = function (value, ref) {
                var length = ref[0];

                if (value === undefined || value === null) {
                    return false;
                }
                return String(value).length >= length;
            };

            var min_value = function (value, ref) {
                var min = ref[0];

                if (Array.isArray(value) || value === null || value === undefined || value === '') {
                    return false;
                }

                return Number(value) >= min;
            };

            var not_in = function (value, options) {
                return !options.filter(function (option) {
                    return option == value;
                }).length;
            }; // eslint-disable-line

            var isNumeric_1 = createCommonjsModule(function (module, exports) {
                'use strict';

                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                exports.default = isNumeric;

                var _assertString = assertString_1;

                var _assertString2 = _interopRequireDefault(_assertString);

                function _interopRequireDefault(obj) {
                    return obj && obj.__esModule ? obj : {default: obj};
                }

                var numeric = /^[-+]?[0-9]+$/;

                function isNumeric(str) {
                    (0, _assertString2.default)(str);
                    return numeric.test(str);
                }

                module.exports = exports['default'];
            });

            var isNumeric = unwrapExports(isNumeric_1);

            var numeric = function (value) {
                return isNumeric(String(value));
            };

            var regex = function (value, ref) {
                var regex = ref[0];
                var flags = ref.slice(1);

                if (regex instanceof RegExp) {
                    return regex.test(value);
                }

                return new RegExp(regex, flags).test(String(value));
            };

            var required = function (value) {
                if (Array.isArray(value)) {
                    return !!value.length;
                }

                if (value === undefined || value === null) {
                    return false;
                }

                return !!String(value).trim().length;
            };

            var size = function (files, ref) {
                var size = ref[0];

                if (isNaN(size)) {
                    return false;
                }

                var nSize = Number(size) * 1024;
                for (var i = 0; i < files.length; i++) {
                    if (files[i].size > nSize) {
                        return false;
                    }
                }

                return true;
            };

            var isURL_1 = createCommonjsModule(function (module, exports) {
                'use strict';

                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                exports.default = isURL;

                var _assertString = assertString_1;

                var _assertString2 = _interopRequireDefault(_assertString);

                var _isFQDN = isFQDN;

                var _isFQDN2 = _interopRequireDefault(_isFQDN);

                var _isIP = isIP_1;

                var _isIP2 = _interopRequireDefault(_isIP);

                var _merge = merge_1;

                var _merge2 = _interopRequireDefault(_merge);

                function _interopRequireDefault(obj) {
                    return obj && obj.__esModule ? obj : {default: obj};
                }

                var default_url_options = {
                    protocols: ['http', 'https', 'ftp'],
                    require_tld: true,
                    require_protocol: false,
                    require_host: true,
                    require_valid_protocol: true,
                    allow_underscores: false,
                    allow_trailing_dot: false,
                    allow_protocol_relative_urls: false
                };

                var wrapped_ipv6 = /^\[([^\]]+)\](?::([0-9]+))?$/;

                function isRegExp(obj) {
                    return Object.prototype.toString.call(obj) === '[object RegExp]';
                }

                function checkHost(host, matches) {
                    for (var i = 0; i < matches.length; i++) {
                        var match = matches[i];
                        if (host === match || isRegExp(match) && match.test(host)) {
                            return true;
                        }
                    }
                    return false;
                }

                function isURL(url, options) {
                    (0, _assertString2.default)(url);
                    if (!url || url.length >= 2083 || /\s/.test(url)) {
                        return false;
                    }
                    if (url.indexOf('mailto:') === 0) {
                        return false;
                    }
                    options = (0, _merge2.default)(options, default_url_options);
                    var protocol = void 0,
                        auth = void 0,
                        host = void 0,
                        hostname = void 0,
                        port = void 0,
                        port_str = void 0,
                        split = void 0,
                        ipv6 = void 0;

                    split = url.split('#');
                    url = split.shift();

                    split = url.split('?');
                    url = split.shift();

                    split = url.split('://');
                    if (split.length > 1) {
                        protocol = split.shift();
                        if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {
                            return false;
                        }
                    } else if (options.require_protocol) {
                        return false;
                    } else if (options.allow_protocol_relative_urls && url.substr(0, 2) === '//') {
                        split[0] = url.substr(2);
                    }
                    url = split.join('://');

                    split = url.split('/');
                    url = split.shift();

                    if (url === '' && !options.require_host) {
                        return true;
                    }

                    split = url.split('@');
                    if (split.length > 1) {
                        auth = split.shift();
                        if (auth.indexOf(':') >= 0 && auth.split(':').length > 2) {
                            return false;
                        }
                    }
                    hostname = split.join('@');

                    port_str = ipv6 = null;
                    var ipv6_match = hostname.match(wrapped_ipv6);
                    if (ipv6_match) {
                        host = '';
                        ipv6 = ipv6_match[1];
                        port_str = ipv6_match[2] || null;
                    } else {
                        split = hostname.split(':');
                        host = split.shift();
                        if (split.length) {
                            port_str = split.join(':');
                        }
                    }

                    if (port_str !== null) {
                        port = parseInt(port_str, 10);
                        if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {
                            return false;
                        }
                    }

                    if (!(0, _isIP2.default)(host) && !(0, _isFQDN2.default)(host, options) && (!ipv6 || !(0, _isIP2.default)(ipv6, 6)) && host !== 'localhost') {
                        return false;
                    }

                    host = host || ipv6;

                    if (options.host_whitelist && !checkHost(host, options.host_whitelist)) {
                        return false;
                    }
                    if (options.host_blacklist && checkHost(host, options.host_blacklist)) {
                        return false;
                    }

                    return true;
                }

                module.exports = exports['default'];
            });

            var isURL = unwrapExports(isURL_1);

            var url = function (value, ref) {
                if (ref === void 0) ref = [true];
                var requireProtocol = ref[0];

                return isURL(value, {require_protocol: !!requireProtocol});
            };

            /* eslint-disable camelcase */
            var Rules = {
                alpha_dash: alpha_dash,
                alpha_num: alpha_num,
                alpha_spaces: alpha_spaces,
                alpha: alpha,
                between: between,
                confirmed: confirmed,
                credit_card: credit_card,
                decimal: decimal,
                digits: digits,
                dimensions: dimensions,
                email: email,
                ext: ext,
                image: image,
                in: In,
                ip: ip,
                max: max,
                max_value: max_value,
                mimes: mimes,
                min: min,
                min_value: min_value,
                not_in: not_in,
                numeric: numeric,
                regex: regex,
                required: required,
                size: size,
                url: url
            };

            var ErrorBag = function ErrorBag() {
                this.errors = [];
            };

            /**
             * Adds an error to the internal array.
             *
             * @param {string} field The field name.
             * @param {string} msg The error message.
             * @param {String} rule The rule that is responsible for the error.
             * @param {String} scope The Scope name, optional.
             */
            ErrorBag.prototype.add = function add(field, msg, rule, scope) {
                if (scope === void 0) scope = '__global__';

                this.errors.push({field: field, msg: msg, rule: rule, scope: scope});
            };

            /**
             * Gets all error messages from the internal array.
             *
             * @param {String} scope The Scope name, optional.
             * @return {Array} errors Array of all error messages.
             */
            ErrorBag.prototype.all = function all(scope) {
                if (!scope) {
                    scope = '__global__';
                }

                return this.errors.filter(function (e) {
                    return e.scope === scope;
                }).map(function (e) {
                    return e.msg;
                });
            };

            /**
             * Checks if there are any errors in the internal array.
             * @param {String} scope The Scope name, optional.
             * @return {boolean} result True if there was at least one error, false otherwise.
             */
            ErrorBag.prototype.any = function any(scope) {
                if (!scope) {
                    scope = '__global__';
                }

                return !!this.errors.filter(function (e) {
                    return e.scope === scope;
                }).length;
            };

            /**
             * Removes all items from the internal array.
             *
             * @param {String} scope The Scope name, optional.
             */
            ErrorBag.prototype.clear = function clear(scope) {
                if (!scope) {
                    scope = '__global__';
                }

                this.errors = this.errors.filter(function (e) {
                    return e.scope !== scope;
                });
            };

            /**
             * Collects errors into groups or for a specific field.
             *
             * @param{string} field The field name.
             * @param{string} scope The scope name.
             * @param {Boolean} map If it should map the errors to strings instead of objects.
             * @return {Array} errors The errors for the specified field.
             */
            ErrorBag.prototype.collect = function collect(field, scope, map) {
                if (map === void 0) map = true;

                if (!field) {
                    var collection = {};
                    this.errors.forEach(function (e) {
                        if (!collection[e.field]) {
                            collection[e.field] = [];
                        }

                        collection[e.field].push(map ? e.msg : e);
                    });

                    return collection;
                }

                if (scope) {
                    return this.errors.filter(function (e) {
                        return e.field === field && e.scope === scope;
                    })
                        .map(function (e) {
                            return (map ? e.msg : e);
                        });
                }

                return this.errors.filter(function (e) {
                    return e.field === field && e.scope === '__global__';
                })
                    .map(function (e) {
                        return (map ? e.msg : e);
                    });
            };
            /**
             * Gets the internal array length.
             *
             * @return {Number} length The internal array length.
             */
            ErrorBag.prototype.count = function count() {
                return this.errors.length;
            };

            /**
             * Gets the first error message for a specific field.
             *
             * @param{string} field The field name.
             * @return {string|null} message The error message.
             */
            ErrorBag.prototype.first = function first(field, scope) {
                var this$1 = this;
                if (scope === void 0) scope = '__global__';

                var selector = this._selector(field);
                var scoped = this._scope(field);

                if (scoped) {
                    return this.first(scoped.name, scoped.scope);
                }

                if (selector) {
                    return this.firstByRule(selector.name, selector.rule, scope);
                }

                for (var i = 0; i < this.errors.length; i++) {
                    if (this$1.errors[i].field === field && (this$1.errors[i].scope === scope)) {
                        return this$1.errors[i].msg;
                    }
                }

                return null;
            };

            /**
             * Returns the first error rule for the specified field
             *
             * @param {string} field The specified field.
             * @return {string|null} First error rule on the specified field if one is found, otherwise null
             */
            ErrorBag.prototype.firstRule = function firstRule(field, scope) {
                var errors = this.collect(field, scope, false);

                return (errors.length && errors[0].rule) || null;
            };

            /**
             * Checks if the internal array has at least one error for the specified field.
             *
             * @param{string} field The specified field.
             * @return {Boolean} result True if at least one error is found, false otherwise.
             */
            ErrorBag.prototype.has = function has(field, scope) {
                if (scope === void 0) scope = '__global__';

                return !!this.first(field, scope);
            };

            /**
             * Gets the first error message for a specific field and a rule.
             * @param {String} name The name of the field.
             * @param {String} rule The name of the rule.
             * @param {String} scope The name of the scope (optional).
             */
            ErrorBag.prototype.firstByRule = function firstByRule(name, rule, scope) {
                var error = this.collect(name, scope, false).filter(function (e) {
                    return e.rule === rule;
                })[0];

                return (error && error.msg) || null;
            };

            /**
             * Removes all error messages associated with a specific field.
             *
             * @param{string} field The field which messages are to be removed.
             * @param {String} scope The Scope name, optional.
             */
            ErrorBag.prototype.remove = function remove(field, scope) {
                if (scope) {
                    this.errors = this.errors.filter(function (e) {
                        return e.field !== field || e.scope !== scope;
                    });

                    return;
                }

                this.errors = this.errors.filter(function (e) {
                    return e.field !== field && e.scope === '__global__';
                });
            };


            /**
             * Get the field attributes if there's a rule selector.
             *
             * @param{string} field The specified field.
             * @return {Object|null}
             */
            ErrorBag.prototype._selector = function _selector(field) {
                if (field.indexOf(':') > -1) {
                    var ref = field.split(':');
                    var name = ref[0];
                    var rule = ref[1];

                    return {name: name, rule: rule};
                }

                return null;
            };

            /**
             * Get the field scope if specified using dot notation.
             *
             * @param {string} field the specifie field.
             * @return {Object|null}
             */
            ErrorBag.prototype._scope = function _scope(field) {
                if (field.indexOf('.') > -1) {
                    var ref = field.split('.');
                    var scope = ref[0];
                    var name = ref[1];

                    return {name: name, scope: scope};
                }

                return null;
            };

            var ValidatorException = (function () {
                function anonymous(msg) {
                    this.msg = "[vee-validate]: " + msg;
                }

                anonymous.prototype.toString = function toString() {
                    return this.msg;
                };

                return anonymous;
            }());

            /**
             * Gets the data attribute. the name must be kebab-case.
             */
            var getDataAttribute = function (el, name) {
                return el.getAttribute(("data-vv-" + name));
            };

            /**
             * Determines the input field scope.
             */
            var getScope = function (el) {
                var scope = getDataAttribute(el, 'scope');
                if (!scope && el.form) {
                    scope = getDataAttribute(el.form, 'scope');
                }

                return scope;
            };

            /**
             * Debounces a function.
             */
            var debounce = function (callback, wait, immediate) {
                if (wait === void 0) wait = 0;

                var timeout;
                return function () {
                    var args = [], len = arguments.length;
                    while (len--) args[len] = arguments[len];

                    var later = function () {
                        timeout = null;
                        if (!immediate) {
                            callback.apply(void 0, args);
                        }
                    };
                    var callNow = immediate && !timeout;
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                    if (callNow) {
                        callback(args);
                    }
                };
            };

            /**
             * Emits a warning to the console.
             */
            var warn = function (message) {
                if (!console) {
                    return;
                }

                console.warn(("[vee-validate]: " + message)); // eslint-disable-line
            };

            /**
             * Checks if the value is an object.
             */
                // eslint-disable-next-line
            var isObject = function (object) {
                    return object !== null && object && typeof object === 'object' && !Array.isArray(object);
                };

            /**
             * Checks if a function is callable.
             */
            var isCallable = function (func) {
                return typeof func === 'function';
            };

            /**
             * Check if element has the css class on it.
             */
            var hasClass = function (el, className) {
                if (el.classList) {
                    return el.classList.contains(className);
                }

                return !!el.className.match(new RegExp(("(\\s|^)" + className + "(\\s|$)")));
            };

            /**
             * Adds the provided css className to the element.
             */
            var addClass = function (el, className) {
                if (el.classList) {
                    el.classList.add(className);
                } else if (!hasClass(el, className)) {
                    el.className += " " + className;
                }
            };

            /**
             * Remove the provided css className from the element.
             */
            var removeClass = function (el, className) {
                if (el.classList) {
                    el.classList.remove(className);
                } else if (hasClass(el, className)) {
                    var reg = new RegExp(("(\\s|^)" + className + "(\\s|$)"));
                    el.className = el.className.replace(reg, ' ');
                }
            };

            /**
             * Converts an array-like object to array.
             * Simple polyfill for Array.from
             */
            var toArray = function (arrayLike) {
                if (Array.from) {
                    return Array.from(arrayLike);
                }

                var array = [];
                var length = arrayLike.length;
                for (var i = 0; i < length; i++) {
                    array.push(arrayLike[i]);
                }

                return array;
            };

            /**
             * Assign polyfill from the mdn.
             */
            var assign = function (target) {
                var others = [], len = arguments.length - 1;
                while (len-- > 0) others[len] = arguments[len + 1];

                if (Object.assign) {
                    return Object.assign.apply(Object, [target].concat(others));
                }

                if (target == null) { // TypeError if undefined or null
                    throw new TypeError('Cannot convert undefined or null to object');
                }

                var to = Object(target);
                others.forEach(function (arg) {
                    if (arg != null) { // Skip over if undefined or null
                        Object.keys(arg).forEach(function (key) {
                            to[key] = arg[key];
                        });
                    }
                });

                return to;
            };

            /* eslint-disable prefer-rest-params */
            var Dictionary = function Dictionary(dictionary) {
                if (dictionary === void 0) dictionary = {};

                this.dictionary = {};
                this.merge(dictionary);
            };

            Dictionary.prototype.hasLocale = function hasLocale(locale) {
                return !!this.dictionary[locale];
            };

            Dictionary.prototype.getMessage = function getMessage(locale, key, fallback) {
                if (fallback === void 0) fallback = '';

                if (!this.hasMessage(locale, key)) {
                    return fallback;
                }

                return this.dictionary[locale].messages[key];
            };

            Dictionary.prototype.getAttribute = function getAttribute(locale, key, fallback) {
                if (fallback === void 0) fallback = '';

                if (!this.hasAttribute(locale, key)) {
                    return fallback;
                }

                return this.dictionary[locale].attributes[key];
            };

            Dictionary.prototype.hasMessage = function hasMessage(locale, key) {
                return !!(
                    this.hasLocale(locale) &&
                    this.dictionary[locale].messages &&
                    this.dictionary[locale].messages[key]
                );
            };

            Dictionary.prototype.hasAttribute = function hasAttribute(locale, key) {
                return !!(
                    this.hasLocale(locale) &&
                    this.dictionary[locale].attributes &&
                    this.dictionary[locale].attributes[key]
                );
            };

            Dictionary.prototype.merge = function merge(dictionary) {
                this._merge(this.dictionary, dictionary);
            };

            Dictionary.prototype.setMessage = function setMessage(locale, key, message) {
                if (!this.hasLocale(locale)) {
                    this.dictionary[locale] = {
                        messages: {},
                        attributes: {}
                    };
                }

                this.dictionary[locale].messages[key] = message;
            };

            Dictionary.prototype.setAttribute = function setAttribute(locale, key, attribute) {
                if (!this.hasLocale(locale)) {
                    this.dictionary[locale] = {
                        messages: {},
                        attributes: {}
                    };
                }

                this.dictionary[locale].attributes[key] = attribute;
            };

            Dictionary.prototype._merge = function _merge(target, source) {
                var this$1 = this;

                if (!(isObject(target) && isObject(source))) {
                    return target;
                }

                Object.keys(source).forEach(function (key) {
                    if (isObject(source[key])) {
                        if (!target[key]) {
                            assign(target, ( obj = {}, obj[key] = {}, obj ));
                            var obj;
                        }

                        this$1._merge(target[key], source[key]);
                        return;
                    }

                    assign(target, ( obj$1 = {}, obj$1[key] = source[key], obj$1 ));
                    var obj$1;
                });

                return target;
            };

            /* istanbul ignore next */
            /* eslint-disable max-len */
            var messages = {
                alpha_dash: function (field) {
                    return ("The " + field + " field may contain alpha-numeric characters as well as dashes and underscores.");
                },
                alpha_num: function (field) {
                    return ("The " + field + " field may only contain alpha-numeric characters.");
                },
                alpha_spaces: function (field) {
                    return ("The " + field + " field may only contain alphabetic characters as well as spaces.");
                },
                alpha: function (field) {
                    return ("The " + field + " field may only contain alphabetic characters.");
                },
                between: function (field, ref) {
                    var min = ref[0];
                    var max = ref[1];

                    return ("The " + field + " field must be between " + min + " and " + max + ".");
                },
                confirmed: function (field) {
                    return ("The " + field + " confirmation does not match.");
                },
                credit_card: function (field) {
                    return ("The " + field + " field is invalid.");
                },
                decimal: function (field, ref) {
                    if (ref === void 0) ref = ['*'];
                    var decimals = ref[0];

                    return ("The " + field + " field must be numeric and may contain " + (decimals === '*' ? '' : decimals) + " decimal points.");
                },
                digits: function (field, ref) {
                    var length = ref[0];

                    return ("The " + field + " field must be numeric and exactly contain " + length + " digits.");
                },
                dimensions: function (field, ref) {
                    var width = ref[0];
                    var height = ref[1];

                    return ("The " + field + " field must be " + width + " pixels by " + height + " pixels.");
                },
                email: function (field) {
                    return ("The " + field + " field must be a valid email.");
                },
                ext: function (field) {
                    return ("The " + field + " field must be a valid file.");
                },
                image: function (field) {
                    return ("The " + field + " field must be an image.");
                },
                in: function (field) {
                    return ("The " + field + " field must be a valid value.");
                },
                ip: function (field) {
                    return ("The " + field + " field must be a valid ip address.");
                },
                max: function (field, ref) {
                    var length = ref[0];

                    return ("The " + field + " field may not be greater than " + length + " characters.");
                },
                max_value: function (field, ref) {
                    var max = ref[0];

                    return ("The " + field + " field must be " + max + " or less.");
                },
                mimes: function (field) {
                    return ("The " + field + " field must have a valid file type.");
                },
                min: function (field, ref) {
                    var length = ref[0];

                    return ("The " + field + " field must be at least " + length + " characters.");
                },
                min_value: function (field, ref) {
                    var min = ref[0];

                    return ("The " + field + " field must be " + min + " or more.");
                },
                not_in: function (field) {
                    return ("The " + field + " field must be a valid value.");
                },
                numeric: function (field) {
                    return ("The " + field + " field may only contain numeric characters.");
                },
                regex: function (field) {
                    return ("The " + field + " field format is invalid.");
                },
                required: function (field) {
                    return ("The " + field + " field is required.");
                },
                size: function (field, ref) {
                    var size = ref[0];

                    return ("The " + field + " field must be less than " + size + " KB.");
                },
                url: function (field) {
                    return ("The " + field + " field is not a valid URL.");
                }
            };

            var after = function (moment) {
                return function (value, ref) {
                    var targetField = ref[0];
                    var format = ref[1];

                    var dateValue = moment(value, format, true);
                    var field = document.querySelector(("input[name='" + targetField + "']"));

                    if (!(dateValue.isValid() && field)) {
                        return false;
                    }

                    var other = moment(field.value, format, true);

                    if (!other.isValid()) {
                        return false;
                    }

                    return dateValue.isAfter(other);
                };
            };

            var before = function (moment) {
                return function (value, ref) {
                    var targetField = ref[0];
                    var format = ref[1];

                    var dateValue = moment(value, format, true);
                    var field = document.querySelector(("input[name='" + targetField + "']"));

                    if (!dateValue.isValid() || !field) {
                        return false;
                    }

                    var other = moment(field.value, format, true);

                    if (!other.isValid()) {
                        return false;
                    }

                    return dateValue.isBefore(other);
                };
            };

            var date_format = function (moment) {
                return function (value, ref) {
                    var format = ref[0];

                    return moment(value, format, true).isValid();
                }
            };

            var date_between = function (moment) {
                return function (value, ref) {
                    var min = ref[0];
                    var max = ref[1];
                    var format = ref[2];

                    var minDate = moment(min, format, true);
                    var maxDate = moment(max, format, true);
                    var dateVal = moment(value, format, true);

                    if (!(minDate.isValid() && maxDate.isValid() && dateVal.isValid())) {
                        return false;
                    }

                    return dateVal.isBetween(minDate, maxDate);
                };
            };

            /* istanbul ignore next */
            /* eslint-disable max-len */
            var messages$1 = {
                after: function (field, ref) {
                    var target = ref[0];

                    return ("The " + field + " must be after " + target + ".");
                },
                before: function (field, ref) {
                    var target = ref[0];

                    return ("The " + field + " must be before " + target + ".");
                },
                date_between: function (field, ref) {
                    var min = ref[0];
                    var max = ref[1];

                    return ("The " + field + " must be between " + min + " and " + max + ".");
                },
                date_format: function (field, ref) {
                    var format = ref[0];

                    return ("The " + field + " must be in the format " + format + ".");
                }
            };

            var date = {
                make: function (moment) {
                    return ({
                        date_format: date_format(moment),
                        after: after(moment),
                        before: before(moment),
                        date_between: date_between(moment)
                    });
                },
                messages: messages$1,
                installed: false
            };

            var FieldBag = function FieldBag() {
                this.fields = {};
            };

            /**
             * Initializes and adds a new field to the bag.
             */
            FieldBag.prototype._add = function _add(name) {
                this.fields[name] = {};
                this._setFlags(name, {dirty: false, valid: false,}, true);
            };

            /**
             * Remooves a field from the bag.
             */
            FieldBag.prototype._remove = function _remove(name) {
                delete this.fields[name];
            };

            /**
             * Resets the flags state for a specified field or all fields.
             */
            FieldBag.prototype.reset = function reset(name) {
                var this$1 = this;

                if (!name) {
                    Object.keys(this.fields).forEach(function (field) {
                        this$1._setFlags(field, {dirty: false, valid: false,}, true);
                    });

                    return;
                }

                this._setFlags(name, {dirty: false, valid: false,}, true);
            };

            /**
             * Sets the flags for a specified field.
             */
            FieldBag.prototype._setFlags = function _setFlags(name, flags, initial) {
                var this$1 = this;
                if (initial === void 0) initial = false;

                return Object.keys(flags).every(
                    function (flag) {
                        return this$1._setFlag(name, flag, flags[flag], initial);
                    }
                );
            };

            /**
             * Sets a flag for a specified field.
             */
            FieldBag.prototype._setFlag = function _setFlag(name, flag, value, initial) {
                if (initial === void 0) initial = false;

                var method = "set" + (flag.charAt(0).toUpperCase()) + (flag.slice(1));
                if (typeof this[method] !== 'function') {
                    return false;
                }

                this[method](name, value, initial);

                return true;
            };

            /**
             * Sets the dirty flag along with dependant flags.
             */
            FieldBag.prototype.setDirty = function setDirty(name, value, initial) {
                if (initial === void 0) initial = false;

                this.fields[name].dirty = value;
                this.fields[name].clean = initial || !value;
                this.fields[name].passed = this.fields[name].valid && value;
                this.fields[name].failed = !this.fields[name].valid && value;
            };

            /**
             * Sets the valid flag along with dependant flags.
             */
            FieldBag.prototype.setValid = function setValid(name, value) {
                this.fields[name].valid = value;
                this.fields[name].passed = this.fields[name].dirty && value;
                this.fields[name].failed = this.fields[name].dirty && !value;
            };

            /**
             * Gets a field flag value.
             */
            FieldBag.prototype._getFieldFlag = function _getFieldFlag(name, flag) {
                if (this.fields[name]) {
                    return this.fields[name][flag];
                }

                return false;
            };

            FieldBag.prototype.dirty = function dirty(name) {
                var this$1 = this;

                if (!name) {
                    return Object.keys(this.fields).some(function (field) {
                        return this$1.fields[field].dirty;
                    });
                }

                return this._getFieldFlag(name, 'dirty');
            };

            FieldBag.prototype.valid = function valid(name) {
                var this$1 = this;

                if (!name) {
                    return Object.keys(this.fields).every(function (field) {
                        return this$1.fields[field].valid;
                    });
                }

                return this._getFieldFlag(name, 'valid');
            };

            FieldBag.prototype.passed = function passed(name) {
                var this$1 = this;

                if (!name) {
                    return Object.keys(this.fields).every(function (field) {
                        return this$1.fields[field].passed;
                    });
                }

                return this._getFieldFlag(name, 'passed');
            };

            FieldBag.prototype.failed = function failed(name) {
                var this$1 = this;

                if (!name) {
                    return Object.keys(this.fields).some(function (field) {
                        return this$1.fields[field].failed;
                    });
                }

                return this._getFieldFlag(name, 'failed');
            };

            FieldBag.prototype.clean = function clean(name) {
                if (!name) {
                    return !this.dirty();
                }

                return this._getFieldFlag(name, 'clean');
            };

            var LOCALE = 'en';
            var STRICT_MODE = true;
            var dictionary = new Dictionary({
                en: {
                    messages: messages,
                    attributes: {}
                }
            });

            var Validator = function Validator(validations, $vm, options) {
                if (options === void 0) options = {init: true};

                this.strictMode = STRICT_MODE;
                this.$scopes = {__global__: {}};
                this.fieldBag = new FieldBag();
                this._createFields(validations);
                this.errorBag = new ErrorBag();
                this.$vm = $vm;
                // Some fields will be later evaluated, because the vm isn't mounted yet
                // so it may register it under an inaccurate scope.
                this.$deferred = [];
                this.$ready = false;

                // if momentjs is present, install the validators.
                if (typeof moment === 'function') {
                    // eslint-disable-next-line
                    this.installDateTimeValidators(moment);
                }

                if (options.init) {
                    this.init();
                }
            };

            /**
             * Merges a validator object into the Rules and Messages.
             *
             * @param{string} name The name of the validator.
             * @param{function|object} validator The validator object.
             */
            Validator._merge = function _merge(name, validator) {
                if (isCallable(validator)) {
                    Rules[name] = validator;
                    dictionary.setMessage('en', name, function (field) {
                        return ("The " + field + " value is not valid.");
                    });
                    return;
                }

                Rules[name] = validator.validate;

                if (validator.getMessage && isCallable(validator.getMessage)) {
                    dictionary.setMessage('en', name, validator.getMessage);
                }

                if (validator.messages) {
                    dictionary.merge(
                        Object.keys(validator.messages).reduce(function (prev, curr) {
                            var dict = prev;
                            dict[curr] = {
                                messages: ( obj = {}, obj[name] = validator.messages[curr], obj )
                            };
                            var obj;

                            return dict;
                        }, {})
                    );
                }
            };

            /**
             * Guards from extnsion violations.
             *
             * @param{string} name name of the validation rule.
             * @param{object} validator a validation rule object.
             */
            Validator._guardExtend = function _guardExtend(name, validator) {
                if (Rules[name]) {
                    throw new ValidatorException(
                        ("Extension Error: There is an existing validator with the same name '" + name + "'.")
                    );
                }

                if (isCallable(validator)) {
                    return;
                }

                if (!isCallable(validator.validate)) {
                    throw new ValidatorException(
                        // eslint-disable-next-line
                        ("Extension Error: The validator '" + name + "' must be a function or have a 'validate' method.")
                    );
                }

                if (!isCallable(validator.getMessage) && !isObject(validator.messages)) {
                    throw new ValidatorException(
                        // eslint-disable-next-line
                        ("Extension Error: The validator '" + name + "' must have a 'getMessage' method or have a 'messages' object.")
                    );
                }
            };

            /**
             * Static constructor.
             *
             * @param{object} validations The validations object.
             * @return {Validator} validator A validator object.
             */
            Validator.create = function create(validations, $vm, options) {
                return new Validator(validations, $vm, options);
            };

            /**
             * Adds a custom validator to the list of validation rules.
             *
             * @param{string} name The name of the validator.
             * @param{object|function} validator The validator object/function.
             */
            Validator.extend = function extend(name, validator) {
                Validator._guardExtend(name, validator);
                Validator._merge(name, validator);
            };

            /**
             * Installs the datetime validators and the messages.
             */
            Validator.installDateTimeValidators = function installDateTimeValidators(moment) {
                if (typeof moment !== 'function') {
                    warn('To use the date-time validators you must provide moment reference.');

                    return false;
                }

                if (date.installed) {
                    return true;
                }

                var validators = date.make(moment);
                Object.keys(validators).forEach(function (name) {
                    Validator.extend(name, validators[name]);
                });

                Validator.updateDictionary({
                    en: {
                        messages: date.messages
                    }
                });
                date.installed = true;

                return true;
            };

            /**
             * Removes a rule from the list of validators.
             * @param {String} name The name of the validator/rule.
             */
            Validator.remove = function remove(name) {
                delete Rules[name];
            };

            /**
             * Sets the default locale for all validators.
             *
             * @param {String} language The locale id.
             */
            Validator.setLocale = function setLocale(language) {
                if (language === void 0) language = 'en';

                /* istanbul ignore if */
                if (!dictionary.hasLocale(language)) {
                    // eslint-disable-next-line
                    warn('You are setting the validator locale to a locale that is not defined in the dicitionary. English messages may still be generated.');
                }

                LOCALE = language;
            };

            /**
             * Sets the operating mode for all newly created validators.
             * strictMode = true: Values without a rule are invalid and cause failure.
             * strictMode = false: Values without a rule are valid and are skipped.
             * @param {Boolean} strictMode.
             */
            Validator.setStrictMode = function setStrictMode(strictMode) {
                if (strictMode === void 0) strictMode = true;

                STRICT_MODE = strictMode;
            };

            /**
             * Updates the dicitionary, overwriting existing values and adding new ones.
             *
             * @param{object} data The dictionary object.
             */
            Validator.updateDictionary = function updateDictionary(data) {
                dictionary.merge(data);
            };

            /**
             * Resolves the scope value. Only strings and functions are allowed.
             * @param {Function|String} scope
             * @returns {String}
             */
            Validator.prototype._resolveScope = function _resolveScope(scope) {
                if (typeof scope === 'string') {
                    return scope;
                }

                // The resolved value should be string.
                if (isCallable(scope)) {
                    var value = scope();
                    return typeof value === 'string' ? value : '__global__';
                }

                return '__global__';
            };

            /**
             * Resolves the field values from the getter functions.
             */
            Validator.prototype._resolveValuesFromGetters = function _resolveValuesFromGetters(scope) {
                var this$1 = this;
                if (scope === void 0) scope = '__global__';

                if (!this.$scopes[scope]) {
                    return {};
                }
                var values = {};
                Object.keys(this.$scopes[scope]).forEach(function (name) {
                    var field = this$1.$scopes[scope][name];
                    var getter = field.getter;
                    var context = field.context;
                    var fieldScope = this$1._resolveScope(field.scope);
                    if (getter && context && (scope === '__global__' || fieldScope === scope)) {
                        values[name] = {
                            value: getter(context()),
                            scope: fieldScope
                        };
                    }
                });

                return values;
            };

            /**
             * Creates the fields to be validated.
             *
             * @param{object} validations
             * @return {object} Normalized object.
             */
            Validator.prototype._createFields = function _createFields(validations) {
                var this$1 = this;

                if (!validations) {
                    return;
                }

                Object.keys(validations).forEach(function (field) {
                    this$1._createField(field, validations[field]);
                });
            };

            /**
             * Creates a field entry in the fields object.
             * @param {String} name.
             * @param {String|Array} checks.
             */
            Validator.prototype._createField = function _createField(name, checks, scope) {
                if (scope === void 0) scope = '__global__';

                scope = this._resolveScope(scope);
                if (!this.$scopes[scope]) {
                    this.$scopes[scope] = {};
                }

                if (!this.$scopes[scope][name]) {
                    this.$scopes[scope][name] = {};
                }

                var field = this.$scopes[scope][name];
                this.fieldBag._add(name);
                field.validations = this._normalizeRules(name, checks, scope);
                field.required = this._isRequired(field);
            };

            /**
             * Normalizes rules.
             * @return {Object}
             */
            Validator.prototype._normalizeRules = function _normalizeRules(name, checks, scope) {
                if (!checks) {
                    return {};
                }

                if (typeof checks === 'string') {
                    return this._normalizeString(checks);
                }

                if (!isObject(checks)) {
                    warn(("Your checks for '" + scope + "." + name + "' must be either a string or an object."));
                    return {};
                }

                return this._normalizeObject(checks);
            };

            /**
             * Checks if a field has a required rule.
             */
            Validator.prototype._isRequired = function _isRequired(field) {
                return field.validations && field.validations.required;
            };

            /**
             * Normalizes an object of rules.
             */
            Validator.prototype._normalizeObject = function _normalizeObject(rules) {
                var this$1 = this;

                var validations = {};
                Object.keys(rules).forEach(function (rule) {
                    var params = [];
                    if (rules[rule] === true) {
                        params = [];
                    } else if (Array.isArray(rules[rule])) {
                        params = rules[rule];
                    } else {
                        params = [rules[rule]];
                    }

                    if (rules[rule] === false) {
                        delete validations[rule];
                    } else {
                        validations[rule] = params;
                    }

                    if (date.installed && this$1._isADateRule(rule)) {
                        validations[rule].push(this$1._getDateFormat(validations));
                    }
                });

                return validations;
            };

            /**
             * Date rules need the existance of a format, so date_format must be supplied.
             * @param {String} name The rule name.
             * @param {Array} validations the field validations.
             */
            Validator.prototype._getDateFormat = function _getDateFormat(validations) {
                if (validations.date_format && Array.isArray(validations.date_format)) {
                    return validations.date_format[0];
                }

                return null;
            };

            /**
             * Checks if the passed rule is a date rule.
             */
            Validator.prototype._isADateRule = function _isADateRule(rule) {
                return !!~['after', 'before', 'date_between'].indexOf(rule);
            };

            /**
             * Normalizes string rules.
             * @param {String} rules The rules that will be normalized.
             * @param {Object} field The field object that is being operated on.
             */
            Validator.prototype._normalizeString = function _normalizeString(rules) {
                var this$1 = this;

                var validations = {};
                rules.split('|').forEach(function (rule) {
                    var parsedRule = this$1._parseRule(rule);
                    if (!parsedRule.name) {
                        return;
                    }

                    if (parsedRule.name === 'required') {
                        validations.required = true;
                    }

                    validations[parsedRule.name] = parsedRule.params;
                    if (date.installed && this$1._isADateRule(parsedRule.name)) {
                        validations[parsedRule.name].push(this$1._getDateFormat(validations));
                    }
                });

                return validations;
            };

            /**
             * Normalizes a string rule.
             *
             * @param {string} rule The rule to be normalized.
             * @return {object} rule The normalized rule.
             */
            Validator.prototype._parseRule = function _parseRule(rule) {
                var params = [];
                var name = rule.split(':')[0];

                if (~rule.indexOf(':')) {
                    params = rule.split(':').slice(1).join(':').split(',');
                }

                return {name: name, params: params};
            };

            /**
             * Formats an error message for field and a rule.
             *
             * @param{string} field The field name.
             * @param{object} rule Normalized rule object.
             * @param {object} data Additional Information about the validation result.
             * @param {string} scope The field scope.
             * @return {string} msg Formatted error message.
             */
            Validator.prototype._formatErrorMessage = function _formatErrorMessage(field, rule, data, scope) {
                if (data === void 0) data = {};
                if (scope === void 0) scope = '__global__';

                var name = this._getFieldDisplayName(field, scope);
                var params = this._getLocalizedParams(rule);

                if (!dictionary.hasLocale(LOCALE) ||
                    typeof dictionary.getMessage(LOCALE, rule.name) !== 'function') {
                    // Default to english message.
                    return dictionary.getMessage('en', rule.name)(name, params, data);
                }

                return dictionary.getMessage(LOCALE, rule.name)(name, params, data);
            };

            /**
             * Translates the parameters passed to the rule (mainly for target fields).
             */
            Validator.prototype._getLocalizedParams = function _getLocalizedParams(rule) {
                if (~['after', 'before', 'confirmed'].indexOf(rule.name) &&
                    rule.params && rule.params[0]) {
                    return [dictionary.getAttribute(LOCALE, rule.params[0], rule.params[0])];
                }

                return rule.params;
            };

            /**
             * Resolves an appropiate display name, first checking 'data-as' or the registered 'prettyName'
             * Then the dictionary, then fallsback to field name.
             * @return {String} displayName The name to be used in the errors.
             */
            Validator.prototype._getFieldDisplayName = function _getFieldDisplayName(field, scope) {
                if (scope === void 0) scope = '__global__';

                return this.$scopes[scope][field].name || dictionary.getAttribute(LOCALE, field, field);
            };

            /**
             * Tests a single input value against a rule.
             *
             * @param{*} name The name of the field.
             * @param{*} valuethe value of the field.
             * @param{object} rule the rule object.
             * @param {scope} scope The field scope.
             * @return {boolean} Whether it passes the check.
             */
            Validator.prototype._test = function _test(name, value, rule, scope) {
                var this$1 = this;
                if (scope === void 0) scope = '__global__';

                var validator = Rules[rule.name];
                if (!validator || typeof validator !== 'function') {
                    throw new ValidatorException(("No such validator '" + (rule.name) + "' exists."));
                }

                var result = validator(value, rule.params, name);

                // If it is a promise.
                if (isCallable(result.then)) {
                    return result.then(function (values) {
                        var allValid = true;
                        var data = {};
                        if (Array.isArray(values)) {
                            allValid = values.every(function (t) {
                                return t.valid;
                            });
                        } else { // Is a single object.
                            allValid = values.valid;
                            data = values.data;
                        }

                        if (!allValid) {
                            this$1.errorBag.add(
                                name,
                                this$1._formatErrorMessage(name, rule, data, scope),
                                rule.name,
                                scope
                            );
                        }

                        return allValid;
                    });
                }

                if (!isObject(result)) {
                    result = {valid: result, data: {}};
                }

                if (!result.valid) {
                    this.errorBag.add(
                        name,
                        this._formatErrorMessage(name, rule, result.data, scope),
                        rule.name,
                        scope
                    );
                }

                return result.valid;
            };

            /**
             * Registers a field to be validated.
             *
             * @param{string} name The field name.
             * @param{String|Array|Object} checks validations expression.
             * @param {string} prettyName Custom name to be used as field name in error messages.
             * @param {Function} getter A function used to retrive a fresh value for the field.
             */
            Validator.prototype.attach = function attach(name, checks, options) {
                var this$1 = this;
                if (options === void 0) options = {};

                var attach = function () {
                    options.scope = this$1._resolveScope(options.scope);
                    this$1.updateField(name, checks, options);
                    var field = this$1.$scopes[options.scope][name];
                    field.scope = options.scope;
                    field.name = options.prettyName;
                    field.getter = options.getter;
                    field.context = options.context;
                    field.listeners = options.listeners || {
                        detach: function detach() {
                        }
                    };
                };

                var scope = isCallable(options.scope) ? options.scope() : options.scope;
                if (!scope && !this.$ready) {
                    this.$deferred.push(attach);
                    return;
                }


                attach();
            };

            /**
             * Initializes the non-scoped fields and any bootstrap logic.
             */
            Validator.prototype.init = function init() {
                this.$ready = true;
                this.$deferred.forEach(function (attach) {
                    attach();
                });
                this.$deferred = [];

                return this;
            };

            /**
             * Append another validation to an existing field.
             *
             * @param{string} name The field name.
             * @param{string} checks validations expression.
             */
            Validator.prototype.append = function append(name, checks, options) {
                if (options === void 0) options = {};

                options.scope = this._resolveScope(options.scope);
                // No such field
                if (!this.$scopes[options.scope] || !this.$scopes[options.scope][name]) {
                    this.attach(name, checks, options);
                }

                var field = this.$scopes[options.scope][name];
                var newChecks = this._normalizeRules(name, checks, options.scope);
                Object.keys(newChecks).forEach(function (key) {
                    field.validations[key] = newChecks[key];
                });
            };

            /**
             * Updates the field rules with new ones.
             */
            Validator.prototype.updateField = function updateField(name, checks, options) {
                if (options === void 0) options = {};

                var field = (this.$scopes[options.scope] && this.$scopes[options.scope][name]) || null;
                var oldChecks = field ? JSON.stringify(field.validations) : '';
                this._createField(name, checks, options.scope);
                field = (this.$scopes[options.scope] && this.$scopes[options.scope][name]) || null;
                var newChecks = field ? JSON.stringify(field.validations) : '';

                // compare both newChecks and oldChecks to make sure we don't trigger uneccessary directive
                // update by changing the errorBag (prevents infinite loops).
                if (newChecks !== oldChecks) {
                    this.errorBag.remove(name, options.scope);
                }
            };

            /**
             * Removes a field from the validator.
             *
             * @param{String} name The name of the field.
             * @param {String} scope The name of the field scope.
             */
            Validator.prototype.detach = function detach(name, scope) {
                if (scope === void 0) scope = '__global__';

                // No such field.
                if (!this.$scopes[scope] || !this.$scopes[scope][name]) {
                    return;
                }


                this.$scopes[scope][name].listeners.detach();
                this.errorBag.remove(name, scope);
                this.fieldBag._remove(name);
                delete this.$scopes[scope][name];
            };

            /**
             * Adds a custom validator to the list of validation rules.
             *
             * @param{string} name The name of the validator.
             * @param{object|function} validator The validator object/function.
             */
            Validator.prototype.extend = function extend(name, validator) {
                Validator.extend(name, validator);
            };

            /**
             * Gets the internal errorBag instance.
             *
             * @return {ErrorBag} errorBag The internal error bag object.
             */
            Validator.prototype.getErrors = function getErrors() {
                return this.errorBag;
            };

            /**
             * Gets the currently active locale.
             *
             * @return {String} Locale identifier.
             */
            Validator.prototype.getLocale = function getLocale() {
                return LOCALE;
            };

            /**
             * Just an alias to the static method for convienece.
             */
            Validator.prototype.installDateTimeValidators = function installDateTimeValidators(moment) {
                Validator.installDateTimeValidators(moment);
            };

            /**
             * Removes a rule from the list of validators.
             * @param {String} name The name of the validator/rule.
             */
            Validator.prototype.remove = function remove(name) {
                Validator.remove(name);
            };

            /**
             * Sets the validator current langauge.
             *
             * @param {string} language locale or language id.
             */
            Validator.prototype.setLocale = function setLocale(language) {
                /* istanbul ignore if */
                if (!dictionary.hasLocale(language)) {
                    // eslint-disable-next-line
                    warn('You are setting the validator locale to a locale that is not defined in the dicitionary. English messages may still be generated.');
                }

                LOCALE = language;
            };

            /**
             * Sets the operating mode for this validator.
             * strictMode = true: Values without a rule are invalid and cause failure.
             * strictMode = false: Values without a rule are valid and are skipped.
             * @param {Boolean} strictMode.
             */
            Validator.prototype.setStrictMode = function setStrictMode(strictMode) {
                if (strictMode === void 0) strictMode = true;

                this.strictMode = strictMode;
            };

            /**
             * Updates the messages dicitionary, overwriting existing values and adding new ones.
             *
             * @param{object} data The messages object.
             */
            Validator.prototype.updateDictionary = function updateDictionary(data) {
                Validator.updateDictionary(data);
            };

            /**
             * Adds a scope.
             */
            Validator.prototype.addScope = function addScope(scope) {
                if (scope && !this.$scopes[scope]) {
                    this.$scopes[scope] = {};
                }
            };

            /**
             * Validates a value against a registered field validations.
             *
             * @param{string} name the field name.
             * @param{*} value The value to be validated.
             * @param {String} scope The scope of the field.
             * @return {boolean|Promise} result returns a boolean or a promise that will resolve to
             *a boolean.
             */
            Validator.prototype.validate = function validate(name, value, scope) {
                var this$1 = this;
                if (scope === void 0) scope = '__global__';

                if (name && name.indexOf('.') > -1) {
                    var assign$$1;
                    (assign$$1 = name.split('.'), scope = assign$$1[0], name = assign$$1[1]);
                }
                if (!scope) {
                    scope = '__global__';
                }
                if (!this.$scopes[scope] || !this.$scopes[scope][name]) {
                    if (!this.strictMode) {
                        return true;
                    }
                    var fullName = scope === '__global__' ? name : (scope + "." + name);
                    warn(("Validating a non-existant field: \"" + fullName + "\". Use \"attach()\" first."));

                    return false;
                }

                var field = this.$scopes[scope][name];
                this.errorBag.remove(name, scope);
                // if its not required and is empty or null or undefined then it passes.
                if (!field.required && ~[null, undefined, ''].indexOf(value)) {
                    this.fieldBag._setFlags(name, {valid: true, dirty: true});
                    return true;
                }

                var test = true;
                var promises = [];
                Object.keys(field.validations).forEach(function (rule) {
                    var result = this$1._test(
                        name,
                        value,
                        {name: rule, params: field.validations[rule]},
                        scope);
                    if (isCallable(result.then)) {
                        promises.push(result);
                        return;
                    }

                    test = test && result;
                });

                if (promises.length) {
                    return Promise.all(promises).then(function (values) {
                        var valid = values.every(function (t) {
                            return t;
                        }) && test;
                        this$1.fieldBag._setFlags(name, {valid: valid, dirty: true});

                        return valid;
                    });
                }

                this.fieldBag._setFlags(name, {valid: test, dirty: true});

                return test;
            };

            /**
             * Validates each value against the corresponding field validations.
             * @param{object} values The values to be validated.
             * @return {Promise} Returns a promise with the validation result.
             */
            Validator.prototype.validateAll = function validateAll(values) {
                var this$1 = this;

                var normalizedValues;
                if (!values || typeof values === 'string') {
                    this.errorBag.clear(values);
                    normalizedValues = this._resolveValuesFromGetters(values);
                } else {
                    normalizedValues = {};
                    Object.keys(values).forEach(function (key) {
                        normalizedValues[key] = {
                            value: values[key]
                        };
                    });
                }

                var test = true;
                var promises = [];
                Object.keys(normalizedValues).forEach(function (property) {
                    var result = this$1.validate(
                        property,
                        normalizedValues[property].value,
                        normalizedValues[property].scope
                    );
                    if (isCallable(result.then)) {
                        promises.push(result);
                        return;
                    }

                    test = test && result;
                });

                return Promise.all(promises).then(function (vals) {
                    var valid = vals.every(function (t) {
                        return t;
                    }) && test;

                    if (!valid) {
                        throw new ValidatorException('Validation Failed');
                    }

                    return valid;
                });
            };

            /**
             * Validates all scopes.
             * @returns {Promise} All promises resulted from each scope.
             */
            Validator.prototype.validateScopes = function validateScopes() {
                var this$1 = this;

                return Promise.all(
                    Object.keys(this.$scopes).map(function (scope) {
                        return this$1.validateAll(scope);
                    })
                );
            };

            /**
             * Keeps track of $vm, $validator instances.
             * @type {Array}
             */
            var instances = [];

            /**
             * Finds a validator instance from the instances array.
             * @param  {[type]} $vm The Vue instance.
             * @return {object} pair the $vm,$validator pair.
             */
            var find = function ($vm) {
                for (var i = 0; i < instances.length; i++) {
                    if (instances[i].$vm === $vm) {
                        return instances[i].$validator;
                    }
                }

                return undefined;
            };

            /**
             * Registers a validator for a $vm instance.
             * @param  {*} $vm The Vue instance.
             * @return {Validator} $validator The validator instance.
             */
            var register = function ($vm) {
                var instance = find($vm);
                if (!instance) {
                    instance = Validator.create(undefined, $vm, {init: false});

                    instances.push({
                        $vm: $vm,
                        $validator: instance
                    });
                }

                return instance;
            };

            var unregister = function ($vm) {
                for (var i = 0; i < instances.length; i++) {
                    if (instances[i].$vm === $vm) {
                        instances.splice(i, 1);

                        return true;
                    }
                }

                return false;
            };

            var mixin = function (options) {
                return ({
                    data: function data() {
                        return ( obj = {}, obj[options.errorBagName] = this.$validator.errorBag, obj );
                        var obj;
                    },
                    computed: ( obj = {}, obj[options.fieldsBagName] = {
                        get: function get() {
                            return this.$validator.fieldBag;
                        }
                    }, obj ),
                    mounted: function mounted() {
                        this.$validator.init();
                    },
                    destroyed: function destroyed() {
                        unregister(this);
                    }
                })
                var obj;
            };

            var ListenerGenerator = function ListenerGenerator(el, binding, vnode, options) {
                this.unwatch = undefined;
                this.callbacks = [];
                this.el = el;
                this.scope = isObject(binding.value) ? binding.value.scope : getScope(el);
                this.binding = binding;
                this.vm = vnode.context;
                this.component = vnode.child;
                this.options = options;
                this.fieldName = this._resolveFieldName();
                if (vnode.data && vnode.data.directives) {
                    this.model = this._resolveModel(vnode.data.directives);
                }
            };

            /**
             * Checks if the node directives contains a v-model.
             */
            ListenerGenerator.prototype._resolveModel = function _resolveModel(directives) {
                var boundTo = null;
                directives.some(function (d) {
                    if (d.name === 'model') {
                        boundTo = d.expression;

                        return true;
                    }

                    return false;
                });

                return boundTo;
            };

            /**
             * Resolves the field name to trigger validations.
             * @return {String} The field name.
             */
            ListenerGenerator.prototype._resolveFieldName = function _resolveFieldName() {
                if (this.component) {
                    return getDataAttribute(this.el, 'name') || this.component.name;
                }

                return this.el.name || getDataAttribute(this.el, 'name');
            };

            /**
             * Determines if the validation rule requires additional listeners on target fields.
             */
            ListenerGenerator.prototype._hasFieldDependency = function _hasFieldDependency(rules) {
                var this$1 = this;

                var fieldName = false;
                if (!rules) {
                    return false;
                }

                if (isObject(rules)) {
                    Object.keys(rules).forEach(function (r) {
                        if (/confirmed|after|before/.test(r)) {
                            fieldName = rules[r];

                            return false;
                        }
                    });

                    return fieldName;
                }

                rules.split('|').every(function (r) {
                    if (/\b(confirmed|after|before):/.test(r)) {
                        fieldName = r.split(':')[1];
                        return false;
                    }

                    if (/\b(confirmed)/.test(r)) {
                        fieldName = (this$1.fieldName) + "_confirmation";
                        return false;
                    }

                    return true;
                });

                return fieldName;
            };

            /**
             * Validates input value, triggered by 'input' event.
             */
            ListenerGenerator.prototype._inputListener = function _inputListener() {
                this._validate(this.el.value);
            };

            /**
             * Validates files, triggered by 'change' event.
             */
            ListenerGenerator.prototype._fileListener = function _fileListener() {
                var isValid = this._validate(toArray(this.el.files));

                if (!isValid && this.binding.modifiers.reject) {
                    this.el.value = '';
                }
            };

            /**
             * Validates radio buttons, triggered by 'change' event.
             */
            ListenerGenerator.prototype._radioListener = function _radioListener() {
                var checked = document.querySelector(("input[name=\"" + (this.el.name) + "\"]:checked"));
                this._validate(checked ? checked.value : null);
            };

            /**
             * Validates checkboxes, triggered by change event.
             */
            ListenerGenerator.prototype._checkboxListener = function _checkboxListener() {
                var this$1 = this;

                var checkedBoxes = document.querySelectorAll(("input[name=\"" + (this.el.name) + "\"]:checked"));
                if (!checkedBoxes || !checkedBoxes.length) {
                    this._validate(null);
                    return;
                }

                toArray(checkedBoxes).forEach(function (box) {
                    this$1._validate(box.value);
                });
            };

            /**
             * Trigger the validation for a specific value.
             */
            ListenerGenerator.prototype._validate = function _validate(value) {
                return this.vm.$validator.validate(this.fieldName, value, this.scope || getScope(this.el));
            };

            /**
             * Returns a scoped callback, only runs if the el scope is the same as the recieved scope
             * From the event.
             */
            ListenerGenerator.prototype._getScopedListener = function _getScopedListener(callback) {
                var this$1 = this;

                return function (scope) {
                    if (!scope || scope === this$1.scope || scope instanceof Event) {
                        callback();
                    }
                };
            };

            ListenerGenerator.prototype._getRules = function _getRules() {
                if (!this.binding.expression) {
                    return getDataAttribute(this.el, 'rules');
                }

                return isObject(this.binding.value) ? this.binding.value.rules : this.binding.value;
            };

            /**
             * Attaches validator event-triggered validation.
             */
            ListenerGenerator.prototype._attachValidatorEvent = function _attachValidatorEvent() {
                var this$1 = this;

                var listener = this._getScopedListener(this._getSuitableListener().listener.bind(this));
                var fieldName = this._hasFieldDependency(this._getRules());
                if (fieldName) {
                    // Wait for the validator ready triggered when vm is mounted because maybe
                    // the element isn't mounted yet.
                    this.vm.$nextTick(function () {
                        var target = document.querySelector(("input[name='" + fieldName + "']"));
                        if (!target) {
                            warn('Cannot find target field, no additional listeners were attached.');
                            return;
                        }

                        target.addEventListener('input', listener);
                        this$1.callbacks.push({name: 'input', listener: listener, el: target});
                    });
                }
            };

            /**
             * Determines a suitable listener for the element.
             */
            ListenerGenerator.prototype._getSuitableListener = function _getSuitableListener() {
                var listener;

                if (this.el.tagName === 'SELECT') {
                    return {
                        names: ['change', 'blur'],
                        listener: this._inputListener
                    };
                }

                // determine the suitable listener and events to handle
                switch (this.el.type) {
                    case 'file':
                        listener = {
                            names: ['change'],
                            listener: this._fileListener
                        };
                        break;

                    case 'radio':
                        listener = {
                            names: ['change'],
                            listener: this._radioListener
                        };
                        break;

                    case 'checkbox':
                        listener = {
                            names: ['change'],
                            listener: this._checkboxListener
                        };
                        break;

                    default:
                        listener = {
                            names: ['input', 'blur'],
                            listener: this._inputListener
                        };
                        break;
                }

                // users are able to specify which events they want to validate on
                // pipe separated list of handler names to use
                var events = getDataAttribute(this.el, 'validate-on');
                if (events) {
                    listener.names = events.split('|');
                }

                return listener;
            };

            /**
             * Attaches neccessary validation events for the component.
             */
            ListenerGenerator.prototype._attachComponentListeners = function _attachComponentListeners() {
                var this$1 = this;

                this.componentListener = debounce(function (value) {
                    this$1._validate(value);
                }, getDataAttribute(this.el, 'delay') || this.options.delay);

                this.component.$on('input', this.componentListener);
            };

            /**
             * Attachs a suitable listener for the input.
             */
            ListenerGenerator.prototype._attachFieldListeners = function _attachFieldListeners() {
                var this$1 = this;

                // If it is a component, use vue events instead.
                if (this.component) {
                    this._attachComponentListeners();

                    return;
                }

                var handler = this._getSuitableListener();
                var listener = debounce(
                    handler.listener.bind(this),
                    getDataAttribute(this.el, 'delay') || this.options.delay
                );

                if (~['radio', 'checkbox'].indexOf(this.el.type)) {
                    this.vm.$nextTick(function () {
                        var elms = document.querySelectorAll(("input[name=\"" + (this$1.el.name) + "\"]"));
                        toArray(elms).forEach(function (input) {
                            handler.names.forEach(function (handlerName) {
                                input.addEventListener(handlerName, listener);
                                this$1.callbacks.push({name: handlerName, listener: listener, el: input});
                            });
                        });
                    });

                    return;
                }

                handler.names.forEach(function (handlerName) {
                    this$1.el.addEventListener(handlerName, listener);
                    this$1.callbacks.push({name: handlerName, listener: listener, el: this$1.el});
                });
            };

            /**
             * Returns a context, getter factory pairs for each input type.
             */
            ListenerGenerator.prototype._resolveValueGetter = function _resolveValueGetter() {
                var this$1 = this;

                if (this.component) {
                    return {
                        context: function () {
                            return this$1.component;
                        },
                        getter: function getter(context) {
                            return context[getDataAttribute(context.$el, 'value-path')] || context.value;
                        }
                    };
                }

                switch (this.el.type) {
                    case 'checkbox':
                        return {
                            context: function () {
                                return document.querySelectorAll(("input[name=\"" + (this$1.el.name) + "\"]:checked"));
                            },
                            getter: function getter(context) {
                                if (!context || !context.length) {
                                    return null;
                                }

                                return toArray(context).map(function (checkbox) {
                                    return checkbox.value;
                                });
                            }
                        };
                    case 'radio':
                        return {
                            context: function () {
                                return document.querySelector(("input[name=\"" + (this$1.el.name) + "\"]:checked"));
                            },
                            getter: function getter(context) {
                                return context && context.value;
                            }
                        };
                    case 'file':
                        return {
                            context: function () {
                                return this$1.el;
                            },
                            getter: function getter(context) {
                                return toArray(context.files);
                            }
                        };

                    default:
                        return {
                            context: function () {
                                return this$1.el;
                            },
                            getter: function getter(context) {
                                return context.value;
                            }
                        };
                }
            };

            /*
  * Gets the arg string value, either from the directive or the expression value.
  */
            ListenerGenerator.prototype._getArg = function _getArg() {
                if (this.model) {
                    return this.model;
                }

                if (this.binding.arg) {
                    return this.binding.arg;
                }

                return isObject(this.binding.value) ? this.binding.value.arg : null;
            };

            /**
             * Attaches the Event Listeners.
             */
            ListenerGenerator.prototype.attach = function attach() {
                var this$1 = this;

                var ref = this._resolveValueGetter();
                var context = ref.context;
                var getter = ref.getter;
                this.vm.$validator.attach(this.fieldName, this._getRules(), {
                    // eslint-disable-next-line
                    scope: function () {
                        return this$1.scope || getScope(this$1.el);
                    },
                    prettyName: getDataAttribute(this.el, 'as'),
                    context: context,
                    getter: getter,
                    listeners: this
                });

                this._attachValidatorEvent();
                var arg = this._getArg();
                if (arg) {
                    this.unwatch = this.vm.$watch(arg, function (value) {
                        this$1.vm.$validator.validate(this$1.fieldName, value, this$1.scope || getScope(this$1.el));
                    }, {deep: true});

                    return;
                }

                this._attachFieldListeners();
            };

            /**
             * Removes all attached event listeners.
             */
            ListenerGenerator.prototype.detach = function detach() {
                if (this.component) {
                    this.component.$off('input', this.componentListener);
                }

                if (this.unwatch) {
                    this.unwatch();
                }

                this.callbacks.forEach(function (h) {
                    h.el.removeEventListener(h.name, h.listener);
                });
            };

            var listenersInstances = [];

            var defaultClassNames = {
                touched: 'touched', // the control has been blurred
                untouched: 'untouched', // the control hasn't been blurred
                valid: 'valid', // model is valid
                invalid: 'invalid', // model is invalid
                pristine: 'pristine', // control has not been interacted with
                dirty: 'dirty' // control has been interacted with
            };

            function addClasses(el, fieldName, fields, classNames) {
                if (classNames === void 0) classNames = null;

                if (!fieldName) {
                    return;
                }

                classNames = assign({}, defaultClassNames, classNames);

                var isDirty = fields.dirty(fieldName);
                var isValid = fields.valid(fieldName);
                var failed = fields.failed(fieldName);

                if (isDirty) {
                    addClass(el, classNames.touched);
                    removeClass(el, classNames.untouched);
                } else {
                    addClass(el, classNames.untouched);
                    removeClass(el, classNames.touched);
                }

                if (isValid) {
                    addClass(el, classNames.valid);
                    removeClass(el, classNames.invalid);
                } else {
                    if (failed) {
                        addClass(el, classNames.invalid);
                    }
                    removeClass(el, classNames.valid);
                }
            }

            function setDirty(el, classNames) {
                classNames = assign({}, defaultClassNames, classNames);

                addClass(el, classNames.dirty);
                removeClass(el, classNames.pristine);
            }

            function setPristine(el, classNames) {
                classNames = assign({}, defaultClassNames, classNames);

                addClass(el, classNames.pristine);
                removeClass(el, classNames.dirty);
            }

            var directive = function (options) {
                return ({
                    bind: function bind(el, binding, vnode) {
                        var listener = new ListenerGenerator(el, binding, vnode, options);

                        listener.attach();
                        listenersInstances.push({vm: vnode.context, el: el, instance: listener});

                        if (options.enableAutoClasses) {
                            var classNames = options.classNames;

                            setPristine(el, classNames);

                            el.onfocus = function () {
                                setDirty(el, classNames);
                            };

                            addClasses(el, listener.fieldName, vnode.context[options.fieldsBagName], classNames);
                        }
                    },
                    update: function update(el, ref, ref$1) {
                        var expression = ref.expression;
                        var value = ref.value;
                        var oldValue = ref.oldValue;
                        var context = ref$1.context;

                        var holder = listenersInstances.filter(function (l) {
                            return l.vm === context && l.el === el;
                        })[0];
                        if (options.enableAutoClasses) {
                            addClasses(el, holder.instance.fieldName, context[options.fieldsBagName], options.classNames);
                        }

                        // make sure we don't do uneccessary work if no expression was passed
                        // or if the string value did not change.
                        // eslint-disable-next-line
                        if (!expression || (typeof value === 'string' && typeof oldValue === 'string' && value === oldValue)) {
                            return;
                        }

                        var scope = isObject(value) ? (value.scope || getScope(el)) : getScope(el);
                        context.$validator.updateField(
                            holder.instance.fieldName,
                            isObject(value) ? value.rules : value,
                            {scope: scope || '__global__'}
                        );
                    },
                    unbind: function unbind(el, ref, ref$1) {
                        var value = ref.value;
                        var context = ref$1.context;

                        var holder = listenersInstances.filter(function (l) {
                            return l.vm === context && l.el === el;
                        })[0];
                        if (typeof holder === 'undefined') {
                            return;
                        }

                        var scope = isObject(value) ? value.scope : getScope(el);
                        context.$validator.detach(holder.instance.fieldName, scope);
                        listenersInstances.splice(listenersInstances.indexOf(holder), 1);
                    }
                });
            };

// eslint-disable-next-line
            var install = function (Vue, ref) {
                if (ref === void 0) ref = {};
                var locale = ref.locale;
                if (locale === void 0) locale = 'en';
                var delay = ref.delay;
                if (delay === void 0) delay = 0;
                var errorBagName = ref.errorBagName;
                if (errorBagName === void 0) errorBagName = 'errors';
                var dictionary = ref.dictionary;
                if (dictionary === void 0) dictionary = null;
                var strict = ref.strict;
                if (strict === void 0) strict = true;
                var fieldsBagName = ref.fieldsBagName;
                if (fieldsBagName === void 0) fieldsBagName = 'fields';
                var enableAutoClasses = ref.enableAutoClasses;
                if (enableAutoClasses === void 0) enableAutoClasses = false;
                var classNames = ref.classNames;
                if (classNames === void 0) classNames = null;

                if (dictionary) {
                    Validator.updateDictionary(dictionary);
                }

                Validator.setLocale(locale);
                Validator.setStrictMode(strict);

                var options = {
                    locale: locale,
                    delay: delay,
                    dictionary: dictionary,
                    errorBagName: errorBagName,
                    fieldsBagName: fieldsBagName,
                    enableAutoClasses: enableAutoClasses,
                    classNames: classNames
                };

                Object.defineProperties(Vue.prototype, {
                    $validator: {
                        get: function get() {
                            return register(this);
                        }
                    }
                });

                Vue.mixin(mixin(options)); // Install Mixin.
                Vue.directive('validate', directive(options));
            };

            var index = {
                install: install,
                Validator: Validator,
                ErrorBag: ErrorBag,
                version: '2.0.0-beta.22'
            };

            return index;

        })));


        /***/
    },
    /* 112 */
    /***/ function (module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */
        (function (global) {
            var require;
            var require;
            /* VueBoot v0.4.5 */
            (function (f) {
                if (true) {
                    module.exports = f()
                } else if (typeof define === "function" && define.amd) {
                    define([], f)
                } else {
                    var g;
                    if (typeof window !== "undefined") {
                        g = window
                    } else if (typeof global !== "undefined") {
                        g = global
                    } else if (typeof self !== "undefined") {
                        g = self
                    } else {
                        g = this
                    }
                    g.vueboot = f()
                }
            })(function () {
                var define, module, exports;
                return (function e(t, n, r) {
                    function s(o, u) {
                        if (!n[o]) {
                            if (!t[o]) {
                                var a = typeof require == "function" && require;
                                if (!u && a) return require(o, !0);
                                if (i) return i(o, !0);
                                var f = new Error("Cannot find module '" + o + "'");
                                throw f.code = "MODULE_NOT_FOUND", f
                            }
                            var l = n[o] = {exports: {}};
                            t[o][0].call(l.exports, function (e) {
                                var n = t[o][1][e];
                                return s(n ? n : e)
                            }, l, l.exports, e, t, n, r)
                        }
                        return n[o].exports
                    }

                    var i = typeof require == "function" && require;
                    for (var o = 0; o < r.length; o++) s(r[o]);
                    return s
                })({
                    1: [function (_dereq_, module, exports) {
                        module.exports = {
                            "default": _dereq_("core-js/library/fn/object/define-property"),
                            __esModule: true
                        };
                    }, {"core-js/library/fn/object/define-property": 4}],
                    2: [function (_dereq_, module, exports) {
                        "use strict";

                        exports.__esModule = true;

                        exports.default = function (instance, Constructor) {
                            if (!(instance instanceof Constructor)) {
                                throw new TypeError("Cannot call a class as a function");
                            }
                        };
                    }, {}],
                    3: [function (_dereq_, module, exports) {
                        "use strict";

                        exports.__esModule = true;

                        var _defineProperty = _dereq_("../core-js/object/define-property");

                        var _defineProperty2 = _interopRequireDefault(_defineProperty);

                        function _interopRequireDefault(obj) {
                            return obj && obj.__esModule ? obj : {default: obj};
                        }

                        exports.default = function () {
                            function defineProperties(target, props) {
                                for (var i = 0; i < props.length; i++) {
                                    var descriptor = props[i];
                                    descriptor.enumerable = descriptor.enumerable || false;
                                    descriptor.configurable = true;
                                    if ("value" in descriptor) descriptor.writable = true;
                                    (0, _defineProperty2.default)(target, descriptor.key, descriptor);
                                }
                            }

                            return function (Constructor, protoProps, staticProps) {
                                if (protoProps) defineProperties(Constructor.prototype, protoProps);
                                if (staticProps) defineProperties(Constructor, staticProps);
                                return Constructor;
                            };
                        }();
                    }, {"../core-js/object/define-property": 1}],
                    4: [function (_dereq_, module, exports) {
                        var $ = _dereq_('../../modules/$');
                        module.exports = function defineProperty(it, key, desc) {
                            return $.setDesc(it, key, desc);
                        };
                    }, {"../../modules/$": 5}],
                    5: [function (_dereq_, module, exports) {
                        var $Object = Object;
                        module.exports = {
                            create: $Object.create,
                            getProto: $Object.getPrototypeOf,
                            isEnum: {}.propertyIsEnumerable,
                            getDesc: $Object.getOwnPropertyDescriptor,
                            setDesc: $Object.defineProperty,
                            setDescs: $Object.defineProperties,
                            getKeys: $Object.keys,
                            getNames: $Object.getOwnPropertyNames,
                            getSymbols: $Object.getOwnPropertySymbols,
                            each: [].forEach
                        };
                    }, {}],
                    6: [function (_dereq_, module, exports) {
                        (function (global) {
                            /**
                             * @license
                             * lodash 3.10.1 (Custom Build) <https://lodash.com/>
                             * Build: `lodash modern -d -o ./index.js`
                             * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
                             * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
                             * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
                             * Available under MIT license <https://lodash.com/license>
                             */
                            ;(function () {

                                /** Used as a safe reference for `undefined` in pre-ES5 environments. */
                                var undefined;

                                /** Used as the semantic version number. */
                                var VERSION = '3.10.1';

                                /** Used to compose bitmasks for wrapper metadata. */
                                var BIND_FLAG = 1,
                                    BIND_KEY_FLAG = 2,
                                    CURRY_BOUND_FLAG = 4,
                                    CURRY_FLAG = 8,
                                    CURRY_RIGHT_FLAG = 16,
                                    PARTIAL_FLAG = 32,
                                    PARTIAL_RIGHT_FLAG = 64,
                                    ARY_FLAG = 128,
                                    REARG_FLAG = 256;

                                /** Used as default options for `_.trunc`. */
                                var DEFAULT_TRUNC_LENGTH = 30,
                                    DEFAULT_TRUNC_OMISSION = '...';

                                /** Used to detect when a function becomes hot. */
                                var HOT_COUNT = 150,
                                    HOT_SPAN = 16;

                                /** Used as the size to enable large array optimizations. */
                                var LARGE_ARRAY_SIZE = 200;

                                /** Used to indicate the type of lazy iteratees. */
                                var LAZY_FILTER_FLAG = 1,
                                    LAZY_MAP_FLAG = 2;

                                /** Used as the `TypeError` message for "Functions" methods. */
                                var FUNC_ERROR_TEXT = 'Expected a function';

                                /** Used as the internal argument placeholder. */
                                var PLACEHOLDER = '__lodash_placeholder__';

                                /** `Object#toString` result references. */
                                var argsTag = '[object Arguments]',
                                    arrayTag = '[object Array]',
                                    boolTag = '[object Boolean]',
                                    dateTag = '[object Date]',
                                    errorTag = '[object Error]',
                                    funcTag = '[object Function]',
                                    mapTag = '[object Map]',
                                    numberTag = '[object Number]',
                                    objectTag = '[object Object]',
                                    regexpTag = '[object RegExp]',
                                    setTag = '[object Set]',
                                    stringTag = '[object String]',
                                    weakMapTag = '[object WeakMap]';

                                var arrayBufferTag = '[object ArrayBuffer]',
                                    float32Tag = '[object Float32Array]',
                                    float64Tag = '[object Float64Array]',
                                    int8Tag = '[object Int8Array]',
                                    int16Tag = '[object Int16Array]',
                                    int32Tag = '[object Int32Array]',
                                    uint8Tag = '[object Uint8Array]',
                                    uint8ClampedTag = '[object Uint8ClampedArray]',
                                    uint16Tag = '[object Uint16Array]',
                                    uint32Tag = '[object Uint32Array]';

                                /** Used to match empty string literals in compiled template source. */
                                var reEmptyStringLeading = /\b__p \+= '';/g,
                                    reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
                                    reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

                                /** Used to match HTML entities and HTML characters. */
                                var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
                                    reUnescapedHtml = /[&<>"'`]/g,
                                    reHasEscapedHtml = RegExp(reEscapedHtml.source),
                                    reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

                                /** Used to match template delimiters. */
                                var reEscape = /<%-([\s\S]+?)%>/g,
                                    reEvaluate = /<%([\s\S]+?)%>/g,
                                    reInterpolate = /<%=([\s\S]+?)%>/g;

                                /** Used to match property names within property paths. */
                                var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
                                    reIsPlainProp = /^\w*$/,
                                    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;

                                /**
                                 * Used to match `RegExp` [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns)
                                 * and those outlined by [`EscapeRegExpPattern`](http://ecma-international.org/ecma-262/6.0/#sec-escaperegexppattern).
                                 */
                                var reRegExpChars = /^[:!,]|[\\^$.*+?()[\]{}|\/]|(^[0-9a-fA-Fnrtuvx])|([\n\r\u2028\u2029])/g,
                                    reHasRegExpChars = RegExp(reRegExpChars.source);

                                /** Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks). */
                                var reComboMark = /[\u0300-\u036f\ufe20-\ufe23]/g;

                                /** Used to match backslashes in property paths. */
                                var reEscapeChar = /\\(\\)?/g;

                                /** Used to match [ES template delimiters](http://ecma-international.org/ecma-262/6.0/#sec-template-literal-lexical-components). */
                                var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

                                /** Used to match `RegExp` flags from their coerced string values. */
                                var reFlags = /\w*$/;

                                /** Used to detect hexadecimal string values. */
                                var reHasHexPrefix = /^0[xX]/;

                                /** Used to detect host constructors (Safari > 5). */
                                var reIsHostCtor = /^\[object .+?Constructor\]$/;

                                /** Used to detect unsigned integer values. */
                                var reIsUint = /^\d+$/;

                                /** Used to match latin-1 supplementary letters (excluding mathematical operators). */
                                var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;

                                /** Used to ensure capturing order of template delimiters. */
                                var reNoMatch = /($^)/;

                                /** Used to match unescaped characters in compiled string literals. */
                                var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

                                /** Used to match words to create compound words. */
                                var reWords = (function () {
                                    var upper = '[A-Z\\xc0-\\xd6\\xd8-\\xde]',
                                        lower = '[a-z\\xdf-\\xf6\\xf8-\\xff]+';

                                    return RegExp(upper + '+(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');
                                }());

                                /** Used to assign default `context` object properties. */
                                var contextProps = [
                                    'Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array',
                                    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number',
                                    'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'isFinite',
                                    'parseFloat', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array',
                                    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap'
                                ];

                                /** Used to make template sourceURLs easier to identify. */
                                var templateCounter = -1;

                                /** Used to identify `toStringTag` values of typed arrays. */
                                var typedArrayTags = {};
                                typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
                                    typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
                                        typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
                                            typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
                                                typedArrayTags[uint32Tag] = true;
                                typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
                                    typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
                                        typedArrayTags[dateTag] = typedArrayTags[errorTag] =
                                            typedArrayTags[funcTag] = typedArrayTags[mapTag] =
                                                typedArrayTags[numberTag] = typedArrayTags[objectTag] =
                                                    typedArrayTags[regexpTag] = typedArrayTags[setTag] =
                                                        typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

                                /** Used to identify `toStringTag` values supported by `_.clone`. */
                                var cloneableTags = {};
                                cloneableTags[argsTag] = cloneableTags[arrayTag] =
                                    cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
                                        cloneableTags[dateTag] = cloneableTags[float32Tag] =
                                            cloneableTags[float64Tag] = cloneableTags[int8Tag] =
                                                cloneableTags[int16Tag] = cloneableTags[int32Tag] =
                                                    cloneableTags[numberTag] = cloneableTags[objectTag] =
                                                        cloneableTags[regexpTag] = cloneableTags[stringTag] =
                                                            cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
                                                                cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
                                cloneableTags[errorTag] = cloneableTags[funcTag] =
                                    cloneableTags[mapTag] = cloneableTags[setTag] =
                                        cloneableTags[weakMapTag] = false;

                                /** Used to map latin-1 supplementary letters to basic latin letters. */
                                var deburredLetters = {
                                    '\xc0': 'A', '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
                                    '\xe0': 'a', '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
                                    '\xc7': 'C', '\xe7': 'c',
                                    '\xd0': 'D', '\xf0': 'd',
                                    '\xc8': 'E', '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
                                    '\xe8': 'e', '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
                                    '\xcC': 'I', '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
                                    '\xeC': 'i', '\xed': 'i', '\xee': 'i', '\xef': 'i',
                                    '\xd1': 'N', '\xf1': 'n',
                                    '\xd2': 'O', '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
                                    '\xf2': 'o', '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
                                    '\xd9': 'U', '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
                                    '\xf9': 'u', '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
                                    '\xdd': 'Y', '\xfd': 'y', '\xff': 'y',
                                    '\xc6': 'Ae', '\xe6': 'ae',
                                    '\xde': 'Th', '\xfe': 'th',
                                    '\xdf': 'ss'
                                };

                                /** Used to map characters to HTML entities. */
                                var htmlEscapes = {
                                    '&': '&amp;',
                                    '<': '&lt;',
                                    '>': '&gt;',
                                    '"': '&quot;',
                                    "'": '&#39;',
                                    '`': '&#96;'
                                };

                                /** Used to map HTML entities to characters. */
                                var htmlUnescapes = {
                                    '&amp;': '&',
                                    '&lt;': '<',
                                    '&gt;': '>',
                                    '&quot;': '"',
                                    '&#39;': "'",
                                    '&#96;': '`'
                                };

                                /** Used to determine if values are of the language type `Object`. */
                                var objectTypes = {
                                    'function': true,
                                    'object': true
                                };

                                /** Used to escape characters for inclusion in compiled regexes. */
                                var regexpEscapes = {
                                    '0': 'x30', '1': 'x31', '2': 'x32', '3': 'x33', '4': 'x34',
                                    '5': 'x35', '6': 'x36', '7': 'x37', '8': 'x38', '9': 'x39',
                                    'A': 'x41', 'B': 'x42', 'C': 'x43', 'D': 'x44', 'E': 'x45', 'F': 'x46',
                                    'a': 'x61', 'b': 'x62', 'c': 'x63', 'd': 'x64', 'e': 'x65', 'f': 'x66',
                                    'n': 'x6e', 'r': 'x72', 't': 'x74', 'u': 'x75', 'v': 'x76', 'x': 'x78'
                                };

                                /** Used to escape characters for inclusion in compiled string literals. */
                                var stringEscapes = {
                                    '\\': '\\',
                                    "'": "'",
                                    '\n': 'n',
                                    '\r': 'r',
                                    '\u2028': 'u2028',
                                    '\u2029': 'u2029'
                                };

                                /** Detect free variable `exports`. */
                                var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

                                /** Detect free variable `module`. */
                                var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

                                /** Detect free variable `global` from Node.js. */
                                var freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;

                                /** Detect free variable `self`. */
                                var freeSelf = objectTypes[typeof self] && self && self.Object && self;

                                /** Detect free variable `window`. */
                                var freeWindow = objectTypes[typeof window] && window && window.Object && window;

                                /** Detect the popular CommonJS extension `module.exports`. */
                                var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

                                /**
                                 * Used as a reference to the global object.
                                 *
                                 * The `this` value is used if it's the global object to avoid Greasemonkey's
                                 * restricted `window` object, otherwise the `window` object is used.
                                 */
                                var root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;

                                /*--------------------------------------------------------------------------*/

                                /**
                                 * The base implementation of `compareAscending` which compares values and
                                 * sorts them in ascending order without guaranteeing a stable sort.
                                 *
                                 * @private
                                 * @param {*} value The value to compare.
                                 * @param {*} other The other value to compare.
                                 * @returns {number} Returns the sort order indicator for `value`.
                                 */
                                function baseCompareAscending(value, other) {
                                    if (value !== other) {
                                        var valIsNull = value === null,
                                            valIsUndef = value === undefined,
                                            valIsReflexive = value === value;

                                        var othIsNull = other === null,
                                            othIsUndef = other === undefined,
                                            othIsReflexive = other === other;

                                        if ((value > other && !othIsNull) || !valIsReflexive ||
                                            (valIsNull && !othIsUndef && othIsReflexive) ||
                                            (valIsUndef && othIsReflexive)) {
                                            return 1;
                                        }
                                        if ((value < other && !valIsNull) || !othIsReflexive ||
                                            (othIsNull && !valIsUndef && valIsReflexive) ||
                                            (othIsUndef && valIsReflexive)) {
                                            return -1;
                                        }
                                    }
                                    return 0;
                                }

                                /**
                                 * The base implementation of `_.findIndex` and `_.findLastIndex` without
                                 * support for callback shorthands and `this` binding.
                                 *
                                 * @private
                                 * @param {Array} array The array to search.
                                 * @param {Function} predicate The function invoked per iteration.
                                 * @param {boolean} [fromRight] Specify iterating from right to left.
                                 * @returns {number} Returns the index of the matched value, else `-1`.
                                 */
                                function baseFindIndex(array, predicate, fromRight) {
                                    var length = array.length,
                                        index = fromRight ? length : -1;

                                    while ((fromRight ? index-- : ++index < length)) {
                                        if (predicate(array[index], index, array)) {
                                            return index;
                                        }
                                    }
                                    return -1;
                                }

                                /**
                                 * The base implementation of `_.indexOf` without support for binary searches.
                                 *
                                 * @private
                                 * @param {Array} array The array to search.
                                 * @param {*} value The value to search for.
                                 * @param {number} fromIndex The index to search from.
                                 * @returns {number} Returns the index of the matched value, else `-1`.
                                 */
                                function baseIndexOf(array, value, fromIndex) {
                                    if (value !== value) {
                                        return indexOfNaN(array, fromIndex);
                                    }
                                    var index = fromIndex - 1,
                                        length = array.length;

                                    while (++index < length) {
                                        if (array[index] === value) {
                                            return index;
                                        }
                                    }
                                    return -1;
                                }

                                /**
                                 * The base implementation of `_.isFunction` without support for environments
                                 * with incorrect `typeof` results.
                                 *
                                 * @private
                                 * @param {*} value The value to check.
                                 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
                                 */
                                function baseIsFunction(value) {
                                    // Avoid a Chakra JIT bug in compatibility modes of IE 11.
                                    // See https://github.com/jashkenas/underscore/issues/1621 for more details.
                                    return typeof value == 'function' || false;
                                }

                                /**
                                 * Converts `value` to a string if it's not one. An empty string is returned
                                 * for `null` or `undefined` values.
                                 *
                                 * @private
                                 * @param {*} value The value to process.
                                 * @returns {string} Returns the string.
                                 */
                                function baseToString(value) {
                                    return value == null ? '' : (value + '');
                                }

                                /**
                                 * Used by `_.trim` and `_.trimLeft` to get the index of the first character
                                 * of `string` that is not found in `chars`.
                                 *
                                 * @private
                                 * @param {string} string The string to inspect.
                                 * @param {string} chars The characters to find.
                                 * @returns {number} Returns the index of the first character not found in `chars`.
                                 */
                                function charsLeftIndex(string, chars) {
                                    var index = -1,
                                        length = string.length;

                                    while (++index < length && chars.indexOf(string.charAt(index)) > -1) {
                                    }
                                    return index;
                                }

                                /**
                                 * Used by `_.trim` and `_.trimRight` to get the index of the last character
                                 * of `string` that is not found in `chars`.
                                 *
                                 * @private
                                 * @param {string} string The string to inspect.
                                 * @param {string} chars The characters to find.
                                 * @returns {number} Returns the index of the last character not found in `chars`.
                                 */
                                function charsRightIndex(string, chars) {
                                    var index = string.length;

                                    while (index-- && chars.indexOf(string.charAt(index)) > -1) {
                                    }
                                    return index;
                                }

                                /**
                                 * Used by `_.sortBy` to compare transformed elements of a collection and stable
                                 * sort them in ascending order.
                                 *
                                 * @private
                                 * @param {Object} object The object to compare.
                                 * @param {Object} other The other object to compare.
                                 * @returns {number} Returns the sort order indicator for `object`.
                                 */
                                function compareAscending(object, other) {
                                    return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
                                }

                                /**
                                 * Used by `_.sortByOrder` to compare multiple properties of a value to another
                                 * and stable sort them.
                                 *
                                 * If `orders` is unspecified, all valuess are sorted in ascending order. Otherwise,
                                 * a value is sorted in ascending order if its corresponding order is "asc", and
                                 * descending if "desc".
                                 *
                                 * @private
                                 * @param {Object} object The object to compare.
                                 * @param {Object} other The other object to compare.
                                 * @param {boolean[]} orders The order to sort by for each property.
                                 * @returns {number} Returns the sort order indicator for `object`.
                                 */
                                function compareMultiple(object, other, orders) {
                                    var index = -1,
                                        objCriteria = object.criteria,
                                        othCriteria = other.criteria,
                                        length = objCriteria.length,
                                        ordersLength = orders.length;

                                    while (++index < length) {
                                        var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
                                        if (result) {
                                            if (index >= ordersLength) {
                                                return result;
                                            }
                                            var order = orders[index];
                                            return result * ((order === 'asc' || order === true) ? 1 : -1);
                                        }
                                    }
                                    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
                                    // that causes it, under certain circumstances, to provide the same value for
                                    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
                                    // for more details.
                                    //
                                    // This also ensures a stable sort in V8 and other engines.
                                    // See https://code.google.com/p/v8/issues/detail?id=90 for more details.
                                    return object.index - other.index;
                                }

                                /**
                                 * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.
                                 *
                                 * @private
                                 * @param {string} letter The matched letter to deburr.
                                 * @returns {string} Returns the deburred letter.
                                 */
                                function deburrLetter(letter) {
                                    return deburredLetters[letter];
                                }

                                /**
                                 * Used by `_.escape` to convert characters to HTML entities.
                                 *
                                 * @private
                                 * @param {string} chr The matched character to escape.
                                 * @returns {string} Returns the escaped character.
                                 */
                                function escapeHtmlChar(chr) {
                                    return htmlEscapes[chr];
                                }

                                /**
                                 * Used by `_.escapeRegExp` to escape characters for inclusion in compiled regexes.
                                 *
                                 * @private
                                 * @param {string} chr The matched character to escape.
                                 * @param {string} leadingChar The capture group for a leading character.
                                 * @param {string} whitespaceChar The capture group for a whitespace character.
                                 * @returns {string} Returns the escaped character.
                                 */
                                function escapeRegExpChar(chr, leadingChar, whitespaceChar) {
                                    if (leadingChar) {
                                        chr = regexpEscapes[chr];
                                    } else if (whitespaceChar) {
                                        chr = stringEscapes[chr];
                                    }
                                    return '\\' + chr;
                                }

                                /**
                                 * Used by `_.template` to escape characters for inclusion in compiled string literals.
                                 *
                                 * @private
                                 * @param {string} chr The matched character to escape.
                                 * @returns {string} Returns the escaped character.
                                 */
                                function escapeStringChar(chr) {
                                    return '\\' + stringEscapes[chr];
                                }

                                /**
                                 * Gets the index at which the first occurrence of `NaN` is found in `array`.
                                 *
                                 * @private
                                 * @param {Array} array The array to search.
                                 * @param {number} fromIndex The index to search from.
                                 * @param {boolean} [fromRight] Specify iterating from right to left.
                                 * @returns {number} Returns the index of the matched `NaN`, else `-1`.
                                 */
                                function indexOfNaN(array, fromIndex, fromRight) {
                                    var length = array.length,
                                        index = fromIndex + (fromRight ? 0 : -1);

                                    while ((fromRight ? index-- : ++index < length)) {
                                        var other = array[index];
                                        if (other !== other) {
                                            return index;
                                        }
                                    }
                                    return -1;
                                }

                                /**
                                 * Checks if `value` is object-like.
                                 *
                                 * @private
                                 * @param {*} value The value to check.
                                 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
                                 */
                                function isObjectLike(value) {
                                    return !!value && typeof value == 'object';
                                }

                                /**
                                 * Used by `trimmedLeftIndex` and `trimmedRightIndex` to determine if a
                                 * character code is whitespace.
                                 *
                                 * @private
                                 * @param {number} charCode The character code to inspect.
                                 * @returns {boolean} Returns `true` if `charCode` is whitespace, else `false`.
                                 */
                                function isSpace(charCode) {
                                    return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 ||
                                        (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));
                                }

                                /**
                                 * Replaces all `placeholder` elements in `array` with an internal placeholder
                                 * and returns an array of their indexes.
                                 *
                                 * @private
                                 * @param {Array} array The array to modify.
                                 * @param {*} placeholder The placeholder to replace.
                                 * @returns {Array} Returns the new array of placeholder indexes.
                                 */
                                function replaceHolders(array, placeholder) {
                                    var index = -1,
                                        length = array.length,
                                        resIndex = -1,
                                        result = [];

                                    while (++index < length) {
                                        if (array[index] === placeholder) {
                                            array[index] = PLACEHOLDER;
                                            result[++resIndex] = index;
                                        }
                                    }
                                    return result;
                                }

                                /**
                                 * An implementation of `_.uniq` optimized for sorted arrays without support
                                 * for callback shorthands and `this` binding.
                                 *
                                 * @private
                                 * @param {Array} array The array to inspect.
                                 * @param {Function} [iteratee] The function invoked per iteration.
                                 * @returns {Array} Returns the new duplicate-value-free array.
                                 */
                                function sortedUniq(array, iteratee) {
                                    var seen,
                                        index = -1,
                                        length = array.length,
                                        resIndex = -1,
                                        result = [];

                                    while (++index < length) {
                                        var value = array[index],
                                            computed = iteratee ? iteratee(value, index, array) : value;

                                        if (!index || seen !== computed) {
                                            seen = computed;
                                            result[++resIndex] = value;
                                        }
                                    }
                                    return result;
                                }

                                /**
                                 * Used by `_.trim` and `_.trimLeft` to get the index of the first non-whitespace
                                 * character of `string`.
                                 *
                                 * @private
                                 * @param {string} string The string to inspect.
                                 * @returns {number} Returns the index of the first non-whitespace character.
                                 */
                                function trimmedLeftIndex(string) {
                                    var index = -1,
                                        length = string.length;

                                    while (++index < length && isSpace(string.charCodeAt(index))) {
                                    }
                                    return index;
                                }

                                /**
                                 * Used by `_.trim` and `_.trimRight` to get the index of the last non-whitespace
                                 * character of `string`.
                                 *
                                 * @private
                                 * @param {string} string The string to inspect.
                                 * @returns {number} Returns the index of the last non-whitespace character.
                                 */
                                function trimmedRightIndex(string) {
                                    var index = string.length;

                                    while (index-- && isSpace(string.charCodeAt(index))) {
                                    }
                                    return index;
                                }

                                /**
                                 * Used by `_.unescape` to convert HTML entities to characters.
                                 *
                                 * @private
                                 * @param {string} chr The matched character to unescape.
                                 * @returns {string} Returns the unescaped character.
                                 */
                                function unescapeHtmlChar(chr) {
                                    return htmlUnescapes[chr];
                                }

                                /*--------------------------------------------------------------------------*/

                                /**
                                 * Create a new pristine `lodash` function using the given `context` object.
                                 *
                                 * @static
                                 * @memberOf _
                                 * @category Utility
                                 * @param {Object} [context=root] The context object.
                                 * @returns {Function} Returns a new `lodash` function.
                                 * @example
                                 *
                                 * _.mixin({ 'foo': _.constant('foo') });
                                 *
                                 * var lodash = _.runInContext();
                                 * lodash.mixin({ 'bar': lodash.constant('bar') });
                                 *
                                 * _.isFunction(_.foo);
                                 * // => true
                                 * _.isFunction(_.bar);
                                 * // => false
                                 *
                                 * lodash.isFunction(lodash.foo);
                                 * // => false
                                 * lodash.isFunction(lodash.bar);
                                 * // => true
                                 *
                                 * // using `context` to mock `Date#getTime` use in `_.now`
                                 * var mock = _.runInContext({
   *   'Date': function() {
   *     return { 'getTime': getTimeMock };
   *   }
   * });
                                 *
                                 * // or creating a suped-up `defer` in Node.js
                                 * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
                                 */
                                function runInContext(context) {
                                    // Avoid issues with some ES3 environments that attempt to use values, named
                                    // after built-in constructors like `Object`, for the creation of literals.
                                    // ES5 clears this up by stating that literals must use built-in constructors.
                                    // See https://es5.github.io/#x11.1.5 for more details.
                                    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

                                    /** Native constructor references. */
                                    var Array = context.Array,
                                        Date = context.Date,
                                        Error = context.Error,
                                        Function = context.Function,
                                        Math = context.Math,
                                        Number = context.Number,
                                        Object = context.Object,
                                        RegExp = context.RegExp,
                                        String = context.String,
                                        TypeError = context.TypeError;

                                    /** Used for native method references. */
                                    var arrayProto = Array.prototype,
                                        objectProto = Object.prototype,
                                        stringProto = String.prototype;

                                    /** Used to resolve the decompiled source of functions. */
                                    var fnToString = Function.prototype.toString;

                                    /** Used to check objects for own properties. */
                                    var hasOwnProperty = objectProto.hasOwnProperty;

                                    /** Used to generate unique IDs. */
                                    var idCounter = 0;

                                    /**
                                     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
                                     * of values.
                                     */
                                    var objToString = objectProto.toString;

                                    /** Used to restore the original `_` reference in `_.noConflict`. */
                                    var oldDash = root._;

                                    /** Used to detect if a method is native. */
                                    var reIsNative = RegExp('^' +
                                        fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
                                            .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
                                    );

                                    /** Native method references. */
                                    var ArrayBuffer = context.ArrayBuffer,
                                        clearTimeout = context.clearTimeout,
                                        parseFloat = context.parseFloat,
                                        pow = Math.pow,
                                        propertyIsEnumerable = objectProto.propertyIsEnumerable,
                                        Set = getNative(context, 'Set'),
                                        setTimeout = context.setTimeout,
                                        splice = arrayProto.splice,
                                        Uint8Array = context.Uint8Array,
                                        WeakMap = getNative(context, 'WeakMap');

                                    /* Native method references for those with the same name as other `lodash` methods. */
                                    var nativeCeil = Math.ceil,
                                        nativeCreate = getNative(Object, 'create'),
                                        nativeFloor = Math.floor,
                                        nativeIsArray = getNative(Array, 'isArray'),
                                        nativeIsFinite = context.isFinite,
                                        nativeKeys = getNative(Object, 'keys'),
                                        nativeMax = Math.max,
                                        nativeMin = Math.min,
                                        nativeNow = getNative(Date, 'now'),
                                        nativeParseInt = context.parseInt,
                                        nativeRandom = Math.random;

                                    /** Used as references for `-Infinity` and `Infinity`. */
                                    var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,
                                        POSITIVE_INFINITY = Number.POSITIVE_INFINITY;

                                    /** Used as references for the maximum length and index of an array. */
                                    var MAX_ARRAY_LENGTH = 4294967295,
                                        MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
                                        HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

                                    /**
                                     * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
                                     * of an array-like value.
                                     */
                                    var MAX_SAFE_INTEGER = 9007199254740991;

                                    /** Used to store function metadata. */
                                    var metaMap = WeakMap && new WeakMap;

                                    /** Used to lookup unminified function names. */
                                    var realNames = {};

                                    /*------------------------------------------------------------------------*/

                                    /**
                                     * Creates a `lodash` object which wraps `value` to enable implicit chaining.
                                     * Methods that operate on and return arrays, collections, and functions can
                                     * be chained together. Methods that retrieve a single value or may return a
                                     * primitive value will automatically end the chain returning the unwrapped
                                     * value. Explicit chaining may be enabled using `_.chain`. The execution of
                                     * chained methods is lazy, that is, execution is deferred until `_#value`
                                     * is implicitly or explicitly called.
                                     *
                                     * Lazy evaluation allows several methods to support shortcut fusion. Shortcut
                                     * fusion is an optimization strategy which merge iteratee calls; this can help
                                     * to avoid the creation of intermediate data structures and greatly reduce the
                                     * number of iteratee executions.
                                     *
                                     * Chaining is supported in custom builds as long as the `_#value` method is
                                     * directly or indirectly included in the build.
                                     *
                                     * In addition to lodash methods, wrappers have `Array` and `String` methods.
                                     *
                                     * The wrapper `Array` methods are:
                                     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`,
                                     * `splice`, and `unshift`
                                     *
                                     * The wrapper `String` methods are:
                                     * `replace` and `split`
                                     *
                                     * The wrapper methods that support shortcut fusion are:
                                     * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,
                                     * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,
                                     * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,
                                     * and `where`
                                     *
                                     * The chainable wrapper methods are:
                                     * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,
                                     * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,
                                     * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defaultsDeep`,
                                     * `defer`, `delay`, `difference`, `drop`, `dropRight`, `dropRightWhile`,
                                     * `dropWhile`, `fill`, `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`,
                                     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
                                     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
                                     * `invoke`, `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`,
                                     * `matchesProperty`, `memoize`, `merge`, `method`, `methodOf`, `mixin`,
                                     * `modArgs`, `negate`, `omit`, `once`, `pairs`, `partial`, `partialRight`,
                                     * `partition`, `pick`, `plant`, `pluck`, `property`, `propertyOf`, `pull`,
                                     * `pullAt`, `push`, `range`, `rearg`, `reject`, `remove`, `rest`, `restParam`,
                                     * `reverse`, `set`, `shuffle`, `slice`, `sort`, `sortBy`, `sortByAll`,
                                     * `sortByOrder`, `splice`, `spread`, `take`, `takeRight`, `takeRightWhile`,
                                     * `takeWhile`, `tap`, `throttle`, `thru`, `times`, `toArray`, `toPlainObject`,
                                     * `transform`, `union`, `uniq`, `unshift`, `unzip`, `unzipWith`, `values`,
                                     * `valuesIn`, `where`, `without`, `wrap`, `xor`, `zip`, `zipObject`, `zipWith`
                                     *
                                     * The wrapper methods that are **not** chainable by default are:
                                     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clone`, `cloneDeep`,
                                     * `deburr`, `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`,
                                     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`,
                                     * `floor`, `get`, `gt`, `gte`, `has`, `identity`, `includes`, `indexOf`,
                                     * `inRange`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
                                     * `isEmpty`, `isEqual`, `isError`, `isFinite` `isFunction`, `isMatch`,
                                     * `isNative`, `isNaN`, `isNull`, `isNumber`, `isObject`, `isPlainObject`,
                                     * `isRegExp`, `isString`, `isUndefined`, `isTypedArray`, `join`, `kebabCase`,
                                     * `last`, `lastIndexOf`, `lt`, `lte`, `max`, `min`, `noConflict`, `noop`,
                                     * `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`, `random`, `reduce`,
                                     * `reduceRight`, `repeat`, `result`, `round`, `runInContext`, `shift`, `size`,
                                     * `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`, `startCase`,
                                     * `startsWith`, `sum`, `template`, `trim`, `trimLeft`, `trimRight`, `trunc`,
                                     * `unescape`, `uniqueId`, `value`, and `words`
                                     *
                                     * The wrapper method `sample` will return a wrapped value when `n` is provided,
                                     * otherwise an unwrapped value is returned.
                                     *
                                     * @name _
                                     * @constructor
                                     * @category Chain
                                     * @param {*} value The value to wrap in a `lodash` instance.
                                     * @returns {Object} Returns the new `lodash` wrapper instance.
                                     * @example
                                     *
                                     * var wrapped = _([1, 2, 3]);
                                     *
                                     * // returns an unwrapped value
                                     * wrapped.reduce(function(total, n) {
     *   return total + n;
     * });
                                     * // => 6
                                     *
                                     * // returns a wrapped value
                                     * var squares = wrapped.map(function(n) {
     *   return n * n;
     * });
                                     *
                                     * _.isArray(squares);
                                     * // => false
                                     *
                                     * _.isArray(squares.value());
                                     * // => true
                                     */
                                    function lodash(value) {
                                        if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
                                            if (value instanceof LodashWrapper) {
                                                return value;
                                            }
                                            if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
                                                return wrapperClone(value);
                                            }
                                        }
                                        return new LodashWrapper(value);
                                    }

                                    /**
                                     * The function whose prototype all chaining wrappers inherit from.
                                     *
                                     * @private
                                     */
                                    function baseLodash() {
                                        // No operation performed.
                                    }

                                    /**
                                     * The base constructor for creating `lodash` wrapper objects.
                                     *
                                     * @private
                                     * @param {*} value The value to wrap.
                                     * @param {boolean} [chainAll] Enable chaining for all wrapper methods.
                                     * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.
                                     */
                                    function LodashWrapper(value, chainAll, actions) {
                                        this.__wrapped__ = value;
                                        this.__actions__ = actions || [];
                                        this.__chain__ = !!chainAll;
                                    }

                                    /**
                                     * An object environment feature flags.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @type Object
                                     */
                                    var support = lodash.support = {};

                                    /**
                                     * By default, the template delimiters used by lodash are like those in
                                     * embedded Ruby (ERB). Change the following template settings to use
                                     * alternative delimiters.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @type Object
                                     */
                                    lodash.templateSettings = {

                                        /**
                                         * Used to detect `data` property values to be HTML-escaped.
                                         *
                                         * @memberOf _.templateSettings
                                         * @type RegExp
                                         */
                                        'escape': reEscape,

                                        /**
                                         * Used to detect code to be evaluated.
                                         *
                                         * @memberOf _.templateSettings
                                         * @type RegExp
                                         */
                                        'evaluate': reEvaluate,

                                        /**
                                         * Used to detect `data` property values to inject.
                                         *
                                         * @memberOf _.templateSettings
                                         * @type RegExp
                                         */
                                        'interpolate': reInterpolate,

                                        /**
                                         * Used to reference the data object in the template text.
                                         *
                                         * @memberOf _.templateSettings
                                         * @type string
                                         */
                                        'variable': '',

                                        /**
                                         * Used to import variables into the compiled template.
                                         *
                                         * @memberOf _.templateSettings
                                         * @type Object
                                         */
                                        'imports': {

                                            /**
                                             * A reference to the `lodash` function.
                                             *
                                             * @memberOf _.templateSettings.imports
                                             * @type Function
                                             */
                                            '_': lodash
                                        }
                                    };

                                    /*------------------------------------------------------------------------*/

                                    /**
                                     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
                                     *
                                     * @private
                                     * @param {*} value The value to wrap.
                                     */
                                    function LazyWrapper(value) {
                                        this.__wrapped__ = value;
                                        this.__actions__ = [];
                                        this.__dir__ = 1;
                                        this.__filtered__ = false;
                                        this.__iteratees__ = [];
                                        this.__takeCount__ = POSITIVE_INFINITY;
                                        this.__views__ = [];
                                    }

                                    /**
                                     * Creates a clone of the lazy wrapper object.
                                     *
                                     * @private
                                     * @name clone
                                     * @memberOf LazyWrapper
                                     * @returns {Object} Returns the cloned `LazyWrapper` object.
                                     */
                                    function lazyClone() {
                                        var result = new LazyWrapper(this.__wrapped__);
                                        result.__actions__ = arrayCopy(this.__actions__);
                                        result.__dir__ = this.__dir__;
                                        result.__filtered__ = this.__filtered__;
                                        result.__iteratees__ = arrayCopy(this.__iteratees__);
                                        result.__takeCount__ = this.__takeCount__;
                                        result.__views__ = arrayCopy(this.__views__);
                                        return result;
                                    }

                                    /**
                                     * Reverses the direction of lazy iteration.
                                     *
                                     * @private
                                     * @name reverse
                                     * @memberOf LazyWrapper
                                     * @returns {Object} Returns the new reversed `LazyWrapper` object.
                                     */
                                    function lazyReverse() {
                                        if (this.__filtered__) {
                                            var result = new LazyWrapper(this);
                                            result.__dir__ = -1;
                                            result.__filtered__ = true;
                                        } else {
                                            result = this.clone();
                                            result.__dir__ *= -1;
                                        }
                                        return result;
                                    }

                                    /**
                                     * Extracts the unwrapped value from its lazy wrapper.
                                     *
                                     * @private
                                     * @name value
                                     * @memberOf LazyWrapper
                                     * @returns {*} Returns the unwrapped value.
                                     */
                                    function lazyValue() {
                                        var array = this.__wrapped__.value(),
                                            dir = this.__dir__,
                                            isArr = isArray(array),
                                            isRight = dir < 0,
                                            arrLength = isArr ? array.length : 0,
                                            view = getView(0, arrLength, this.__views__),
                                            start = view.start,
                                            end = view.end,
                                            length = end - start,
                                            index = isRight ? end : (start - 1),
                                            iteratees = this.__iteratees__,
                                            iterLength = iteratees.length,
                                            resIndex = 0,
                                            takeCount = nativeMin(length, this.__takeCount__);

                                        if (!isArr || arrLength < LARGE_ARRAY_SIZE || (arrLength == length && takeCount == length)) {
                                            return baseWrapperValue((isRight && isArr) ? array.reverse() : array, this.__actions__);
                                        }
                                        var result = [];

                                        outer:
                                            while (length-- && resIndex < takeCount) {
                                                index += dir;

                                                var iterIndex = -1,
                                                    value = array[index];

                                                while (++iterIndex < iterLength) {
                                                    var data = iteratees[iterIndex],
                                                        iteratee = data.iteratee,
                                                        type = data.type,
                                                        computed = iteratee(value);

                                                    if (type == LAZY_MAP_FLAG) {
                                                        value = computed;
                                                    } else if (!computed) {
                                                        if (type == LAZY_FILTER_FLAG) {
                                                            continue outer;
                                                        } else {
                                                            break outer;
                                                        }
                                                    }
                                                }
                                                result[resIndex++] = value;
                                            }
                                        return result;
                                    }

                                    /*------------------------------------------------------------------------*/

                                    /**
                                     * Creates a cache object to store key/value pairs.
                                     *
                                     * @private
                                     * @static
                                     * @name Cache
                                     * @memberOf _.memoize
                                     */
                                    function MapCache() {
                                        this.__data__ = {};
                                    }

                                    /**
                                     * Removes `key` and its value from the cache.
                                     *
                                     * @private
                                     * @name delete
                                     * @memberOf _.memoize.Cache
                                     * @param {string} key The key of the value to remove.
                                     * @returns {boolean} Returns `true` if the entry was removed successfully, else `false`.
                                     */
                                    function mapDelete(key) {
                                        return this.has(key) && delete this.__data__[key];
                                    }

                                    /**
                                     * Gets the cached value for `key`.
                                     *
                                     * @private
                                     * @name get
                                     * @memberOf _.memoize.Cache
                                     * @param {string} key The key of the value to get.
                                     * @returns {*} Returns the cached value.
                                     */
                                    function mapGet(key) {
                                        return key == '__proto__' ? undefined : this.__data__[key];
                                    }

                                    /**
                                     * Checks if a cached value for `key` exists.
                                     *
                                     * @private
                                     * @name has
                                     * @memberOf _.memoize.Cache
                                     * @param {string} key The key of the entry to check.
                                     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                                     */
                                    function mapHas(key) {
                                        return key != '__proto__' && hasOwnProperty.call(this.__data__, key);
                                    }

                                    /**
                                     * Sets `value` to `key` of the cache.
                                     *
                                     * @private
                                     * @name set
                                     * @memberOf _.memoize.Cache
                                     * @param {string} key The key of the value to cache.
                                     * @param {*} value The value to cache.
                                     * @returns {Object} Returns the cache object.
                                     */
                                    function mapSet(key, value) {
                                        if (key != '__proto__') {
                                            this.__data__[key] = value;
                                        }
                                        return this;
                                    }

                                    /*------------------------------------------------------------------------*/

                                    /**
                                     *
                                     * Creates a cache object to store unique values.
                                     *
                                     * @private
                                     * @param {Array} [values] The values to cache.
                                     */
                                    function SetCache(values) {
                                        var length = values ? values.length : 0;

                                        this.data = {'hash': nativeCreate(null), 'set': new Set};
                                        while (length--) {
                                            this.push(values[length]);
                                        }
                                    }

                                    /**
                                     * Checks if `value` is in `cache` mimicking the return signature of
                                     * `_.indexOf` by returning `0` if the value is found, else `-1`.
                                     *
                                     * @private
                                     * @param {Object} cache The cache to search.
                                     * @param {*} value The value to search for.
                                     * @returns {number} Returns `0` if `value` is found, else `-1`.
                                     */
                                    function cacheIndexOf(cache, value) {
                                        var data = cache.data,
                                            result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];

                                        return result ? 0 : -1;
                                    }

                                    /**
                                     * Adds `value` to the cache.
                                     *
                                     * @private
                                     * @name push
                                     * @memberOf SetCache
                                     * @param {*} value The value to cache.
                                     */
                                    function cachePush(value) {
                                        var data = this.data;
                                        if (typeof value == 'string' || isObject(value)) {
                                            data.set.add(value);
                                        } else {
                                            data.hash[value] = true;
                                        }
                                    }

                                    /*------------------------------------------------------------------------*/

                                    /**
                                     * Creates a new array joining `array` with `other`.
                                     *
                                     * @private
                                     * @param {Array} array The array to join.
                                     * @param {Array} other The other array to join.
                                     * @returns {Array} Returns the new concatenated array.
                                     */
                                    function arrayConcat(array, other) {
                                        var index = -1,
                                            length = array.length,
                                            othIndex = -1,
                                            othLength = other.length,
                                            result = Array(length + othLength);

                                        while (++index < length) {
                                            result[index] = array[index];
                                        }
                                        while (++othIndex < othLength) {
                                            result[index++] = other[othIndex];
                                        }
                                        return result;
                                    }

                                    /**
                                     * Copies the values of `source` to `array`.
                                     *
                                     * @private
                                     * @param {Array} source The array to copy values from.
                                     * @param {Array} [array=[]] The array to copy values to.
                                     * @returns {Array} Returns `array`.
                                     */
                                    function arrayCopy(source, array) {
                                        var index = -1,
                                            length = source.length;

                                        array || (array = Array(length));
                                        while (++index < length) {
                                            array[index] = source[index];
                                        }
                                        return array;
                                    }

                                    /**
                                     * A specialized version of `_.forEach` for arrays without support for callback
                                     * shorthands and `this` binding.
                                     *
                                     * @private
                                     * @param {Array} array The array to iterate over.
                                     * @param {Function} iteratee The function invoked per iteration.
                                     * @returns {Array} Returns `array`.
                                     */
                                    function arrayEach(array, iteratee) {
                                        var index = -1,
                                            length = array.length;

                                        while (++index < length) {
                                            if (iteratee(array[index], index, array) === false) {
                                                break;
                                            }
                                        }
                                        return array;
                                    }

                                    /**
                                     * A specialized version of `_.forEachRight` for arrays without support for
                                     * callback shorthands and `this` binding.
                                     *
                                     * @private
                                     * @param {Array} array The array to iterate over.
                                     * @param {Function} iteratee The function invoked per iteration.
                                     * @returns {Array} Returns `array`.
                                     */
                                    function arrayEachRight(array, iteratee) {
                                        var length = array.length;

                                        while (length--) {
                                            if (iteratee(array[length], length, array) === false) {
                                                break;
                                            }
                                        }
                                        return array;
                                    }

                                    /**
                                     * A specialized version of `_.every` for arrays without support for callback
                                     * shorthands and `this` binding.
                                     *
                                     * @private
                                     * @param {Array} array The array to iterate over.
                                     * @param {Function} predicate The function invoked per iteration.
                                     * @returns {boolean} Returns `true` if all elements pass the predicate check,
                                     *  else `false`.
                                     */
                                    function arrayEvery(array, predicate) {
                                        var index = -1,
                                            length = array.length;

                                        while (++index < length) {
                                            if (!predicate(array[index], index, array)) {
                                                return false;
                                            }
                                        }
                                        return true;
                                    }

                                    /**
                                     * A specialized version of `baseExtremum` for arrays which invokes `iteratee`
                                     * with one argument: (value).
                                     *
                                     * @private
                                     * @param {Array} array The array to iterate over.
                                     * @param {Function} iteratee The function invoked per iteration.
                                     * @param {Function} comparator The function used to compare values.
                                     * @param {*} exValue The initial extremum value.
                                     * @returns {*} Returns the extremum value.
                                     */
                                    function arrayExtremum(array, iteratee, comparator, exValue) {
                                        var index = -1,
                                            length = array.length,
                                            computed = exValue,
                                            result = computed;

                                        while (++index < length) {
                                            var value = array[index],
                                                current = +iteratee(value);

                                            if (comparator(current, computed)) {
                                                computed = current;
                                                result = value;
                                            }
                                        }
                                        return result;
                                    }

                                    /**
                                     * A specialized version of `_.filter` for arrays without support for callback
                                     * shorthands and `this` binding.
                                     *
                                     * @private
                                     * @param {Array} array The array to iterate over.
                                     * @param {Function} predicate The function invoked per iteration.
                                     * @returns {Array} Returns the new filtered array.
                                     */
                                    function arrayFilter(array, predicate) {
                                        var index = -1,
                                            length = array.length,
                                            resIndex = -1,
                                            result = [];

                                        while (++index < length) {
                                            var value = array[index];
                                            if (predicate(value, index, array)) {
                                                result[++resIndex] = value;
                                            }
                                        }
                                        return result;
                                    }

                                    /**
                                     * A specialized version of `_.map` for arrays without support for callback
                                     * shorthands and `this` binding.
                                     *
                                     * @private
                                     * @param {Array} array The array to iterate over.
                                     * @param {Function} iteratee The function invoked per iteration.
                                     * @returns {Array} Returns the new mapped array.
                                     */
                                    function arrayMap(array, iteratee) {
                                        var index = -1,
                                            length = array.length,
                                            result = Array(length);

                                        while (++index < length) {
                                            result[index] = iteratee(array[index], index, array);
                                        }
                                        return result;
                                    }

                                    /**
                                     * Appends the elements of `values` to `array`.
                                     *
                                     * @private
                                     * @param {Array} array The array to modify.
                                     * @param {Array} values The values to append.
                                     * @returns {Array} Returns `array`.
                                     */
                                    function arrayPush(array, values) {
                                        var index = -1,
                                            length = values.length,
                                            offset = array.length;

                                        while (++index < length) {
                                            array[offset + index] = values[index];
                                        }
                                        return array;
                                    }

                                    /**
                                     * A specialized version of `_.reduce` for arrays without support for callback
                                     * shorthands and `this` binding.
                                     *
                                     * @private
                                     * @param {Array} array The array to iterate over.
                                     * @param {Function} iteratee The function invoked per iteration.
                                     * @param {*} [accumulator] The initial value.
                                     * @param {boolean} [initFromArray] Specify using the first element of `array`
                                     *  as the initial value.
                                     * @returns {*} Returns the accumulated value.
                                     */
                                    function arrayReduce(array, iteratee, accumulator, initFromArray) {
                                        var index = -1,
                                            length = array.length;

                                        if (initFromArray && length) {
                                            accumulator = array[++index];
                                        }
                                        while (++index < length) {
                                            accumulator = iteratee(accumulator, array[index], index, array);
                                        }
                                        return accumulator;
                                    }

                                    /**
                                     * A specialized version of `_.reduceRight` for arrays without support for
                                     * callback shorthands and `this` binding.
                                     *
                                     * @private
                                     * @param {Array} array The array to iterate over.
                                     * @param {Function} iteratee The function invoked per iteration.
                                     * @param {*} [accumulator] The initial value.
                                     * @param {boolean} [initFromArray] Specify using the last element of `array`
                                     *  as the initial value.
                                     * @returns {*} Returns the accumulated value.
                                     */
                                    function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
                                        var length = array.length;
                                        if (initFromArray && length) {
                                            accumulator = array[--length];
                                        }
                                        while (length--) {
                                            accumulator = iteratee(accumulator, array[length], length, array);
                                        }
                                        return accumulator;
                                    }

                                    /**
                                     * A specialized version of `_.some` for arrays without support for callback
                                     * shorthands and `this` binding.
                                     *
                                     * @private
                                     * @param {Array} array The array to iterate over.
                                     * @param {Function} predicate The function invoked per iteration.
                                     * @returns {boolean} Returns `true` if any element passes the predicate check,
                                     *  else `false`.
                                     */
                                    function arraySome(array, predicate) {
                                        var index = -1,
                                            length = array.length;

                                        while (++index < length) {
                                            if (predicate(array[index], index, array)) {
                                                return true;
                                            }
                                        }
                                        return false;
                                    }

                                    /**
                                     * A specialized version of `_.sum` for arrays without support for callback
                                     * shorthands and `this` binding..
                                     *
                                     * @private
                                     * @param {Array} array The array to iterate over.
                                     * @param {Function} iteratee The function invoked per iteration.
                                     * @returns {number} Returns the sum.
                                     */
                                    function arraySum(array, iteratee) {
                                        var length = array.length,
                                            result = 0;

                                        while (length--) {
                                            result += +iteratee(array[length]) || 0;
                                        }
                                        return result;
                                    }

                                    /**
                                     * Used by `_.defaults` to customize its `_.assign` use.
                                     *
                                     * @private
                                     * @param {*} objectValue The destination object property value.
                                     * @param {*} sourceValue The source object property value.
                                     * @returns {*} Returns the value to assign to the destination object.
                                     */
                                    function assignDefaults(objectValue, sourceValue) {
                                        return objectValue === undefined ? sourceValue : objectValue;
                                    }

                                    /**
                                     * Used by `_.template` to customize its `_.assign` use.
                                     *
                                     * **Note:** This function is like `assignDefaults` except that it ignores
                                     * inherited property values when checking if a property is `undefined`.
                                     *
                                     * @private
                                     * @param {*} objectValue The destination object property value.
                                     * @param {*} sourceValue The source object property value.
                                     * @param {string} key The key associated with the object and source values.
                                     * @param {Object} object The destination object.
                                     * @returns {*} Returns the value to assign to the destination object.
                                     */
                                    function assignOwnDefaults(objectValue, sourceValue, key, object) {
                                        return (objectValue === undefined || !hasOwnProperty.call(object, key))
                                            ? sourceValue
                                            : objectValue;
                                    }

                                    /**
                                     * A specialized version of `_.assign` for customizing assigned values without
                                     * support for argument juggling, multiple sources, and `this` binding `customizer`
                                     * functions.
                                     *
                                     * @private
                                     * @param {Object} object The destination object.
                                     * @param {Object} source The source object.
                                     * @param {Function} customizer The function to customize assigned values.
                                     * @returns {Object} Returns `object`.
                                     */
                                    function assignWith(object, source, customizer) {
                                        var index = -1,
                                            props = keys(source),
                                            length = props.length;

                                        while (++index < length) {
                                            var key = props[index],
                                                value = object[key],
                                                result = customizer(value, source[key], key, object, source);

                                            if ((result === result ? (result !== value) : (value === value)) ||
                                                (value === undefined && !(key in object))) {
                                                object[key] = result;
                                            }
                                        }
                                        return object;
                                    }

                                    /**
                                     * The base implementation of `_.assign` without support for argument juggling,
                                     * multiple sources, and `customizer` functions.
                                     *
                                     * @private
                                     * @param {Object} object The destination object.
                                     * @param {Object} source The source object.
                                     * @returns {Object} Returns `object`.
                                     */
                                    function baseAssign(object, source) {
                                        return source == null
                                            ? object
                                            : baseCopy(source, keys(source), object);
                                    }

                                    /**
                                     * The base implementation of `_.at` without support for string collections
                                     * and individual key arguments.
                                     *
                                     * @private
                                     * @param {Array|Object} collection The collection to iterate over.
                                     * @param {number[]|string[]} props The property names or indexes of elements to pick.
                                     * @returns {Array} Returns the new array of picked elements.
                                     */
                                    function baseAt(collection, props) {
                                        var index = -1,
                                            isNil = collection == null,
                                            isArr = !isNil && isArrayLike(collection),
                                            length = isArr ? collection.length : 0,
                                            propsLength = props.length,
                                            result = Array(propsLength);

                                        while (++index < propsLength) {
                                            var key = props[index];
                                            if (isArr) {
                                                result[index] = isIndex(key, length) ? collection[key] : undefined;
                                            } else {
                                                result[index] = isNil ? undefined : collection[key];
                                            }
                                        }
                                        return result;
                                    }

                                    /**
                                     * Copies properties of `source` to `object`.
                                     *
                                     * @private
                                     * @param {Object} source The object to copy properties from.
                                     * @param {Array} props The property names to copy.
                                     * @param {Object} [object={}] The object to copy properties to.
                                     * @returns {Object} Returns `object`.
                                     */
                                    function baseCopy(source, props, object) {
                                        object || (object = {});

                                        var index = -1,
                                            length = props.length;

                                        while (++index < length) {
                                            var key = props[index];
                                            object[key] = source[key];
                                        }
                                        return object;
                                    }

                                    /**
                                     * The base implementation of `_.callback` which supports specifying the
                                     * number of arguments to provide to `func`.
                                     *
                                     * @private
                                     * @param {*} [func=_.identity] The value to convert to a callback.
                                     * @param {*} [thisArg] The `this` binding of `func`.
                                     * @param {number} [argCount] The number of arguments to provide to `func`.
                                     * @returns {Function} Returns the callback.
                                     */
                                    function baseCallback(func, thisArg, argCount) {
                                        var type = typeof func;
                                        if (type == 'function') {
                                            return thisArg === undefined
                                                ? func
                                                : bindCallback(func, thisArg, argCount);
                                        }
                                        if (func == null) {
                                            return identity;
                                        }
                                        if (type == 'object') {
                                            return baseMatches(func);
                                        }
                                        return thisArg === undefined
                                            ? property(func)
                                            : baseMatchesProperty(func, thisArg);
                                    }

                                    /**
                                     * The base implementation of `_.clone` without support for argument juggling
                                     * and `this` binding `customizer` functions.
                                     *
                                     * @private
                                     * @param {*} value The value to clone.
                                     * @param {boolean} [isDeep] Specify a deep clone.
                                     * @param {Function} [customizer] The function to customize cloning values.
                                     * @param {string} [key] The key of `value`.
                                     * @param {Object} [object] The object `value` belongs to.
                                     * @param {Array} [stackA=[]] Tracks traversed source objects.
                                     * @param {Array} [stackB=[]] Associates clones with source counterparts.
                                     * @returns {*} Returns the cloned value.
                                     */
                                    function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
                                        var result;
                                        if (customizer) {
                                            result = object ? customizer(value, key, object) : customizer(value);
                                        }
                                        if (result !== undefined) {
                                            return result;
                                        }
                                        if (!isObject(value)) {
                                            return value;
                                        }
                                        var isArr = isArray(value);
                                        if (isArr) {
                                            result = initCloneArray(value);
                                            if (!isDeep) {
                                                return arrayCopy(value, result);
                                            }
                                        } else {
                                            var tag = objToString.call(value),
                                                isFunc = tag == funcTag;

                                            if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
                                                result = initCloneObject(isFunc ? {} : value);
                                                if (!isDeep) {
                                                    return baseAssign(result, value);
                                                }
                                            } else {
                                                return cloneableTags[tag]
                                                    ? initCloneByTag(value, tag, isDeep)
                                                    : (object ? value : {});
                                            }
                                        }
                                        // Check for circular references and return its corresponding clone.
                                        stackA || (stackA = []);
                                        stackB || (stackB = []);

                                        var length = stackA.length;
                                        while (length--) {
                                            if (stackA[length] == value) {
                                                return stackB[length];
                                            }
                                        }
                                        // Add the source value to the stack of traversed objects and associate it with its clone.
                                        stackA.push(value);
                                        stackB.push(result);

                                        // Recursively populate clone (susceptible to call stack limits).
                                        (isArr ? arrayEach : baseForOwn)(value, function (subValue, key) {
                                            result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
                                        });
                                        return result;
                                    }

                                    /**
                                     * The base implementation of `_.create` without support for assigning
                                     * properties to the created object.
                                     *
                                     * @private
                                     * @param {Object} prototype The object to inherit from.
                                     * @returns {Object} Returns the new object.
                                     */
                                    var baseCreate = (function () {
                                        function object() {
                                        }

                                        return function (prototype) {
                                            if (isObject(prototype)) {
                                                object.prototype = prototype;
                                                var result = new object;
                                                object.prototype = undefined;
                                            }
                                            return result || {};
                                        };
                                    }());

                                    /**
                                     * The base implementation of `_.delay` and `_.defer` which accepts an index
                                     * of where to slice the arguments to provide to `func`.
                                     *
                                     * @private
                                     * @param {Function} func The function to delay.
                                     * @param {number} wait The number of milliseconds to delay invocation.
                                     * @param {Object} args The arguments provide to `func`.
                                     * @returns {number} Returns the timer id.
                                     */
                                    function baseDelay(func, wait, args) {
                                        if (typeof func != 'function') {
                                            throw new TypeError(FUNC_ERROR_TEXT);
                                        }
                                        return setTimeout(function () {
                                            func.apply(undefined, args);
                                        }, wait);
                                    }

                                    /**
                                     * The base implementation of `_.difference` which accepts a single array
                                     * of values to exclude.
                                     *
                                     * @private
                                     * @param {Array} array The array to inspect.
                                     * @param {Array} values The values to exclude.
                                     * @returns {Array} Returns the new array of filtered values.
                                     */
                                    function baseDifference(array, values) {
                                        var length = array ? array.length : 0,
                                            result = [];

                                        if (!length) {
                                            return result;
                                        }
                                        var index = -1,
                                            indexOf = getIndexOf(),
                                            isCommon = indexOf == baseIndexOf,
                                            cache = (isCommon && values.length >= LARGE_ARRAY_SIZE) ? createCache(values) : null,
                                            valuesLength = values.length;

                                        if (cache) {
                                            indexOf = cacheIndexOf;
                                            isCommon = false;
                                            values = cache;
                                        }
                                        outer:
                                            while (++index < length) {
                                                var value = array[index];

                                                if (isCommon && value === value) {
                                                    var valuesIndex = valuesLength;
                                                    while (valuesIndex--) {
                                                        if (values[valuesIndex] === value) {
                                                            continue outer;
                                                        }
                                                    }
                                                    result.push(value);
                                                }
                                                else if (indexOf(values, value, 0) < 0) {
                                                    result.push(value);
                                                }
                                            }
                                        return result;
                                    }

                                    /**
                                     * The base implementation of `_.forEach` without support for callback
                                     * shorthands and `this` binding.
                                     *
                                     * @private
                                     * @param {Array|Object|string} collection The collection to iterate over.
                                     * @param {Function} iteratee The function invoked per iteration.
                                     * @returns {Array|Object|string} Returns `collection`.
                                     */
                                    var baseEach = createBaseEach(baseForOwn);

                                    /**
                                     * The base implementation of `_.forEachRight` without support for callback
                                     * shorthands and `this` binding.
                                     *
                                     * @private
                                     * @param {Array|Object|string} collection The collection to iterate over.
                                     * @param {Function} iteratee The function invoked per iteration.
                                     * @returns {Array|Object|string} Returns `collection`.
                                     */
                                    var baseEachRight = createBaseEach(baseForOwnRight, true);

                                    /**
                                     * The base implementation of `_.every` without support for callback
                                     * shorthands and `this` binding.
                                     *
                                     * @private
                                     * @param {Array|Object|string} collection The collection to iterate over.
                                     * @param {Function} predicate The function invoked per iteration.
                                     * @returns {boolean} Returns `true` if all elements pass the predicate check,
                                     *  else `false`
                                     */
                                    function baseEvery(collection, predicate) {
                                        var result = true;
                                        baseEach(collection, function (value, index, collection) {
                                            result = !!predicate(value, index, collection);
                                            return result;
                                        });
                                        return result;
                                    }

                                    /**
                                     * Gets the extremum value of `collection` invoking `iteratee` for each value
                                     * in `collection` to generate the criterion by which the value is ranked.
                                     * The `iteratee` is invoked with three arguments: (value, index|key, collection).
                                     *
                                     * @private
                                     * @param {Array|Object|string} collection The collection to iterate over.
                                     * @param {Function} iteratee The function invoked per iteration.
                                     * @param {Function} comparator The function used to compare values.
                                     * @param {*} exValue The initial extremum value.
                                     * @returns {*} Returns the extremum value.
                                     */
                                    function baseExtremum(collection, iteratee, comparator, exValue) {
                                        var computed = exValue,
                                            result = computed;

                                        baseEach(collection, function (value, index, collection) {
                                            var current = +iteratee(value, index, collection);
                                            if (comparator(current, computed) || (current === exValue && current === result)) {
                                                computed = current;
                                                result = value;
                                            }
                                        });
                                        return result;
                                    }

                                    /**
                                     * The base implementation of `_.fill` without an iteratee call guard.
                                     *
                                     * @private
                                     * @param {Array} array The array to fill.
                                     * @param {*} value The value to fill `array` with.
                                     * @param {number} [start=0] The start position.
                                     * @param {number} [end=array.length] The end position.
                                     * @returns {Array} Returns `array`.
                                     */
                                    function baseFill(array, value, start, end) {
                                        var length = array.length;

                                        start = start == null ? 0 : (+start || 0);
                                        if (start < 0) {
                                            start = -start > length ? 0 : (length + start);
                                        }
                                        end = (end === undefined || end > length) ? length : (+end || 0);
                                        if (end < 0) {
                                            end += length;
                                        }
                                        length = start > end ? 0 : (end >>> 0);
                                        start >>>= 0;

                                        while (start < length) {
                                            array[start++] = value;
                                        }
                                        return array;
                                    }

                                    /**
                                     * The base implementation of `_.filter` without support for callback
                                     * shorthands and `this` binding.
                                     *
                                     * @private
                                     * @param {Array|Object|string} collection The collection to iterate over.
                                     * @param {Function} predicate The function invoked per iteration.
                                     * @returns {Array} Returns the new filtered array.
                                     */
                                    function baseFilter(collection, predicate) {
                                        var result = [];
                                        baseEach(collection, function (value, index, collection) {
                                            if (predicate(value, index, collection)) {
                                                result.push(value);
                                            }
                                        });
                                        return result;
                                    }

                                    /**
                                     * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,
                                     * without support for callback shorthands and `this` binding, which iterates
                                     * over `collection` using the provided `eachFunc`.
                                     *
                                     * @private
                                     * @param {Array|Object|string} collection The collection to search.
                                     * @param {Function} predicate The function invoked per iteration.
                                     * @param {Function} eachFunc The function to iterate over `collection`.
                                     * @param {boolean} [retKey] Specify returning the key of the found element
                                     *  instead of the element itself.
                                     * @returns {*} Returns the found element or its key, else `undefined`.
                                     */
                                    function baseFind(collection, predicate, eachFunc, retKey) {
                                        var result;
                                        eachFunc(collection, function (value, key, collection) {
                                            if (predicate(value, key, collection)) {
                                                result = retKey ? key : value;
                                                return false;
                                            }
                                        });
                                        return result;
                                    }

                                    /**
                                     * The base implementation of `_.flatten` with added support for restricting
                                     * flattening and specifying the start index.
                                     *
                                     * @private
                                     * @param {Array} array The array to flatten.
                                     * @param {boolean} [isDeep] Specify a deep flatten.
                                     * @param {boolean} [isStrict] Restrict flattening to arrays-like objects.
                                     * @param {Array} [result=[]] The initial result value.
                                     * @returns {Array} Returns the new flattened array.
                                     */
                                    function baseFlatten(array, isDeep, isStrict, result) {
                                        result || (result = []);

                                        var index = -1,
                                            length = array.length;

                                        while (++index < length) {
                                            var value = array[index];
                                            if (isObjectLike(value) && isArrayLike(value) &&
                                                (isStrict || isArray(value) || isArguments(value))) {
                                                if (isDeep) {
                                                    // Recursively flatten arrays (susceptible to call stack limits).
                                                    baseFlatten(value, isDeep, isStrict, result);
                                                } else {
                                                    arrayPush(result, value);
                                                }
                                            } else if (!isStrict) {
                                                result[result.length] = value;
                                            }
                                        }
                                        return result;
                                    }

                                    /**
                                     * The base implementation of `baseForIn` and `baseForOwn` which iterates
                                     * over `object` properties returned by `keysFunc` invoking `iteratee` for
                                     * each property. Iteratee functions may exit iteration early by explicitly
                                     * returning `false`.
                                     *
                                     * @private
                                     * @param {Object} object The object to iterate over.
                                     * @param {Function} iteratee The function invoked per iteration.
                                     * @param {Function} keysFunc The function to get the keys of `object`.
                                     * @returns {Object} Returns `object`.
                                     */
                                    var baseFor = createBaseFor();

                                    /**
                                     * This function is like `baseFor` except that it iterates over properties
                                     * in the opposite order.
                                     *
                                     * @private
                                     * @param {Object} object The object to iterate over.
                                     * @param {Function} iteratee The function invoked per iteration.
                                     * @param {Function} keysFunc The function to get the keys of `object`.
                                     * @returns {Object} Returns `object`.
                                     */
                                    var baseForRight = createBaseFor(true);

                                    /**
                                     * The base implementation of `_.forIn` without support for callback
                                     * shorthands and `this` binding.
                                     *
                                     * @private
                                     * @param {Object} object The object to iterate over.
                                     * @param {Function} iteratee The function invoked per iteration.
                                     * @returns {Object} Returns `object`.
                                     */
                                    function baseForIn(object, iteratee) {
                                        return baseFor(object, iteratee, keysIn);
                                    }

                                    /**
                                     * The base implementation of `_.forOwn` without support for callback
                                     * shorthands and `this` binding.
                                     *
                                     * @private
                                     * @param {Object} object The object to iterate over.
                                     * @param {Function} iteratee The function invoked per iteration.
                                     * @returns {Object} Returns `object`.
                                     */
                                    function baseForOwn(object, iteratee) {
                                        return baseFor(object, iteratee, keys);
                                    }

                                    /**
                                     * The base implementation of `_.forOwnRight` without support for callback
                                     * shorthands and `this` binding.
                                     *
                                     * @private
                                     * @param {Object} object The object to iterate over.
                                     * @param {Function} iteratee The function invoked per iteration.
                                     * @returns {Object} Returns `object`.
                                     */
                                    function baseForOwnRight(object, iteratee) {
                                        return baseForRight(object, iteratee, keys);
                                    }

                                    /**
                                     * The base implementation of `_.functions` which creates an array of
                                     * `object` function property names filtered from those provided.
                                     *
                                     * @private
                                     * @param {Object} object The object to inspect.
                                     * @param {Array} props The property names to filter.
                                     * @returns {Array} Returns the new array of filtered property names.
                                     */
                                    function baseFunctions(object, props) {
                                        var index = -1,
                                            length = props.length,
                                            resIndex = -1,
                                            result = [];

                                        while (++index < length) {
                                            var key = props[index];
                                            if (isFunction(object[key])) {
                                                result[++resIndex] = key;
                                            }
                                        }
                                        return result;
                                    }

                                    /**
                                     * The base implementation of `get` without support for string paths
                                     * and default values.
                                     *
                                     * @private
                                     * @param {Object} object The object to query.
                                     * @param {Array} path The path of the property to get.
                                     * @param {string} [pathKey] The key representation of path.
                                     * @returns {*} Returns the resolved value.
                                     */
                                    function baseGet(object, path, pathKey) {
                                        if (object == null) {
                                            return;
                                        }
                                        if (pathKey !== undefined && pathKey in toObject(object)) {
                                            path = [pathKey];
                                        }
                                        var index = 0,
                                            length = path.length;

                                        while (object != null && index < length) {
                                            object = object[path[index++]];
                                        }
                                        return (index && index == length) ? object : undefined;
                                    }

                                    /**
                                     * The base implementation of `_.isEqual` without support for `this` binding
                                     * `customizer` functions.
                                     *
                                     * @private
                                     * @param {*} value The value to compare.
                                     * @param {*} other The other value to compare.
                                     * @param {Function} [customizer] The function to customize comparing values.
                                     * @param {boolean} [isLoose] Specify performing partial comparisons.
                                     * @param {Array} [stackA] Tracks traversed `value` objects.
                                     * @param {Array} [stackB] Tracks traversed `other` objects.
                                     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
                                     */
                                    function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
                                        if (value === other) {
                                            return true;
                                        }
                                        if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
                                            return value !== value && other !== other;
                                        }
                                        return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
                                    }

                                    /**
                                     * A specialized version of `baseIsEqual` for arrays and objects which performs
                                     * deep comparisons and tracks traversed objects enabling objects with circular
                                     * references to be compared.
                                     *
                                     * @private
                                     * @param {Object} object The object to compare.
                                     * @param {Object} other The other object to compare.
                                     * @param {Function} equalFunc The function to determine equivalents of values.
                                     * @param {Function} [customizer] The function to customize comparing objects.
                                     * @param {boolean} [isLoose] Specify performing partial comparisons.
                                     * @param {Array} [stackA=[]] Tracks traversed `value` objects.
                                     * @param {Array} [stackB=[]] Tracks traversed `other` objects.
                                     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
                                     */
                                    function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
                                        var objIsArr = isArray(object),
                                            othIsArr = isArray(other),
                                            objTag = arrayTag,
                                            othTag = arrayTag;

                                        if (!objIsArr) {
                                            objTag = objToString.call(object);
                                            if (objTag == argsTag) {
                                                objTag = objectTag;
                                            } else if (objTag != objectTag) {
                                                objIsArr = isTypedArray(object);
                                            }
                                        }
                                        if (!othIsArr) {
                                            othTag = objToString.call(other);
                                            if (othTag == argsTag) {
                                                othTag = objectTag;
                                            } else if (othTag != objectTag) {
                                                othIsArr = isTypedArray(other);
                                            }
                                        }
                                        var objIsObj = objTag == objectTag,
                                            othIsObj = othTag == objectTag,
                                            isSameTag = objTag == othTag;

                                        if (isSameTag && !(objIsArr || objIsObj)) {
                                            return equalByTag(object, other, objTag);
                                        }
                                        if (!isLoose) {
                                            var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
                                                othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

                                            if (objIsWrapped || othIsWrapped) {
                                                return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
                                            }
                                        }
                                        if (!isSameTag) {
                                            return false;
                                        }
                                        // Assume cyclic values are equal.
                                        // For more information on detecting circular references see https://es5.github.io/#JO.
                                        stackA || (stackA = []);
                                        stackB || (stackB = []);

                                        var length = stackA.length;
                                        while (length--) {
                                            if (stackA[length] == object) {
                                                return stackB[length] == other;
                                            }
                                        }
                                        // Add `object` and `other` to the stack of traversed objects.
                                        stackA.push(object);
                                        stackB.push(other);

                                        var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);

                                        stackA.pop();
                                        stackB.pop();

                                        return result;
                                    }

                                    /**
                                     * The base implementation of `_.isMatch` without support for callback
                                     * shorthands and `this` binding.
                                     *
                                     * @private
                                     * @param {Object} object The object to inspect.
                                     * @param {Array} matchData The propery names, values, and compare flags to match.
                                     * @param {Function} [customizer] The function to customize comparing objects.
                                     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
                                     */
                                    function baseIsMatch(object, matchData, customizer) {
                                        var index = matchData.length,
                                            length = index,
                                            noCustomizer = !customizer;

                                        if (object == null) {
                                            return !length;
                                        }
                                        object = toObject(object);
                                        while (index--) {
                                            var data = matchData[index];
                                            if ((noCustomizer && data[2])
                                                    ? data[1] !== object[data[0]]
                                                    : !(data[0] in object)
                                            ) {
                                                return false;
                                            }
                                        }
                                        while (++index < length) {
                                            data = matchData[index];
                                            var key = data[0],
                                                objValue = object[key],
                                                srcValue = data[1];

                                            if (noCustomizer && data[2]) {
                                                if (objValue === undefined && !(key in object)) {
                                                    return false;
                                                }
                                            } else {
                                                var result = customizer ? customizer(objValue, srcValue, key) : undefined;
                                                if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {
                                                    return false;
                                                }
                                            }
                                        }
                                        return true;
                                    }

                                    /**
                                     * The base implementation of `_.map` without support for callback shorthands
                                     * and `this` binding.
                                     *
                                     * @private
                                     * @param {Array|Object|string} collection The collection to iterate over.
                                     * @param {Function} iteratee The function invoked per iteration.
                                     * @returns {Array} Returns the new mapped array.
                                     */
                                    function baseMap(collection, iteratee) {
                                        var index = -1,
                                            result = isArrayLike(collection) ? Array(collection.length) : [];

                                        baseEach(collection, function (value, key, collection) {
                                            result[++index] = iteratee(value, key, collection);
                                        });
                                        return result;
                                    }

                                    /**
                                     * The base implementation of `_.matches` which does not clone `source`.
                                     *
                                     * @private
                                     * @param {Object} source The object of property values to match.
                                     * @returns {Function} Returns the new function.
                                     */
                                    function baseMatches(source) {
                                        var matchData = getMatchData(source);
                                        if (matchData.length == 1 && matchData[0][2]) {
                                            var key = matchData[0][0],
                                                value = matchData[0][1];

                                            return function (object) {
                                                if (object == null) {
                                                    return false;
                                                }
                                                return object[key] === value && (value !== undefined || (key in toObject(object)));
                                            };
                                        }
                                        return function (object) {
                                            return baseIsMatch(object, matchData);
                                        };
                                    }

                                    /**
                                     * The base implementation of `_.matchesProperty` which does not clone `srcValue`.
                                     *
                                     * @private
                                     * @param {string} path The path of the property to get.
                                     * @param {*} srcValue The value to compare.
                                     * @returns {Function} Returns the new function.
                                     */
                                    function baseMatchesProperty(path, srcValue) {
                                        var isArr = isArray(path),
                                            isCommon = isKey(path) && isStrictComparable(srcValue),
                                            pathKey = (path + '');

                                        path = toPath(path);
                                        return function (object) {
                                            if (object == null) {
                                                return false;
                                            }
                                            var key = pathKey;
                                            object = toObject(object);
                                            if ((isArr || !isCommon) && !(key in object)) {
                                                object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
                                                if (object == null) {
                                                    return false;
                                                }
                                                key = last(path);
                                                object = toObject(object);
                                            }
                                            return object[key] === srcValue
                                                ? (srcValue !== undefined || (key in object))
                                                : baseIsEqual(srcValue, object[key], undefined, true);
                                        };
                                    }

                                    /**
                                     * The base implementation of `_.merge` without support for argument juggling,
                                     * multiple sources, and `this` binding `customizer` functions.
                                     *
                                     * @private
                                     * @param {Object} object The destination object.
                                     * @param {Object} source The source object.
                                     * @param {Function} [customizer] The function to customize merged values.
                                     * @param {Array} [stackA=[]] Tracks traversed source objects.
                                     * @param {Array} [stackB=[]] Associates values with source counterparts.
                                     * @returns {Object} Returns `object`.
                                     */
                                    function baseMerge(object, source, customizer, stackA, stackB) {
                                        if (!isObject(object)) {
                                            return object;
                                        }
                                        var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),
                                            props = isSrcArr ? undefined : keys(source);

                                        arrayEach(props || source, function (srcValue, key) {
                                            if (props) {
                                                key = srcValue;
                                                srcValue = source[key];
                                            }
                                            if (isObjectLike(srcValue)) {
                                                stackA || (stackA = []);
                                                stackB || (stackB = []);
                                                baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
                                            }
                                            else {
                                                var value = object[key],
                                                    result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
                                                    isCommon = result === undefined;

                                                if (isCommon) {
                                                    result = srcValue;
                                                }
                                                if ((result !== undefined || (isSrcArr && !(key in object))) &&
                                                    (isCommon || (result === result ? (result !== value) : (value === value)))) {
                                                    object[key] = result;
                                                }
                                            }
                                        });
                                        return object;
                                    }

                                    /**
                                     * A specialized version of `baseMerge` for arrays and objects which performs
                                     * deep merges and tracks traversed objects enabling objects with circular
                                     * references to be merged.
                                     *
                                     * @private
                                     * @param {Object} object The destination object.
                                     * @param {Object} source The source object.
                                     * @param {string} key The key of the value to merge.
                                     * @param {Function} mergeFunc The function to merge values.
                                     * @param {Function} [customizer] The function to customize merged values.
                                     * @param {Array} [stackA=[]] Tracks traversed source objects.
                                     * @param {Array} [stackB=[]] Associates values with source counterparts.
                                     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
                                     */
                                    function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
                                        var length = stackA.length,
                                            srcValue = source[key];

                                        while (length--) {
                                            if (stackA[length] == srcValue) {
                                                object[key] = stackB[length];
                                                return;
                                            }
                                        }
                                        var value = object[key],
                                            result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
                                            isCommon = result === undefined;

                                        if (isCommon) {
                                            result = srcValue;
                                            if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {
                                                result = isArray(value)
                                                    ? value
                                                    : (isArrayLike(value) ? arrayCopy(value) : []);
                                            }
                                            else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                                                result = isArguments(value)
                                                    ? toPlainObject(value)
                                                    : (isPlainObject(value) ? value : {});
                                            }
                                            else {
                                                isCommon = false;
                                            }
                                        }
                                        // Add the source value to the stack of traversed objects and associate
                                        // it with its merged value.
                                        stackA.push(srcValue);
                                        stackB.push(result);

                                        if (isCommon) {
                                            // Recursively merge objects and arrays (susceptible to call stack limits).
                                            object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
                                        } else if (result === result ? (result !== value) : (value === value)) {
                                            object[key] = result;
                                        }
                                    }

                                    /**
                                     * The base implementation of `_.property` without support for deep paths.
                                     *
                                     * @private
                                     * @param {string} key The key of the property to get.
                                     * @returns {Function} Returns the new function.
                                     */
                                    function baseProperty(key) {
                                        return function (object) {
                                            return object == null ? undefined : object[key];
                                        };
                                    }

                                    /**
                                     * A specialized version of `baseProperty` which supports deep paths.
                                     *
                                     * @private
                                     * @param {Array|string} path The path of the property to get.
                                     * @returns {Function} Returns the new function.
                                     */
                                    function basePropertyDeep(path) {
                                        var pathKey = (path + '');
                                        path = toPath(path);
                                        return function (object) {
                                            return baseGet(object, path, pathKey);
                                        };
                                    }

                                    /**
                                     * The base implementation of `_.pullAt` without support for individual
                                     * index arguments and capturing the removed elements.
                                     *
                                     * @private
                                     * @param {Array} array The array to modify.
                                     * @param {number[]} indexes The indexes of elements to remove.
                                     * @returns {Array} Returns `array`.
                                     */
                                    function basePullAt(array, indexes) {
                                        var length = array ? indexes.length : 0;
                                        while (length--) {
                                            var index = indexes[length];
                                            if (index != previous && isIndex(index)) {
                                                var previous = index;
                                                splice.call(array, index, 1);
                                            }
                                        }
                                        return array;
                                    }

                                    /**
                                     * The base implementation of `_.random` without support for argument juggling
                                     * and returning floating-point numbers.
                                     *
                                     * @private
                                     * @param {number} min The minimum possible value.
                                     * @param {number} max The maximum possible value.
                                     * @returns {number} Returns the random number.
                                     */
                                    function baseRandom(min, max) {
                                        return min + nativeFloor(nativeRandom() * (max - min + 1));
                                    }

                                    /**
                                     * The base implementation of `_.reduce` and `_.reduceRight` without support
                                     * for callback shorthands and `this` binding, which iterates over `collection`
                                     * using the provided `eachFunc`.
                                     *
                                     * @private
                                     * @param {Array|Object|string} collection The collection to iterate over.
                                     * @param {Function} iteratee The function invoked per iteration.
                                     * @param {*} accumulator The initial value.
                                     * @param {boolean} initFromCollection Specify using the first or last element
                                     *  of `collection` as the initial value.
                                     * @param {Function} eachFunc The function to iterate over `collection`.
                                     * @returns {*} Returns the accumulated value.
                                     */
                                    function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
                                        eachFunc(collection, function (value, index, collection) {
                                            accumulator = initFromCollection
                                                ? (initFromCollection = false, value)
                                                : iteratee(accumulator, value, index, collection);
                                        });
                                        return accumulator;
                                    }

                                    /**
                                     * The base implementation of `setData` without support for hot loop detection.
                                     *
                                     * @private
                                     * @param {Function} func The function to associate metadata with.
                                     * @param {*} data The metadata.
                                     * @returns {Function} Returns `func`.
                                     */
                                    var baseSetData = !metaMap ? identity : function (func, data) {
                                        metaMap.set(func, data);
                                        return func;
                                    };

                                    /**
                                     * The base implementation of `_.slice` without an iteratee call guard.
                                     *
                                     * @private
                                     * @param {Array} array The array to slice.
                                     * @param {number} [start=0] The start position.
                                     * @param {number} [end=array.length] The end position.
                                     * @returns {Array} Returns the slice of `array`.
                                     */
                                    function baseSlice(array, start, end) {
                                        var index = -1,
                                            length = array.length;

                                        start = start == null ? 0 : (+start || 0);
                                        if (start < 0) {
                                            start = -start > length ? 0 : (length + start);
                                        }
                                        end = (end === undefined || end > length) ? length : (+end || 0);
                                        if (end < 0) {
                                            end += length;
                                        }
                                        length = start > end ? 0 : ((end - start) >>> 0);
                                        start >>>= 0;

                                        var result = Array(length);
                                        while (++index < length) {
                                            result[index] = array[index + start];
                                        }
                                        return result;
                                    }

                                    /**
                                     * The base implementation of `_.some` without support for callback shorthands
                                     * and `this` binding.
                                     *
                                     * @private
                                     * @param {Array|Object|string} collection The collection to iterate over.
                                     * @param {Function} predicate The function invoked per iteration.
                                     * @returns {boolean} Returns `true` if any element passes the predicate check,
                                     *  else `false`.
                                     */
                                    function baseSome(collection, predicate) {
                                        var result;

                                        baseEach(collection, function (value, index, collection) {
                                            result = predicate(value, index, collection);
                                            return !result;
                                        });
                                        return !!result;
                                    }

                                    /**
                                     * The base implementation of `_.sortBy` which uses `comparer` to define
                                     * the sort order of `array` and replaces criteria objects with their
                                     * corresponding values.
                                     *
                                     * @private
                                     * @param {Array} array The array to sort.
                                     * @param {Function} comparer The function to define sort order.
                                     * @returns {Array} Returns `array`.
                                     */
                                    function baseSortBy(array, comparer) {
                                        var length = array.length;

                                        array.sort(comparer);
                                        while (length--) {
                                            array[length] = array[length].value;
                                        }
                                        return array;
                                    }

                                    /**
                                     * The base implementation of `_.sortByOrder` without param guards.
                                     *
                                     * @private
                                     * @param {Array|Object|string} collection The collection to iterate over.
                                     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
                                     * @param {boolean[]} orders The sort orders of `iteratees`.
                                     * @returns {Array} Returns the new sorted array.
                                     */
                                    function baseSortByOrder(collection, iteratees, orders) {
                                        var callback = getCallback(),
                                            index = -1;

                                        iteratees = arrayMap(iteratees, function (iteratee) {
                                            return callback(iteratee);
                                        });

                                        var result = baseMap(collection, function (value) {
                                            var criteria = arrayMap(iteratees, function (iteratee) {
                                                return iteratee(value);
                                            });
                                            return {'criteria': criteria, 'index': ++index, 'value': value};
                                        });

                                        return baseSortBy(result, function (object, other) {
                                            return compareMultiple(object, other, orders);
                                        });
                                    }

                                    /**
                                     * The base implementation of `_.sum` without support for callback shorthands
                                     * and `this` binding.
                                     *
                                     * @private
                                     * @param {Array|Object|string} collection The collection to iterate over.
                                     * @param {Function} iteratee The function invoked per iteration.
                                     * @returns {number} Returns the sum.
                                     */
                                    function baseSum(collection, iteratee) {
                                        var result = 0;
                                        baseEach(collection, function (value, index, collection) {
                                            result += +iteratee(value, index, collection) || 0;
                                        });
                                        return result;
                                    }

                                    /**
                                     * The base implementation of `_.uniq` without support for callback shorthands
                                     * and `this` binding.
                                     *
                                     * @private
                                     * @param {Array} array The array to inspect.
                                     * @param {Function} [iteratee] The function invoked per iteration.
                                     * @returns {Array} Returns the new duplicate-value-free array.
                                     */
                                    function baseUniq(array, iteratee) {
                                        var index = -1,
                                            indexOf = getIndexOf(),
                                            length = array.length,
                                            isCommon = indexOf == baseIndexOf,
                                            isLarge = isCommon && length >= LARGE_ARRAY_SIZE,
                                            seen = isLarge ? createCache() : null,
                                            result = [];

                                        if (seen) {
                                            indexOf = cacheIndexOf;
                                            isCommon = false;
                                        } else {
                                            isLarge = false;
                                            seen = iteratee ? [] : result;
                                        }
                                        outer:
                                            while (++index < length) {
                                                var value = array[index],
                                                    computed = iteratee ? iteratee(value, index, array) : value;

                                                if (isCommon && value === value) {
                                                    var seenIndex = seen.length;
                                                    while (seenIndex--) {
                                                        if (seen[seenIndex] === computed) {
                                                            continue outer;
                                                        }
                                                    }
                                                    if (iteratee) {
                                                        seen.push(computed);
                                                    }
                                                    result.push(value);
                                                }
                                                else if (indexOf(seen, computed, 0) < 0) {
                                                    if (iteratee || isLarge) {
                                                        seen.push(computed);
                                                    }
                                                    result.push(value);
                                                }
                                            }
                                        return result;
                                    }

                                    /**
                                     * The base implementation of `_.values` and `_.valuesIn` which creates an
                                     * array of `object` property values corresponding to the property names
                                     * of `props`.
                                     *
                                     * @private
                                     * @param {Object} object The object to query.
                                     * @param {Array} props The property names to get values for.
                                     * @returns {Object} Returns the array of property values.
                                     */
                                    function baseValues(object, props) {
                                        var index = -1,
                                            length = props.length,
                                            result = Array(length);

                                        while (++index < length) {
                                            result[index] = object[props[index]];
                                        }
                                        return result;
                                    }

                                    /**
                                     * The base implementation of `_.dropRightWhile`, `_.dropWhile`, `_.takeRightWhile`,
                                     * and `_.takeWhile` without support for callback shorthands and `this` binding.
                                     *
                                     * @private
                                     * @param {Array} array The array to query.
                                     * @param {Function} predicate The function invoked per iteration.
                                     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
                                     * @param {boolean} [fromRight] Specify iterating from right to left.
                                     * @returns {Array} Returns the slice of `array`.
                                     */
                                    function baseWhile(array, predicate, isDrop, fromRight) {
                                        var length = array.length,
                                            index = fromRight ? length : -1;

                                        while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
                                        }
                                        return isDrop
                                            ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
                                            : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
                                    }

                                    /**
                                     * The base implementation of `wrapperValue` which returns the result of
                                     * performing a sequence of actions on the unwrapped `value`, where each
                                     * successive action is supplied the return value of the previous.
                                     *
                                     * @private
                                     * @param {*} value The unwrapped value.
                                     * @param {Array} actions Actions to peform to resolve the unwrapped value.
                                     * @returns {*} Returns the resolved value.
                                     */
                                    function baseWrapperValue(value, actions) {
                                        var result = value;
                                        if (result instanceof LazyWrapper) {
                                            result = result.value();
                                        }
                                        var index = -1,
                                            length = actions.length;

                                        while (++index < length) {
                                            var action = actions[index];
                                            result = action.func.apply(action.thisArg, arrayPush([result], action.args));
                                        }
                                        return result;
                                    }

                                    /**
                                     * Performs a binary search of `array` to determine the index at which `value`
                                     * should be inserted into `array` in order to maintain its sort order.
                                     *
                                     * @private
                                     * @param {Array} array The sorted array to inspect.
                                     * @param {*} value The value to evaluate.
                                     * @param {boolean} [retHighest] Specify returning the highest qualified index.
                                     * @returns {number} Returns the index at which `value` should be inserted
                                     *  into `array`.
                                     */
                                    function binaryIndex(array, value, retHighest) {
                                        var low = 0,
                                            high = array ? array.length : low;

                                        if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
                                            while (low < high) {
                                                var mid = (low + high) >>> 1,
                                                    computed = array[mid];

                                                if ((retHighest ? (computed <= value) : (computed < value)) && computed !== null) {
                                                    low = mid + 1;
                                                } else {
                                                    high = mid;
                                                }
                                            }
                                            return high;
                                        }
                                        return binaryIndexBy(array, value, identity, retHighest);
                                    }

                                    /**
                                     * This function is like `binaryIndex` except that it invokes `iteratee` for
                                     * `value` and each element of `array` to compute their sort ranking. The
                                     * iteratee is invoked with one argument; (value).
                                     *
                                     * @private
                                     * @param {Array} array The sorted array to inspect.
                                     * @param {*} value The value to evaluate.
                                     * @param {Function} iteratee The function invoked per iteration.
                                     * @param {boolean} [retHighest] Specify returning the highest qualified index.
                                     * @returns {number} Returns the index at which `value` should be inserted
                                     *  into `array`.
                                     */
                                    function binaryIndexBy(array, value, iteratee, retHighest) {
                                        value = iteratee(value);

                                        var low = 0,
                                            high = array ? array.length : 0,
                                            valIsNaN = value !== value,
                                            valIsNull = value === null,
                                            valIsUndef = value === undefined;

                                        while (low < high) {
                                            var mid = nativeFloor((low + high) / 2),
                                                computed = iteratee(array[mid]),
                                                isDef = computed !== undefined,
                                                isReflexive = computed === computed;

                                            if (valIsNaN) {
                                                var setLow = isReflexive || retHighest;
                                            } else if (valIsNull) {
                                                setLow = isReflexive && isDef && (retHighest || computed != null);
                                            } else if (valIsUndef) {
                                                setLow = isReflexive && (retHighest || isDef);
                                            } else if (computed == null) {
                                                setLow = false;
                                            } else {
                                                setLow = retHighest ? (computed <= value) : (computed < value);
                                            }
                                            if (setLow) {
                                                low = mid + 1;
                                            } else {
                                                high = mid;
                                            }
                                        }
                                        return nativeMin(high, MAX_ARRAY_INDEX);
                                    }

                                    /**
                                     * A specialized version of `baseCallback` which only supports `this` binding
                                     * and specifying the number of arguments to provide to `func`.
                                     *
                                     * @private
                                     * @param {Function} func The function to bind.
                                     * @param {*} thisArg The `this` binding of `func`.
                                     * @param {number} [argCount] The number of arguments to provide to `func`.
                                     * @returns {Function} Returns the callback.
                                     */
                                    function bindCallback(func, thisArg, argCount) {
                                        if (typeof func != 'function') {
                                            return identity;
                                        }
                                        if (thisArg === undefined) {
                                            return func;
                                        }
                                        switch (argCount) {
                                            case 1:
                                                return function (value) {
                                                    return func.call(thisArg, value);
                                                };
                                            case 3:
                                                return function (value, index, collection) {
                                                    return func.call(thisArg, value, index, collection);
                                                };
                                            case 4:
                                                return function (accumulator, value, index, collection) {
                                                    return func.call(thisArg, accumulator, value, index, collection);
                                                };
                                            case 5:
                                                return function (value, other, key, object, source) {
                                                    return func.call(thisArg, value, other, key, object, source);
                                                };
                                        }
                                        return function () {
                                            return func.apply(thisArg, arguments);
                                        };
                                    }

                                    /**
                                     * Creates a clone of the given array buffer.
                                     *
                                     * @private
                                     * @param {ArrayBuffer} buffer The array buffer to clone.
                                     * @returns {ArrayBuffer} Returns the cloned array buffer.
                                     */
                                    function bufferClone(buffer) {
                                        var result = new ArrayBuffer(buffer.byteLength),
                                            view = new Uint8Array(result);

                                        view.set(new Uint8Array(buffer));
                                        return result;
                                    }

                                    /**
                                     * Creates an array that is the composition of partially applied arguments,
                                     * placeholders, and provided arguments into a single array of arguments.
                                     *
                                     * @private
                                     * @param {Array|Object} args The provided arguments.
                                     * @param {Array} partials The arguments to prepend to those provided.
                                     * @param {Array} holders The `partials` placeholder indexes.
                                     * @returns {Array} Returns the new array of composed arguments.
                                     */
                                    function composeArgs(args, partials, holders) {
                                        var holdersLength = holders.length,
                                            argsIndex = -1,
                                            argsLength = nativeMax(args.length - holdersLength, 0),
                                            leftIndex = -1,
                                            leftLength = partials.length,
                                            result = Array(leftLength + argsLength);

                                        while (++leftIndex < leftLength) {
                                            result[leftIndex] = partials[leftIndex];
                                        }
                                        while (++argsIndex < holdersLength) {
                                            result[holders[argsIndex]] = args[argsIndex];
                                        }
                                        while (argsLength--) {
                                            result[leftIndex++] = args[argsIndex++];
                                        }
                                        return result;
                                    }

                                    /**
                                     * This function is like `composeArgs` except that the arguments composition
                                     * is tailored for `_.partialRight`.
                                     *
                                     * @private
                                     * @param {Array|Object} args The provided arguments.
                                     * @param {Array} partials The arguments to append to those provided.
                                     * @param {Array} holders The `partials` placeholder indexes.
                                     * @returns {Array} Returns the new array of composed arguments.
                                     */
                                    function composeArgsRight(args, partials, holders) {
                                        var holdersIndex = -1,
                                            holdersLength = holders.length,
                                            argsIndex = -1,
                                            argsLength = nativeMax(args.length - holdersLength, 0),
                                            rightIndex = -1,
                                            rightLength = partials.length,
                                            result = Array(argsLength + rightLength);

                                        while (++argsIndex < argsLength) {
                                            result[argsIndex] = args[argsIndex];
                                        }
                                        var offset = argsIndex;
                                        while (++rightIndex < rightLength) {
                                            result[offset + rightIndex] = partials[rightIndex];
                                        }
                                        while (++holdersIndex < holdersLength) {
                                            result[offset + holders[holdersIndex]] = args[argsIndex++];
                                        }
                                        return result;
                                    }

                                    /**
                                     * Creates a `_.countBy`, `_.groupBy`, `_.indexBy`, or `_.partition` function.
                                     *
                                     * @private
                                     * @param {Function} setter The function to set keys and values of the accumulator object.
                                     * @param {Function} [initializer] The function to initialize the accumulator object.
                                     * @returns {Function} Returns the new aggregator function.
                                     */
                                    function createAggregator(setter, initializer) {
                                        return function (collection, iteratee, thisArg) {
                                            var result = initializer ? initializer() : {};
                                            iteratee = getCallback(iteratee, thisArg, 3);

                                            if (isArray(collection)) {
                                                var index = -1,
                                                    length = collection.length;

                                                while (++index < length) {
                                                    var value = collection[index];
                                                    setter(result, value, iteratee(value, index, collection), collection);
                                                }
                                            } else {
                                                baseEach(collection, function (value, key, collection) {
                                                    setter(result, value, iteratee(value, key, collection), collection);
                                                });
                                            }
                                            return result;
                                        };
                                    }

                                    /**
                                     * Creates a `_.assign`, `_.defaults`, or `_.merge` function.
                                     *
                                     * @private
                                     * @param {Function} assigner The function to assign values.
                                     * @returns {Function} Returns the new assigner function.
                                     */
                                    function createAssigner(assigner) {
                                        return restParam(function (object, sources) {
                                            var index = -1,
                                                length = object == null ? 0 : sources.length,
                                                customizer = length > 2 ? sources[length - 2] : undefined,
                                                guard = length > 2 ? sources[2] : undefined,
                                                thisArg = length > 1 ? sources[length - 1] : undefined;

                                            if (typeof customizer == 'function') {
                                                customizer = bindCallback(customizer, thisArg, 5);
                                                length -= 2;
                                            } else {
                                                customizer = typeof thisArg == 'function' ? thisArg : undefined;
                                                length -= (customizer ? 1 : 0);
                                            }
                                            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                                                customizer = length < 3 ? undefined : customizer;
                                                length = 1;
                                            }
                                            while (++index < length) {
                                                var source = sources[index];
                                                if (source) {
                                                    assigner(object, source, customizer);
                                                }
                                            }
                                            return object;
                                        });
                                    }

                                    /**
                                     * Creates a `baseEach` or `baseEachRight` function.
                                     *
                                     * @private
                                     * @param {Function} eachFunc The function to iterate over a collection.
                                     * @param {boolean} [fromRight] Specify iterating from right to left.
                                     * @returns {Function} Returns the new base function.
                                     */
                                    function createBaseEach(eachFunc, fromRight) {
                                        return function (collection, iteratee) {
                                            var length = collection ? getLength(collection) : 0;
                                            if (!isLength(length)) {
                                                return eachFunc(collection, iteratee);
                                            }
                                            var index = fromRight ? length : -1,
                                                iterable = toObject(collection);

                                            while ((fromRight ? index-- : ++index < length)) {
                                                if (iteratee(iterable[index], index, iterable) === false) {
                                                    break;
                                                }
                                            }
                                            return collection;
                                        };
                                    }

                                    /**
                                     * Creates a base function for `_.forIn` or `_.forInRight`.
                                     *
                                     * @private
                                     * @param {boolean} [fromRight] Specify iterating from right to left.
                                     * @returns {Function} Returns the new base function.
                                     */
                                    function createBaseFor(fromRight) {
                                        return function (object, iteratee, keysFunc) {
                                            var iterable = toObject(object),
                                                props = keysFunc(object),
                                                length = props.length,
                                                index = fromRight ? length : -1;

                                            while ((fromRight ? index-- : ++index < length)) {
                                                var key = props[index];
                                                if (iteratee(iterable[key], key, iterable) === false) {
                                                    break;
                                                }
                                            }
                                            return object;
                                        };
                                    }

                                    /**
                                     * Creates a function that wraps `func` and invokes it with the `this`
                                     * binding of `thisArg`.
                                     *
                                     * @private
                                     * @param {Function} func The function to bind.
                                     * @param {*} [thisArg] The `this` binding of `func`.
                                     * @returns {Function} Returns the new bound function.
                                     */
                                    function createBindWrapper(func, thisArg) {
                                        var Ctor = createCtorWrapper(func);

                                        function wrapper() {
                                            var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
                                            return fn.apply(thisArg, arguments);
                                        }

                                        return wrapper;
                                    }

                                    /**
                                     * Creates a `Set` cache object to optimize linear searches of large arrays.
                                     *
                                     * @private
                                     * @param {Array} [values] The values to cache.
                                     * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.
                                     */
                                    function createCache(values) {
                                        return (nativeCreate && Set) ? new SetCache(values) : null;
                                    }

                                    /**
                                     * Creates a function that produces compound words out of the words in a
                                     * given string.
                                     *
                                     * @private
                                     * @param {Function} callback The function to combine each word.
                                     * @returns {Function} Returns the new compounder function.
                                     */
                                    function createCompounder(callback) {
                                        return function (string) {
                                            var index = -1,
                                                array = words(deburr(string)),
                                                length = array.length,
                                                result = '';

                                            while (++index < length) {
                                                result = callback(result, array[index], index);
                                            }
                                            return result;
                                        };
                                    }

                                    /**
                                     * Creates a function that produces an instance of `Ctor` regardless of
                                     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
                                     *
                                     * @private
                                     * @param {Function} Ctor The constructor to wrap.
                                     * @returns {Function} Returns the new wrapped function.
                                     */
                                    function createCtorWrapper(Ctor) {
                                        return function () {
                                            // Use a `switch` statement to work with class constructors.
                                            // See http://ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
                                            // for more details.
                                            var args = arguments;
                                            switch (args.length) {
                                                case 0:
                                                    return new Ctor;
                                                case 1:
                                                    return new Ctor(args[0]);
                                                case 2:
                                                    return new Ctor(args[0], args[1]);
                                                case 3:
                                                    return new Ctor(args[0], args[1], args[2]);
                                                case 4:
                                                    return new Ctor(args[0], args[1], args[2], args[3]);
                                                case 5:
                                                    return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                                                case 6:
                                                    return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                                                case 7:
                                                    return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
                                            }
                                            var thisBinding = baseCreate(Ctor.prototype),
                                                result = Ctor.apply(thisBinding, args);

                                            // Mimic the constructor's `return` behavior.
                                            // See https://es5.github.io/#x13.2.2 for more details.
                                            return isObject(result) ? result : thisBinding;
                                        };
                                    }

                                    /**
                                     * Creates a `_.curry` or `_.curryRight` function.
                                     *
                                     * @private
                                     * @param {boolean} flag The curry bit flag.
                                     * @returns {Function} Returns the new curry function.
                                     */
                                    function createCurry(flag) {
                                        function curryFunc(func, arity, guard) {
                                            if (guard && isIterateeCall(func, arity, guard)) {
                                                arity = undefined;
                                            }
                                            var result = createWrapper(func, flag, undefined, undefined, undefined, undefined, undefined, arity);
                                            result.placeholder = curryFunc.placeholder;
                                            return result;
                                        }

                                        return curryFunc;
                                    }

                                    /**
                                     * Creates a `_.defaults` or `_.defaultsDeep` function.
                                     *
                                     * @private
                                     * @param {Function} assigner The function to assign values.
                                     * @param {Function} customizer The function to customize assigned values.
                                     * @returns {Function} Returns the new defaults function.
                                     */
                                    function createDefaults(assigner, customizer) {
                                        return restParam(function (args) {
                                            var object = args[0];
                                            if (object == null) {
                                                return object;
                                            }
                                            args.push(customizer);
                                            return assigner.apply(undefined, args);
                                        });
                                    }

                                    /**
                                     * Creates a `_.max` or `_.min` function.
                                     *
                                     * @private
                                     * @param {Function} comparator The function used to compare values.
                                     * @param {*} exValue The initial extremum value.
                                     * @returns {Function} Returns the new extremum function.
                                     */
                                    function createExtremum(comparator, exValue) {
                                        return function (collection, iteratee, thisArg) {
                                            if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
                                                iteratee = undefined;
                                            }
                                            iteratee = getCallback(iteratee, thisArg, 3);
                                            if (iteratee.length == 1) {
                                                collection = isArray(collection) ? collection : toIterable(collection);
                                                var result = arrayExtremum(collection, iteratee, comparator, exValue);
                                                if (!(collection.length && result === exValue)) {
                                                    return result;
                                                }
                                            }
                                            return baseExtremum(collection, iteratee, comparator, exValue);
                                        };
                                    }

                                    /**
                                     * Creates a `_.find` or `_.findLast` function.
                                     *
                                     * @private
                                     * @param {Function} eachFunc The function to iterate over a collection.
                                     * @param {boolean} [fromRight] Specify iterating from right to left.
                                     * @returns {Function} Returns the new find function.
                                     */
                                    function createFind(eachFunc, fromRight) {
                                        return function (collection, predicate, thisArg) {
                                            predicate = getCallback(predicate, thisArg, 3);
                                            if (isArray(collection)) {
                                                var index = baseFindIndex(collection, predicate, fromRight);
                                                return index > -1 ? collection[index] : undefined;
                                            }
                                            return baseFind(collection, predicate, eachFunc);
                                        };
                                    }

                                    /**
                                     * Creates a `_.findIndex` or `_.findLastIndex` function.
                                     *
                                     * @private
                                     * @param {boolean} [fromRight] Specify iterating from right to left.
                                     * @returns {Function} Returns the new find function.
                                     */
                                    function createFindIndex(fromRight) {
                                        return function (array, predicate, thisArg) {
                                            if (!(array && array.length)) {
                                                return -1;
                                            }
                                            predicate = getCallback(predicate, thisArg, 3);
                                            return baseFindIndex(array, predicate, fromRight);
                                        };
                                    }

                                    /**
                                     * Creates a `_.findKey` or `_.findLastKey` function.
                                     *
                                     * @private
                                     * @param {Function} objectFunc The function to iterate over an object.
                                     * @returns {Function} Returns the new find function.
                                     */
                                    function createFindKey(objectFunc) {
                                        return function (object, predicate, thisArg) {
                                            predicate = getCallback(predicate, thisArg, 3);
                                            return baseFind(object, predicate, objectFunc, true);
                                        };
                                    }

                                    /**
                                     * Creates a `_.flow` or `_.flowRight` function.
                                     *
                                     * @private
                                     * @param {boolean} [fromRight] Specify iterating from right to left.
                                     * @returns {Function} Returns the new flow function.
                                     */
                                    function createFlow(fromRight) {
                                        return function () {
                                            var wrapper,
                                                length = arguments.length,
                                                index = fromRight ? length : -1,
                                                leftIndex = 0,
                                                funcs = Array(length);

                                            while ((fromRight ? index-- : ++index < length)) {
                                                var func = funcs[leftIndex++] = arguments[index];
                                                if (typeof func != 'function') {
                                                    throw new TypeError(FUNC_ERROR_TEXT);
                                                }
                                                if (!wrapper && LodashWrapper.prototype.thru && getFuncName(func) == 'wrapper') {
                                                    wrapper = new LodashWrapper([], true);
                                                }
                                            }
                                            index = wrapper ? -1 : length;
                                            while (++index < length) {
                                                func = funcs[index];

                                                var funcName = getFuncName(func),
                                                    data = funcName == 'wrapper' ? getData(func) : undefined;

                                                if (data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && data[9] == 1) {
                                                    wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                                                } else {
                                                    wrapper = (func.length == 1 && isLaziable(func)) ? wrapper[funcName]() : wrapper.thru(func);
                                                }
                                            }
                                            return function () {
                                                var args = arguments,
                                                    value = args[0];

                                                if (wrapper && args.length == 1 && isArray(value) && value.length >= LARGE_ARRAY_SIZE) {
                                                    return wrapper.plant(value).value();
                                                }
                                                var index = 0,
                                                    result = length ? funcs[index].apply(this, args) : value;

                                                while (++index < length) {
                                                    result = funcs[index].call(this, result);
                                                }
                                                return result;
                                            };
                                        };
                                    }

                                    /**
                                     * Creates a function for `_.forEach` or `_.forEachRight`.
                                     *
                                     * @private
                                     * @param {Function} arrayFunc The function to iterate over an array.
                                     * @param {Function} eachFunc The function to iterate over a collection.
                                     * @returns {Function} Returns the new each function.
                                     */
                                    function createForEach(arrayFunc, eachFunc) {
                                        return function (collection, iteratee, thisArg) {
                                            return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
                                                ? arrayFunc(collection, iteratee)
                                                : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
                                        };
                                    }

                                    /**
                                     * Creates a function for `_.forIn` or `_.forInRight`.
                                     *
                                     * @private
                                     * @param {Function} objectFunc The function to iterate over an object.
                                     * @returns {Function} Returns the new each function.
                                     */
                                    function createForIn(objectFunc) {
                                        return function (object, iteratee, thisArg) {
                                            if (typeof iteratee != 'function' || thisArg !== undefined) {
                                                iteratee = bindCallback(iteratee, thisArg, 3);
                                            }
                                            return objectFunc(object, iteratee, keysIn);
                                        };
                                    }

                                    /**
                                     * Creates a function for `_.forOwn` or `_.forOwnRight`.
                                     *
                                     * @private
                                     * @param {Function} objectFunc The function to iterate over an object.
                                     * @returns {Function} Returns the new each function.
                                     */
                                    function createForOwn(objectFunc) {
                                        return function (object, iteratee, thisArg) {
                                            if (typeof iteratee != 'function' || thisArg !== undefined) {
                                                iteratee = bindCallback(iteratee, thisArg, 3);
                                            }
                                            return objectFunc(object, iteratee);
                                        };
                                    }

                                    /**
                                     * Creates a function for `_.mapKeys` or `_.mapValues`.
                                     *
                                     * @private
                                     * @param {boolean} [isMapKeys] Specify mapping keys instead of values.
                                     * @returns {Function} Returns the new map function.
                                     */
                                    function createObjectMapper(isMapKeys) {
                                        return function (object, iteratee, thisArg) {
                                            var result = {};
                                            iteratee = getCallback(iteratee, thisArg, 3);

                                            baseForOwn(object, function (value, key, object) {
                                                var mapped = iteratee(value, key, object);
                                                key = isMapKeys ? mapped : key;
                                                value = isMapKeys ? value : mapped;
                                                result[key] = value;
                                            });
                                            return result;
                                        };
                                    }

                                    /**
                                     * Creates a function for `_.padLeft` or `_.padRight`.
                                     *
                                     * @private
                                     * @param {boolean} [fromRight] Specify padding from the right.
                                     * @returns {Function} Returns the new pad function.
                                     */
                                    function createPadDir(fromRight) {
                                        return function (string, length, chars) {
                                            string = baseToString(string);
                                            return (fromRight ? string : '') + createPadding(string, length, chars) + (fromRight ? '' : string);
                                        };
                                    }

                                    /**
                                     * Creates a `_.partial` or `_.partialRight` function.
                                     *
                                     * @private
                                     * @param {boolean} flag The partial bit flag.
                                     * @returns {Function} Returns the new partial function.
                                     */
                                    function createPartial(flag) {
                                        var partialFunc = restParam(function (func, partials) {
                                            var holders = replaceHolders(partials, partialFunc.placeholder);
                                            return createWrapper(func, flag, undefined, partials, holders);
                                        });
                                        return partialFunc;
                                    }

                                    /**
                                     * Creates a function for `_.reduce` or `_.reduceRight`.
                                     *
                                     * @private
                                     * @param {Function} arrayFunc The function to iterate over an array.
                                     * @param {Function} eachFunc The function to iterate over a collection.
                                     * @returns {Function} Returns the new each function.
                                     */
                                    function createReduce(arrayFunc, eachFunc) {
                                        return function (collection, iteratee, accumulator, thisArg) {
                                            var initFromArray = arguments.length < 3;
                                            return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
                                                ? arrayFunc(collection, iteratee, accumulator, initFromArray)
                                                : baseReduce(collection, getCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);
                                        };
                                    }

                                    /**
                                     * Creates a function that wraps `func` and invokes it with optional `this`
                                     * binding of, partial application, and currying.
                                     *
                                     * @private
                                     * @param {Function|string} func The function or method name to reference.
                                     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
                                     * @param {*} [thisArg] The `this` binding of `func`.
                                     * @param {Array} [partials] The arguments to prepend to those provided to the new function.
                                     * @param {Array} [holders] The `partials` placeholder indexes.
                                     * @param {Array} [partialsRight] The arguments to append to those provided to the new function.
                                     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
                                     * @param {Array} [argPos] The argument positions of the new function.
                                     * @param {number} [ary] The arity cap of `func`.
                                     * @param {number} [arity] The arity of `func`.
                                     * @returns {Function} Returns the new wrapped function.
                                     */
                                    function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
                                        var isAry = bitmask & ARY_FLAG,
                                            isBind = bitmask & BIND_FLAG,
                                            isBindKey = bitmask & BIND_KEY_FLAG,
                                            isCurry = bitmask & CURRY_FLAG,
                                            isCurryBound = bitmask & CURRY_BOUND_FLAG,
                                            isCurryRight = bitmask & CURRY_RIGHT_FLAG,
                                            Ctor = isBindKey ? undefined : createCtorWrapper(func);

                                        function wrapper() {
                                            // Avoid `arguments` object use disqualifying optimizations by
                                            // converting it to an array before providing it to other functions.
                                            var length = arguments.length,
                                                index = length,
                                                args = Array(length);

                                            while (index--) {
                                                args[index] = arguments[index];
                                            }
                                            if (partials) {
                                                args = composeArgs(args, partials, holders);
                                            }
                                            if (partialsRight) {
                                                args = composeArgsRight(args, partialsRight, holdersRight);
                                            }
                                            if (isCurry || isCurryRight) {
                                                var placeholder = wrapper.placeholder,
                                                    argsHolders = replaceHolders(args, placeholder);

                                                length -= argsHolders.length;
                                                if (length < arity) {
                                                    var newArgPos = argPos ? arrayCopy(argPos) : undefined,
                                                        newArity = nativeMax(arity - length, 0),
                                                        newsHolders = isCurry ? argsHolders : undefined,
                                                        newHoldersRight = isCurry ? undefined : argsHolders,
                                                        newPartials = isCurry ? args : undefined,
                                                        newPartialsRight = isCurry ? undefined : args;

                                                    bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
                                                    bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);

                                                    if (!isCurryBound) {
                                                        bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
                                                    }
                                                    var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity],
                                                        result = createHybridWrapper.apply(undefined, newData);

                                                    if (isLaziable(func)) {
                                                        setData(result, newData);
                                                    }
                                                    result.placeholder = placeholder;
                                                    return result;
                                                }
                                            }
                                            var thisBinding = isBind ? thisArg : this,
                                                fn = isBindKey ? thisBinding[func] : func;

                                            if (argPos) {
                                                args = reorder(args, argPos);
                                            }
                                            if (isAry && ary < args.length) {
                                                args.length = ary;
                                            }
                                            if (this && this !== root && this instanceof wrapper) {
                                                fn = Ctor || createCtorWrapper(func);
                                            }
                                            return fn.apply(thisBinding, args);
                                        }

                                        return wrapper;
                                    }

                                    /**
                                     * Creates the padding required for `string` based on the given `length`.
                                     * The `chars` string is truncated if the number of characters exceeds `length`.
                                     *
                                     * @private
                                     * @param {string} string The string to create padding for.
                                     * @param {number} [length=0] The padding length.
                                     * @param {string} [chars=' '] The string used as padding.
                                     * @returns {string} Returns the pad for `string`.
                                     */
                                    function createPadding(string, length, chars) {
                                        var strLength = string.length;
                                        length = +length;

                                        if (strLength >= length || !nativeIsFinite(length)) {
                                            return '';
                                        }
                                        var padLength = length - strLength;
                                        chars = chars == null ? ' ' : (chars + '');
                                        return repeat(chars, nativeCeil(padLength / chars.length)).slice(0, padLength);
                                    }

                                    /**
                                     * Creates a function that wraps `func` and invokes it with the optional `this`
                                     * binding of `thisArg` and the `partials` prepended to those provided to
                                     * the wrapper.
                                     *
                                     * @private
                                     * @param {Function} func The function to partially apply arguments to.
                                     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
                                     * @param {*} thisArg The `this` binding of `func`.
                                     * @param {Array} partials The arguments to prepend to those provided to the new function.
                                     * @returns {Function} Returns the new bound function.
                                     */
                                    function createPartialWrapper(func, bitmask, thisArg, partials) {
                                        var isBind = bitmask & BIND_FLAG,
                                            Ctor = createCtorWrapper(func);

                                        function wrapper() {
                                            // Avoid `arguments` object use disqualifying optimizations by
                                            // converting it to an array before providing it `func`.
                                            var argsIndex = -1,
                                                argsLength = arguments.length,
                                                leftIndex = -1,
                                                leftLength = partials.length,
                                                args = Array(leftLength + argsLength);

                                            while (++leftIndex < leftLength) {
                                                args[leftIndex] = partials[leftIndex];
                                            }
                                            while (argsLength--) {
                                                args[leftIndex++] = arguments[++argsIndex];
                                            }
                                            var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
                                            return fn.apply(isBind ? thisArg : this, args);
                                        }

                                        return wrapper;
                                    }

                                    /**
                                     * Creates a `_.ceil`, `_.floor`, or `_.round` function.
                                     *
                                     * @private
                                     * @param {string} methodName The name of the `Math` method to use when rounding.
                                     * @returns {Function} Returns the new round function.
                                     */
                                    function createRound(methodName) {
                                        var func = Math[methodName];
                                        return function (number, precision) {
                                            precision = precision === undefined ? 0 : (+precision || 0);
                                            if (precision) {
                                                precision = pow(10, precision);
                                                return func(number * precision) / precision;
                                            }
                                            return func(number);
                                        };
                                    }

                                    /**
                                     * Creates a `_.sortedIndex` or `_.sortedLastIndex` function.
                                     *
                                     * @private
                                     * @param {boolean} [retHighest] Specify returning the highest qualified index.
                                     * @returns {Function} Returns the new index function.
                                     */
                                    function createSortedIndex(retHighest) {
                                        return function (array, value, iteratee, thisArg) {
                                            var callback = getCallback(iteratee);
                                            return (iteratee == null && callback === baseCallback)
                                                ? binaryIndex(array, value, retHighest)
                                                : binaryIndexBy(array, value, callback(iteratee, thisArg, 1), retHighest);
                                        };
                                    }

                                    /**
                                     * Creates a function that either curries or invokes `func` with optional
                                     * `this` binding and partially applied arguments.
                                     *
                                     * @private
                                     * @param {Function|string} func The function or method name to reference.
                                     * @param {number} bitmask The bitmask of flags.
                                     *  The bitmask may be composed of the following flags:
                                     *     1 - `_.bind`
                                     *     2 - `_.bindKey`
                                     *     4 - `_.curry` or `_.curryRight` of a bound function
                                     *     8 - `_.curry`
                                     *    16 - `_.curryRight`
                                     *    32 - `_.partial`
                                     *    64 - `_.partialRight`
                                     *   128 - `_.rearg`
                                     *   256 - `_.ary`
                                     * @param {*} [thisArg] The `this` binding of `func`.
                                     * @param {Array} [partials] The arguments to be partially applied.
                                     * @param {Array} [holders] The `partials` placeholder indexes.
                                     * @param {Array} [argPos] The argument positions of the new function.
                                     * @param {number} [ary] The arity cap of `func`.
                                     * @param {number} [arity] The arity of `func`.
                                     * @returns {Function} Returns the new wrapped function.
                                     */
                                    function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
                                        var isBindKey = bitmask & BIND_KEY_FLAG;
                                        if (!isBindKey && typeof func != 'function') {
                                            throw new TypeError(FUNC_ERROR_TEXT);
                                        }
                                        var length = partials ? partials.length : 0;
                                        if (!length) {
                                            bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
                                            partials = holders = undefined;
                                        }
                                        length -= (holders ? holders.length : 0);
                                        if (bitmask & PARTIAL_RIGHT_FLAG) {
                                            var partialsRight = partials,
                                                holdersRight = holders;

                                            partials = holders = undefined;
                                        }
                                        var data = isBindKey ? undefined : getData(func),
                                            newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];

                                        if (data) {
                                            mergeData(newData, data);
                                            bitmask = newData[1];
                                            arity = newData[9];
                                        }
                                        newData[9] = arity == null
                                            ? (isBindKey ? 0 : func.length)
                                            : (nativeMax(arity - length, 0) || 0);

                                        if (bitmask == BIND_FLAG) {
                                            var result = createBindWrapper(newData[0], newData[2]);
                                        } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
                                            result = createPartialWrapper.apply(undefined, newData);
                                        } else {
                                            result = createHybridWrapper.apply(undefined, newData);
                                        }
                                        var setter = data ? baseSetData : setData;
                                        return setter(result, newData);
                                    }

                                    /**
                                     * A specialized version of `baseIsEqualDeep` for arrays with support for
                                     * partial deep comparisons.
                                     *
                                     * @private
                                     * @param {Array} array The array to compare.
                                     * @param {Array} other The other array to compare.
                                     * @param {Function} equalFunc The function to determine equivalents of values.
                                     * @param {Function} [customizer] The function to customize comparing arrays.
                                     * @param {boolean} [isLoose] Specify performing partial comparisons.
                                     * @param {Array} [stackA] Tracks traversed `value` objects.
                                     * @param {Array} [stackB] Tracks traversed `other` objects.
                                     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
                                     */
                                    function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
                                        var index = -1,
                                            arrLength = array.length,
                                            othLength = other.length;

                                        if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
                                            return false;
                                        }
                                        // Ignore non-index properties.
                                        while (++index < arrLength) {
                                            var arrValue = array[index],
                                                othValue = other[index],
                                                result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;

                                            if (result !== undefined) {
                                                if (result) {
                                                    continue;
                                                }
                                                return false;
                                            }
                                            // Recursively compare arrays (susceptible to call stack limits).
                                            if (isLoose) {
                                                if (!arraySome(other, function (othValue) {
                                                        return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
                                                    })) {
                                                    return false;
                                                }
                                            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {
                                                return false;
                                            }
                                        }
                                        return true;
                                    }

                                    /**
                                     * A specialized version of `baseIsEqualDeep` for comparing objects of
                                     * the same `toStringTag`.
                                     *
                                     * **Note:** This function only supports comparing values with tags of
                                     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
                                     *
                                     * @private
                                     * @param {Object} object The object to compare.
                                     * @param {Object} other The other object to compare.
                                     * @param {string} tag The `toStringTag` of the objects to compare.
                                     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
                                     */
                                    function equalByTag(object, other, tag) {
                                        switch (tag) {
                                            case boolTag:
                                            case dateTag:
                                                // Coerce dates and booleans to numbers, dates to milliseconds and booleans
                                                // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
                                                return +object == +other;

                                            case errorTag:
                                                return object.name == other.name && object.message == other.message;

                                            case numberTag:
                                                // Treat `NaN` vs. `NaN` as equal.
                                                return (object != +object)
                                                    ? other != +other
                                                    : object == +other;

                                            case regexpTag:
                                            case stringTag:
                                                // Coerce regexes to strings and treat strings primitives and string
                                                // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
                                                return object == (other + '');
                                        }
                                        return false;
                                    }

                                    /**
                                     * A specialized version of `baseIsEqualDeep` for objects with support for
                                     * partial deep comparisons.
                                     *
                                     * @private
                                     * @param {Object} object The object to compare.
                                     * @param {Object} other The other object to compare.
                                     * @param {Function} equalFunc The function to determine equivalents of values.
                                     * @param {Function} [customizer] The function to customize comparing values.
                                     * @param {boolean} [isLoose] Specify performing partial comparisons.
                                     * @param {Array} [stackA] Tracks traversed `value` objects.
                                     * @param {Array} [stackB] Tracks traversed `other` objects.
                                     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
                                     */
                                    function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
                                        var objProps = keys(object),
                                            objLength = objProps.length,
                                            othProps = keys(other),
                                            othLength = othProps.length;

                                        if (objLength != othLength && !isLoose) {
                                            return false;
                                        }
                                        var index = objLength;
                                        while (index--) {
                                            var key = objProps[index];
                                            if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
                                                return false;
                                            }
                                        }
                                        var skipCtor = isLoose;
                                        while (++index < objLength) {
                                            key = objProps[index];
                                            var objValue = object[key],
                                                othValue = other[key],
                                                result = customizer ? customizer(isLoose ? othValue : objValue, isLoose ? objValue : othValue, key) : undefined;

                                            // Recursively compare objects (susceptible to call stack limits).
                                            if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {
                                                return false;
                                            }
                                            skipCtor || (skipCtor = key == 'constructor');
                                        }
                                        if (!skipCtor) {
                                            var objCtor = object.constructor,
                                                othCtor = other.constructor;

                                            // Non `Object` object instances with different constructors are not equal.
                                            if (objCtor != othCtor &&
                                                ('constructor' in object && 'constructor' in other) &&
                                                !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
                                                    typeof othCtor == 'function' && othCtor instanceof othCtor)) {
                                                return false;
                                            }
                                        }
                                        return true;
                                    }

                                    /**
                                     * Gets the appropriate "callback" function. If the `_.callback` method is
                                     * customized this function returns the custom method, otherwise it returns
                                     * the `baseCallback` function. If arguments are provided the chosen function
                                     * is invoked with them and its result is returned.
                                     *
                                     * @private
                                     * @returns {Function} Returns the chosen function or its result.
                                     */
                                    function getCallback(func, thisArg, argCount) {
                                        var result = lodash.callback || callback;
                                        result = result === callback ? baseCallback : result;
                                        return argCount ? result(func, thisArg, argCount) : result;
                                    }

                                    /**
                                     * Gets metadata for `func`.
                                     *
                                     * @private
                                     * @param {Function} func The function to query.
                                     * @returns {*} Returns the metadata for `func`.
                                     */
                                    var getData = !metaMap ? noop : function (func) {
                                        return metaMap.get(func);
                                    };

                                    /**
                                     * Gets the name of `func`.
                                     *
                                     * @private
                                     * @param {Function} func The function to query.
                                     * @returns {string} Returns the function name.
                                     */
                                    function getFuncName(func) {
                                        var result = func.name,
                                            array = realNames[result],
                                            length = array ? array.length : 0;

                                        while (length--) {
                                            var data = array[length],
                                                otherFunc = data.func;
                                            if (otherFunc == null || otherFunc == func) {
                                                return data.name;
                                            }
                                        }
                                        return result;
                                    }

                                    /**
                                     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
                                     * customized this function returns the custom method, otherwise it returns
                                     * the `baseIndexOf` function. If arguments are provided the chosen function
                                     * is invoked with them and its result is returned.
                                     *
                                     * @private
                                     * @returns {Function|number} Returns the chosen function or its result.
                                     */
                                    function getIndexOf(collection, target, fromIndex) {
                                        var result = lodash.indexOf || indexOf;
                                        result = result === indexOf ? baseIndexOf : result;
                                        return collection ? result(collection, target, fromIndex) : result;
                                    }

                                    /**
                                     * Gets the "length" property value of `object`.
                                     *
                                     * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
                                     * that affects Safari on at least iOS 8.1-8.3 ARM64.
                                     *
                                     * @private
                                     * @param {Object} object The object to query.
                                     * @returns {*} Returns the "length" value.
                                     */
                                    var getLength = baseProperty('length');

                                    /**
                                     * Gets the propery names, values, and compare flags of `object`.
                                     *
                                     * @private
                                     * @param {Object} object The object to query.
                                     * @returns {Array} Returns the match data of `object`.
                                     */
                                    function getMatchData(object) {
                                        var result = pairs(object),
                                            length = result.length;

                                        while (length--) {
                                            result[length][2] = isStrictComparable(result[length][1]);
                                        }
                                        return result;
                                    }

                                    /**
                                     * Gets the native function at `key` of `object`.
                                     *
                                     * @private
                                     * @param {Object} object The object to query.
                                     * @param {string} key The key of the method to get.
                                     * @returns {*} Returns the function if it's native, else `undefined`.
                                     */
                                    function getNative(object, key) {
                                        var value = object == null ? undefined : object[key];
                                        return isNative(value) ? value : undefined;
                                    }

                                    /**
                                     * Gets the view, applying any `transforms` to the `start` and `end` positions.
                                     *
                                     * @private
                                     * @param {number} start The start of the view.
                                     * @param {number} end The end of the view.
                                     * @param {Array} transforms The transformations to apply to the view.
                                     * @returns {Object} Returns an object containing the `start` and `end`
                                     *  positions of the view.
                                     */
                                    function getView(start, end, transforms) {
                                        var index = -1,
                                            length = transforms.length;

                                        while (++index < length) {
                                            var data = transforms[index],
                                                size = data.size;

                                            switch (data.type) {
                                                case 'drop':
                                                    start += size;
                                                    break;
                                                case 'dropRight':
                                                    end -= size;
                                                    break;
                                                case 'take':
                                                    end = nativeMin(end, start + size);
                                                    break;
                                                case 'takeRight':
                                                    start = nativeMax(start, end - size);
                                                    break;
                                            }
                                        }
                                        return {'start': start, 'end': end};
                                    }

                                    /**
                                     * Initializes an array clone.
                                     *
                                     * @private
                                     * @param {Array} array The array to clone.
                                     * @returns {Array} Returns the initialized clone.
                                     */
                                    function initCloneArray(array) {
                                        var length = array.length,
                                            result = new array.constructor(length);

                                        // Add array properties assigned by `RegExp#exec`.
                                        if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
                                            result.index = array.index;
                                            result.input = array.input;
                                        }
                                        return result;
                                    }

                                    /**
                                     * Initializes an object clone.
                                     *
                                     * @private
                                     * @param {Object} object The object to clone.
                                     * @returns {Object} Returns the initialized clone.
                                     */
                                    function initCloneObject(object) {
                                        var Ctor = object.constructor;
                                        if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
                                            Ctor = Object;
                                        }
                                        return new Ctor;
                                    }

                                    /**
                                     * Initializes an object clone based on its `toStringTag`.
                                     *
                                     * **Note:** This function only supports cloning values with tags of
                                     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
                                     *
                                     * @private
                                     * @param {Object} object The object to clone.
                                     * @param {string} tag The `toStringTag` of the object to clone.
                                     * @param {boolean} [isDeep] Specify a deep clone.
                                     * @returns {Object} Returns the initialized clone.
                                     */
                                    function initCloneByTag(object, tag, isDeep) {
                                        var Ctor = object.constructor;
                                        switch (tag) {
                                            case arrayBufferTag:
                                                return bufferClone(object);

                                            case boolTag:
                                            case dateTag:
                                                return new Ctor(+object);

                                            case float32Tag:
                                            case float64Tag:
                                            case int8Tag:
                                            case int16Tag:
                                            case int32Tag:
                                            case uint8Tag:
                                            case uint8ClampedTag:
                                            case uint16Tag:
                                            case uint32Tag:
                                                var buffer = object.buffer;
                                                return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);

                                            case numberTag:
                                            case stringTag:
                                                return new Ctor(object);

                                            case regexpTag:
                                                var result = new Ctor(object.source, reFlags.exec(object));
                                                result.lastIndex = object.lastIndex;
                                        }
                                        return result;
                                    }

                                    /**
                                     * Invokes the method at `path` on `object`.
                                     *
                                     * @private
                                     * @param {Object} object The object to query.
                                     * @param {Array|string} path The path of the method to invoke.
                                     * @param {Array} args The arguments to invoke the method with.
                                     * @returns {*} Returns the result of the invoked method.
                                     */
                                    function invokePath(object, path, args) {
                                        if (object != null && !isKey(path, object)) {
                                            path = toPath(path);
                                            object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
                                            path = last(path);
                                        }
                                        var func = object == null ? object : object[path];
                                        return func == null ? undefined : func.apply(object, args);
                                    }

                                    /**
                                     * Checks if `value` is array-like.
                                     *
                                     * @private
                                     * @param {*} value The value to check.
                                     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
                                     */
                                    function isArrayLike(value) {
                                        return value != null && isLength(getLength(value));
                                    }

                                    /**
                                     * Checks if `value` is a valid array-like index.
                                     *
                                     * @private
                                     * @param {*} value The value to check.
                                     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
                                     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
                                     */
                                    function isIndex(value, length) {
                                        value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
                                        length = length == null ? MAX_SAFE_INTEGER : length;
                                        return value > -1 && value % 1 == 0 && value < length;
                                    }

                                    /**
                                     * Checks if the provided arguments are from an iteratee call.
                                     *
                                     * @private
                                     * @param {*} value The potential iteratee value argument.
                                     * @param {*} index The potential iteratee index or key argument.
                                     * @param {*} object The potential iteratee object argument.
                                     * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
                                     */
                                    function isIterateeCall(value, index, object) {
                                        if (!isObject(object)) {
                                            return false;
                                        }
                                        var type = typeof index;
                                        if (type == 'number'
                                                ? (isArrayLike(object) && isIndex(index, object.length))
                                                : (type == 'string' && index in object)) {
                                            var other = object[index];
                                            return value === value ? (value === other) : (other !== other);
                                        }
                                        return false;
                                    }

                                    /**
                                     * Checks if `value` is a property name and not a property path.
                                     *
                                     * @private
                                     * @param {*} value The value to check.
                                     * @param {Object} [object] The object to query keys on.
                                     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
                                     */
                                    function isKey(value, object) {
                                        var type = typeof value;
                                        if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
                                            return true;
                                        }
                                        if (isArray(value)) {
                                            return false;
                                        }
                                        var result = !reIsDeepProp.test(value);
                                        return result || (object != null && value in toObject(object));
                                    }

                                    /**
                                     * Checks if `func` has a lazy counterpart.
                                     *
                                     * @private
                                     * @param {Function} func The function to check.
                                     * @returns {boolean} Returns `true` if `func` has a lazy counterpart, else `false`.
                                     */
                                    function isLaziable(func) {
                                        var funcName = getFuncName(func);
                                        if (!(funcName in LazyWrapper.prototype)) {
                                            return false;
                                        }
                                        var other = lodash[funcName];
                                        if (func === other) {
                                            return true;
                                        }
                                        var data = getData(other);
                                        return !!data && func === data[0];
                                    }

                                    /**
                                     * Checks if `value` is a valid array-like length.
                                     *
                                     * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
                                     *
                                     * @private
                                     * @param {*} value The value to check.
                                     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
                                     */
                                    function isLength(value) {
                                        return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
                                    }

                                    /**
                                     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
                                     *
                                     * @private
                                     * @param {*} value The value to check.
                                     * @returns {boolean} Returns `true` if `value` if suitable for strict
                                     *  equality comparisons, else `false`.
                                     */
                                    function isStrictComparable(value) {
                                        return value === value && !isObject(value);
                                    }

                                    /**
                                     * Merges the function metadata of `source` into `data`.
                                     *
                                     * Merging metadata reduces the number of wrappers required to invoke a function.
                                     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
                                     * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`
                                     * augment function arguments, making the order in which they are executed important,
                                     * preventing the merging of metadata. However, we make an exception for a safe
                                     * common case where curried functions have `_.ary` and or `_.rearg` applied.
                                     *
                                     * @private
                                     * @param {Array} data The destination metadata.
                                     * @param {Array} source The source metadata.
                                     * @returns {Array} Returns `data`.
                                     */
                                    function mergeData(data, source) {
                                        var bitmask = data[1],
                                            srcBitmask = source[1],
                                            newBitmask = bitmask | srcBitmask,
                                            isCommon = newBitmask < ARY_FLAG;

                                        var isCombo =
                                            (srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG) ||
                                            (srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8]) ||
                                            (srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG);

                                        // Exit early if metadata can't be merged.
                                        if (!(isCommon || isCombo)) {
                                            return data;
                                        }
                                        // Use source `thisArg` if available.
                                        if (srcBitmask & BIND_FLAG) {
                                            data[2] = source[2];
                                            // Set when currying a bound function.
                                            newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
                                        }
                                        // Compose partial arguments.
                                        var value = source[3];
                                        if (value) {
                                            var partials = data[3];
                                            data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
                                            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
                                        }
                                        // Compose partial right arguments.
                                        value = source[5];
                                        if (value) {
                                            partials = data[5];
                                            data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
                                            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
                                        }
                                        // Use source `argPos` if available.
                                        value = source[7];
                                        if (value) {
                                            data[7] = arrayCopy(value);
                                        }
                                        // Use source `ary` if it's smaller.
                                        if (srcBitmask & ARY_FLAG) {
                                            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
                                        }
                                        // Use source `arity` if one is not provided.
                                        if (data[9] == null) {
                                            data[9] = source[9];
                                        }
                                        // Use source `func` and merge bitmasks.
                                        data[0] = source[0];
                                        data[1] = newBitmask;

                                        return data;
                                    }

                                    /**
                                     * Used by `_.defaultsDeep` to customize its `_.merge` use.
                                     *
                                     * @private
                                     * @param {*} objectValue The destination object property value.
                                     * @param {*} sourceValue The source object property value.
                                     * @returns {*} Returns the value to assign to the destination object.
                                     */
                                    function mergeDefaults(objectValue, sourceValue) {
                                        return objectValue === undefined ? sourceValue : merge(objectValue, sourceValue, mergeDefaults);
                                    }

                                    /**
                                     * A specialized version of `_.pick` which picks `object` properties specified
                                     * by `props`.
                                     *
                                     * @private
                                     * @param {Object} object The source object.
                                     * @param {string[]} props The property names to pick.
                                     * @returns {Object} Returns the new object.
                                     */
                                    function pickByArray(object, props) {
                                        object = toObject(object);

                                        var index = -1,
                                            length = props.length,
                                            result = {};

                                        while (++index < length) {
                                            var key = props[index];
                                            if (key in object) {
                                                result[key] = object[key];
                                            }
                                        }
                                        return result;
                                    }

                                    /**
                                     * A specialized version of `_.pick` which picks `object` properties `predicate`
                                     * returns truthy for.
                                     *
                                     * @private
                                     * @param {Object} object The source object.
                                     * @param {Function} predicate The function invoked per iteration.
                                     * @returns {Object} Returns the new object.
                                     */
                                    function pickByCallback(object, predicate) {
                                        var result = {};
                                        baseForIn(object, function (value, key, object) {
                                            if (predicate(value, key, object)) {
                                                result[key] = value;
                                            }
                                        });
                                        return result;
                                    }

                                    /**
                                     * Reorder `array` according to the specified indexes where the element at
                                     * the first index is assigned as the first element, the element at
                                     * the second index is assigned as the second element, and so on.
                                     *
                                     * @private
                                     * @param {Array} array The array to reorder.
                                     * @param {Array} indexes The arranged array indexes.
                                     * @returns {Array} Returns `array`.
                                     */
                                    function reorder(array, indexes) {
                                        var arrLength = array.length,
                                            length = nativeMin(indexes.length, arrLength),
                                            oldArray = arrayCopy(array);

                                        while (length--) {
                                            var index = indexes[length];
                                            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
                                        }
                                        return array;
                                    }

                                    /**
                                     * Sets metadata for `func`.
                                     *
                                     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
                                     * period of time, it will trip its breaker and transition to an identity function
                                     * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)
                                     * for more details.
                                     *
                                     * @private
                                     * @param {Function} func The function to associate metadata with.
                                     * @param {*} data The metadata.
                                     * @returns {Function} Returns `func`.
                                     */
                                    var setData = (function () {
                                        var count = 0,
                                            lastCalled = 0;

                                        return function (key, value) {
                                            var stamp = now(),
                                                remaining = HOT_SPAN - (stamp - lastCalled);

                                            lastCalled = stamp;
                                            if (remaining > 0) {
                                                if (++count >= HOT_COUNT) {
                                                    return key;
                                                }
                                            } else {
                                                count = 0;
                                            }
                                            return baseSetData(key, value);
                                        };
                                    }());

                                    /**
                                     * A fallback implementation of `Object.keys` which creates an array of the
                                     * own enumerable property names of `object`.
                                     *
                                     * @private
                                     * @param {Object} object The object to query.
                                     * @returns {Array} Returns the array of property names.
                                     */
                                    function shimKeys(object) {
                                        var props = keysIn(object),
                                            propsLength = props.length,
                                            length = propsLength && object.length;

                                        var allowIndexes = !!length && isLength(length) &&
                                            (isArray(object) || isArguments(object));

                                        var index = -1,
                                            result = [];

                                        while (++index < propsLength) {
                                            var key = props[index];
                                            if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
                                                result.push(key);
                                            }
                                        }
                                        return result;
                                    }

                                    /**
                                     * Converts `value` to an array-like object if it's not one.
                                     *
                                     * @private
                                     * @param {*} value The value to process.
                                     * @returns {Array|Object} Returns the array-like object.
                                     */
                                    function toIterable(value) {
                                        if (value == null) {
                                            return [];
                                        }
                                        if (!isArrayLike(value)) {
                                            return values(value);
                                        }
                                        return isObject(value) ? value : Object(value);
                                    }

                                    /**
                                     * Converts `value` to an object if it's not one.
                                     *
                                     * @private
                                     * @param {*} value The value to process.
                                     * @returns {Object} Returns the object.
                                     */
                                    function toObject(value) {
                                        return isObject(value) ? value : Object(value);
                                    }

                                    /**
                                     * Converts `value` to property path array if it's not one.
                                     *
                                     * @private
                                     * @param {*} value The value to process.
                                     * @returns {Array} Returns the property path array.
                                     */
                                    function toPath(value) {
                                        if (isArray(value)) {
                                            return value;
                                        }
                                        var result = [];
                                        baseToString(value).replace(rePropName, function (match, number, quote, string) {
                                            result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
                                        });
                                        return result;
                                    }

                                    /**
                                     * Creates a clone of `wrapper`.
                                     *
                                     * @private
                                     * @param {Object} wrapper The wrapper to clone.
                                     * @returns {Object} Returns the cloned wrapper.
                                     */
                                    function wrapperClone(wrapper) {
                                        return wrapper instanceof LazyWrapper
                                            ? wrapper.clone()
                                            : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
                                    }

                                    /*------------------------------------------------------------------------*/

                                    /**
                                     * Creates an array of elements split into groups the length of `size`.
                                     * If `collection` can't be split evenly, the final chunk will be the remaining
                                     * elements.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Array
                                     * @param {Array} array The array to process.
                                     * @param {number} [size=1] The length of each chunk.
                                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                                     * @returns {Array} Returns the new array containing chunks.
                                     * @example
                                     *
                                     * _.chunk(['a', 'b', 'c', 'd'], 2);
                                     * // => [['a', 'b'], ['c', 'd']]
                                     *
                                     * _.chunk(['a', 'b', 'c', 'd'], 3);
                                     * // => [['a', 'b', 'c'], ['d']]
                                     */
                                    function chunk(array, size, guard) {
                                        if (guard ? isIterateeCall(array, size, guard) : size == null) {
                                            size = 1;
                                        } else {
                                            size = nativeMax(nativeFloor(size) || 1, 1);
                                        }
                                        var index = 0,
                                            length = array ? array.length : 0,
                                            resIndex = -1,
                                            result = Array(nativeCeil(length / size));

                                        while (index < length) {
                                            result[++resIndex] = baseSlice(array, index, (index += size));
                                        }
                                        return result;
                                    }

                                    /**
                                     * Creates an array with all falsey values removed. The values `false`, `null`,
                                     * `0`, `""`, `undefined`, and `NaN` are falsey.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Array
                                     * @param {Array} array The array to compact.
                                     * @returns {Array} Returns the new array of filtered values.
                                     * @example
                                     *
                                     * _.compact([0, 1, false, 2, '', 3]);
                                     * // => [1, 2, 3]
                                     */
                                    function compact(array) {
                                        var index = -1,
                                            length = array ? array.length : 0,
                                            resIndex = -1,
                                            result = [];

                                        while (++index < length) {
                                            var value = array[index];
                                            if (value) {
                                                result[++resIndex] = value;
                                            }
                                        }
                                        return result;
                                    }

                                    /**
                                     * Creates an array of unique `array` values not included in the other
                                     * provided arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
                                     * for equality comparisons.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Array
                                     * @param {Array} array The array to inspect.
                                     * @param {...Array} [values] The arrays of values to exclude.
                                     * @returns {Array} Returns the new array of filtered values.
                                     * @example
                                     *
                                     * _.difference([1, 2, 3], [4, 2]);
                                     * // => [1, 3]
                                     */
                                    var difference = restParam(function (array, values) {
                                        return (isObjectLike(array) && isArrayLike(array))
                                            ? baseDifference(array, baseFlatten(values, false, true))
                                            : [];
                                    });

                                    /**
                                     * Creates a slice of `array` with `n` elements dropped from the beginning.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Array
                                     * @param {Array} array The array to query.
                                     * @param {number} [n=1] The number of elements to drop.
                                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                                     * @returns {Array} Returns the slice of `array`.
                                     * @example
                                     *
                                     * _.drop([1, 2, 3]);
                                     * // => [2, 3]
                                     *
                                     * _.drop([1, 2, 3], 2);
                                     * // => [3]
                                     *
                                     * _.drop([1, 2, 3], 5);
                                     * // => []
                                     *
                                     * _.drop([1, 2, 3], 0);
                                     * // => [1, 2, 3]
                                     */
                                    function drop(array, n, guard) {
                                        var length = array ? array.length : 0;
                                        if (!length) {
                                            return [];
                                        }
                                        if (guard ? isIterateeCall(array, n, guard) : n == null) {
                                            n = 1;
                                        }
                                        return baseSlice(array, n < 0 ? 0 : n);
                                    }

                                    /**
                                     * Creates a slice of `array` with `n` elements dropped from the end.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Array
                                     * @param {Array} array The array to query.
                                     * @param {number} [n=1] The number of elements to drop.
                                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                                     * @returns {Array} Returns the slice of `array`.
                                     * @example
                                     *
                                     * _.dropRight([1, 2, 3]);
                                     * // => [1, 2]
                                     *
                                     * _.dropRight([1, 2, 3], 2);
                                     * // => [1]
                                     *
                                     * _.dropRight([1, 2, 3], 5);
                                     * // => []
                                     *
                                     * _.dropRight([1, 2, 3], 0);
                                     * // => [1, 2, 3]
                                     */
                                    function dropRight(array, n, guard) {
                                        var length = array ? array.length : 0;
                                        if (!length) {
                                            return [];
                                        }
                                        if (guard ? isIterateeCall(array, n, guard) : n == null) {
                                            n = 1;
                                        }
                                        n = length - (+n || 0);
                                        return baseSlice(array, 0, n < 0 ? 0 : n);
                                    }

                                    /**
                                     * Creates a slice of `array` excluding elements dropped from the end.
                                     * Elements are dropped until `predicate` returns falsey. The predicate is
                                     * bound to `thisArg` and invoked with three arguments: (value, index, array).
                                     *
                                     * If a property name is provided for `predicate` the created `_.property`
                                     * style callback returns the property value of the given element.
                                     *
                                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                                     * style callback returns `true` for elements that have a matching property
                                     * value, else `false`.
                                     *
                                     * If an object is provided for `predicate` the created `_.matches` style
                                     * callback returns `true` for elements that match the properties of the given
                                     * object, else `false`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Array
                                     * @param {Array} array The array to query.
                                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                                     *  per iteration.
                                     * @param {*} [thisArg] The `this` binding of `predicate`.
                                     * @returns {Array} Returns the slice of `array`.
                                     * @example
                                     *
                                     * _.dropRightWhile([1, 2, 3], function(n) {
     *   return n > 1;
     * });
                                     * // => [1]
                                     *
                                     * var users = [
                                     *   { 'user': 'barney',  'active': true },
                                     *   { 'user': 'fred',    'active': false },
                                     *   { 'user': 'pebbles', 'active': false }
                                     * ];
                                     *
                                     * // using the `_.matches` callback shorthand
                                     * _.pluck(_.dropRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
                                     * // => ['barney', 'fred']
                                     *
                                     * // using the `_.matchesProperty` callback shorthand
                                     * _.pluck(_.dropRightWhile(users, 'active', false), 'user');
                                     * // => ['barney']
                                     *
                                     * // using the `_.property` callback shorthand
                                     * _.pluck(_.dropRightWhile(users, 'active'), 'user');
                                     * // => ['barney', 'fred', 'pebbles']
                                     */
                                    function dropRightWhile(array, predicate, thisArg) {
                                        return (array && array.length)
                                            ? baseWhile(array, getCallback(predicate, thisArg, 3), true, true)
                                            : [];
                                    }

                                    /**
                                     * Creates a slice of `array` excluding elements dropped from the beginning.
                                     * Elements are dropped until `predicate` returns falsey. The predicate is
                                     * bound to `thisArg` and invoked with three arguments: (value, index, array).
                                     *
                                     * If a property name is provided for `predicate` the created `_.property`
                                     * style callback returns the property value of the given element.
                                     *
                                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                                     * style callback returns `true` for elements that have a matching property
                                     * value, else `false`.
                                     *
                                     * If an object is provided for `predicate` the created `_.matches` style
                                     * callback returns `true` for elements that have the properties of the given
                                     * object, else `false`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Array
                                     * @param {Array} array The array to query.
                                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                                     *  per iteration.
                                     * @param {*} [thisArg] The `this` binding of `predicate`.
                                     * @returns {Array} Returns the slice of `array`.
                                     * @example
                                     *
                                     * _.dropWhile([1, 2, 3], function(n) {
     *   return n < 3;
     * });
                                     * // => [3]
                                     *
                                     * var users = [
                                     *   { 'user': 'barney',  'active': false },
                                     *   { 'user': 'fred',    'active': false },
                                     *   { 'user': 'pebbles', 'active': true }
                                     * ];
                                     *
                                     * // using the `_.matches` callback shorthand
                                     * _.pluck(_.dropWhile(users, { 'user': 'barney', 'active': false }), 'user');
                                     * // => ['fred', 'pebbles']
                                     *
                                     * // using the `_.matchesProperty` callback shorthand
                                     * _.pluck(_.dropWhile(users, 'active', false), 'user');
                                     * // => ['pebbles']
                                     *
                                     * // using the `_.property` callback shorthand
                                     * _.pluck(_.dropWhile(users, 'active'), 'user');
                                     * // => ['barney', 'fred', 'pebbles']
                                     */
                                    function dropWhile(array, predicate, thisArg) {
                                        return (array && array.length)
                                            ? baseWhile(array, getCallback(predicate, thisArg, 3), true)
                                            : [];
                                    }

                                    /**
                                     * Fills elements of `array` with `value` from `start` up to, but not
                                     * including, `end`.
                                     *
                                     * **Note:** This method mutates `array`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Array
                                     * @param {Array} array The array to fill.
                                     * @param {*} value The value to fill `array` with.
                                     * @param {number} [start=0] The start position.
                                     * @param {number} [end=array.length] The end position.
                                     * @returns {Array} Returns `array`.
                                     * @example
                                     *
                                     * var array = [1, 2, 3];
                                     *
                                     * _.fill(array, 'a');
                                     * console.log(array);
                                     * // => ['a', 'a', 'a']
                                     *
                                     * _.fill(Array(3), 2);
                                     * // => [2, 2, 2]
                                     *
                                     * _.fill([4, 6, 8], '*', 1, 2);
                                     * // => [4, '*', 8]
                                     */
                                    function fill(array, value, start, end) {
                                        var length = array ? array.length : 0;
                                        if (!length) {
                                            return [];
                                        }
                                        if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
                                            start = 0;
                                            end = length;
                                        }
                                        return baseFill(array, value, start, end);
                                    }

                                    /**
                                     * This method is like `_.find` except that it returns the index of the first
                                     * element `predicate` returns truthy for instead of the element itself.
                                     *
                                     * If a property name is provided for `predicate` the created `_.property`
                                     * style callback returns the property value of the given element.
                                     *
                                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                                     * style callback returns `true` for elements that have a matching property
                                     * value, else `false`.
                                     *
                                     * If an object is provided for `predicate` the created `_.matches` style
                                     * callback returns `true` for elements that have the properties of the given
                                     * object, else `false`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Array
                                     * @param {Array} array The array to search.
                                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                                     *  per iteration.
                                     * @param {*} [thisArg] The `this` binding of `predicate`.
                                     * @returns {number} Returns the index of the found element, else `-1`.
                                     * @example
                                     *
                                     * var users = [
                                     *   { 'user': 'barney',  'active': false },
                                     *   { 'user': 'fred',    'active': false },
                                     *   { 'user': 'pebbles', 'active': true }
                                     * ];
                                     *
                                     * _.findIndex(users, function(chr) {
     *   return chr.user == 'barney';
     * });
                                     * // => 0
                                     *
                                     * // using the `_.matches` callback shorthand
                                     * _.findIndex(users, { 'user': 'fred', 'active': false });
                                     * // => 1
                                     *
                                     * // using the `_.matchesProperty` callback shorthand
                                     * _.findIndex(users, 'active', false);
                                     * // => 0
                                     *
                                     * // using the `_.property` callback shorthand
                                     * _.findIndex(users, 'active');
                                     * // => 2
                                     */
                                    var findIndex = createFindIndex();

                                    /**
                                     * This method is like `_.findIndex` except that it iterates over elements
                                     * of `collection` from right to left.
                                     *
                                     * If a property name is provided for `predicate` the created `_.property`
                                     * style callback returns the property value of the given element.
                                     *
                                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                                     * style callback returns `true` for elements that have a matching property
                                     * value, else `false`.
                                     *
                                     * If an object is provided for `predicate` the created `_.matches` style
                                     * callback returns `true` for elements that have the properties of the given
                                     * object, else `false`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Array
                                     * @param {Array} array The array to search.
                                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                                     *  per iteration.
                                     * @param {*} [thisArg] The `this` binding of `predicate`.
                                     * @returns {number} Returns the index of the found element, else `-1`.
                                     * @example
                                     *
                                     * var users = [
                                     *   { 'user': 'barney',  'active': true },
                                     *   { 'user': 'fred',    'active': false },
                                     *   { 'user': 'pebbles', 'active': false }
                                     * ];
                                     *
                                     * _.findLastIndex(users, function(chr) {
     *   return chr.user == 'pebbles';
     * });
                                     * // => 2
                                     *
                                     * // using the `_.matches` callback shorthand
                                     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
                                     * // => 0
                                     *
                                     * // using the `_.matchesProperty` callback shorthand
                                     * _.findLastIndex(users, 'active', false);
                                     * // => 2
                                     *
                                     * // using the `_.property` callback shorthand
                                     * _.findLastIndex(users, 'active');
                                     * // => 0
                                     */
                                    var findLastIndex = createFindIndex(true);

                                    /**
                                     * Gets the first element of `array`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @alias head
                                     * @category Array
                                     * @param {Array} array The array to query.
                                     * @returns {*} Returns the first element of `array`.
                                     * @example
                                     *
                                     * _.first([1, 2, 3]);
                                     * // => 1
                                     *
                                     * _.first([]);
                                     * // => undefined
                                     */
                                    function first(array) {
                                        return array ? array[0] : undefined;
                                    }

                                    /**
                                     * Flattens a nested array. If `isDeep` is `true` the array is recursively
                                     * flattened, otherwise it is only flattened a single level.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Array
                                     * @param {Array} array The array to flatten.
                                     * @param {boolean} [isDeep] Specify a deep flatten.
                                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                                     * @returns {Array} Returns the new flattened array.
                                     * @example
                                     *
                                     * _.flatten([1, [2, 3, [4]]]);
                                     * // => [1, 2, 3, [4]]
                                     *
                                     * // using `isDeep`
                                     * _.flatten([1, [2, 3, [4]]], true);
                                     * // => [1, 2, 3, 4]
                                     */
                                    function flatten(array, isDeep, guard) {
                                        var length = array ? array.length : 0;
                                        if (guard && isIterateeCall(array, isDeep, guard)) {
                                            isDeep = false;
                                        }
                                        return length ? baseFlatten(array, isDeep) : [];
                                    }

                                    /**
                                     * Recursively flattens a nested array.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Array
                                     * @param {Array} array The array to recursively flatten.
                                     * @returns {Array} Returns the new flattened array.
                                     * @example
                                     *
                                     * _.flattenDeep([1, [2, 3, [4]]]);
                                     * // => [1, 2, 3, 4]
                                     */
                                    function flattenDeep(array) {
                                        var length = array ? array.length : 0;
                                        return length ? baseFlatten(array, true) : [];
                                    }

                                    /**
                                     * Gets the index at which the first occurrence of `value` is found in `array`
                                     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
                                     * for equality comparisons. If `fromIndex` is negative, it is used as the offset
                                     * from the end of `array`. If `array` is sorted providing `true` for `fromIndex`
                                     * performs a faster binary search.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Array
                                     * @param {Array} array The array to search.
                                     * @param {*} value The value to search for.
                                     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
                                     *  to perform a binary search on a sorted array.
                                     * @returns {number} Returns the index of the matched value, else `-1`.
                                     * @example
                                     *
                                     * _.indexOf([1, 2, 1, 2], 2);
                                     * // => 1
                                     *
                                     * // using `fromIndex`
                                     * _.indexOf([1, 2, 1, 2], 2, 2);
                                     * // => 3
                                     *
                                     * // performing a binary search
                                     * _.indexOf([1, 1, 2, 2], 2, true);
                                     * // => 2
                                     */
                                    function indexOf(array, value, fromIndex) {
                                        var length = array ? array.length : 0;
                                        if (!length) {
                                            return -1;
                                        }
                                        if (typeof fromIndex == 'number') {
                                            fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;
                                        } else if (fromIndex) {
                                            var index = binaryIndex(array, value);
                                            if (index < length &&
                                                (value === value ? (value === array[index]) : (array[index] !== array[index]))) {
                                                return index;
                                            }
                                            return -1;
                                        }
                                        return baseIndexOf(array, value, fromIndex || 0);
                                    }

                                    /**
                                     * Gets all but the last element of `array`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Array
                                     * @param {Array} array The array to query.
                                     * @returns {Array} Returns the slice of `array`.
                                     * @example
                                     *
                                     * _.initial([1, 2, 3]);
                                     * // => [1, 2]
                                     */
                                    function initial(array) {
                                        return dropRight(array, 1);
                                    }

                                    /**
                                     * Creates an array of unique values that are included in all of the provided
                                     * arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
                                     * for equality comparisons.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Array
                                     * @param {...Array} [arrays] The arrays to inspect.
                                     * @returns {Array} Returns the new array of shared values.
                                     * @example
                                     * _.intersection([1, 2], [4, 2], [2, 1]);
                                     * // => [2]
                                     */
                                    var intersection = restParam(function (arrays) {
                                        var othLength = arrays.length,
                                            othIndex = othLength,
                                            caches = Array(length),
                                            indexOf = getIndexOf(),
                                            isCommon = indexOf == baseIndexOf,
                                            result = [];

                                        while (othIndex--) {
                                            var value = arrays[othIndex] = isArrayLike(value = arrays[othIndex]) ? value : [];
                                            caches[othIndex] = (isCommon && value.length >= 120) ? createCache(othIndex && value) : null;
                                        }
                                        var array = arrays[0],
                                            index = -1,
                                            length = array ? array.length : 0,
                                            seen = caches[0];

                                        outer:
                                            while (++index < length) {
                                                value = array[index];
                                                if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {
                                                    var othIndex = othLength;
                                                    while (--othIndex) {
                                                        var cache = caches[othIndex];
                                                        if ((cache ? cacheIndexOf(cache, value) : indexOf(arrays[othIndex], value, 0)) < 0) {
                                                            continue outer;
                                                        }
                                                    }
                                                    if (seen) {
                                                        seen.push(value);
                                                    }
                                                    result.push(value);
                                                }
                                            }
                                        return result;
                                    });

                                    /**
                                     * Gets the last element of `array`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Array
                                     * @param {Array} array The array to query.
                                     * @returns {*} Returns the last element of `array`.
                                     * @example
                                     *
                                     * _.last([1, 2, 3]);
                                     * // => 3
                                     */
                                    function last(array) {
                                        var length = array ? array.length : 0;
                                        return length ? array[length - 1] : undefined;
                                    }

                                    /**
                                     * This method is like `_.indexOf` except that it iterates over elements of
                                     * `array` from right to left.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Array
                                     * @param {Array} array The array to search.
                                     * @param {*} value The value to search for.
                                     * @param {boolean|number} [fromIndex=array.length-1] The index to search from
                                     *  or `true` to perform a binary search on a sorted array.
                                     * @returns {number} Returns the index of the matched value, else `-1`.
                                     * @example
                                     *
                                     * _.lastIndexOf([1, 2, 1, 2], 2);
                                     * // => 3
                                     *
                                     * // using `fromIndex`
                                     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
                                     * // => 1
                                     *
                                     * // performing a binary search
                                     * _.lastIndexOf([1, 1, 2, 2], 2, true);
                                     * // => 3
                                     */
                                    function lastIndexOf(array, value, fromIndex) {
                                        var length = array ? array.length : 0;
                                        if (!length) {
                                            return -1;
                                        }
                                        var index = length;
                                        if (typeof fromIndex == 'number') {
                                            index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
                                        } else if (fromIndex) {
                                            index = binaryIndex(array, value, true) - 1;
                                            var other = array[index];
                                            if (value === value ? (value === other) : (other !== other)) {
                                                return index;
                                            }
                                            return -1;
                                        }
                                        if (value !== value) {
                                            return indexOfNaN(array, index, true);
                                        }
                                        while (index--) {
                                            if (array[index] === value) {
                                                return index;
                                            }
                                        }
                                        return -1;
                                    }

                                    /**
                                     * Removes all provided values from `array` using
                                     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
                                     * for equality comparisons.
                                     *
                                     * **Note:** Unlike `_.without`, this method mutates `array`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Array
                                     * @param {Array} array The array to modify.
                                     * @param {...*} [values] The values to remove.
                                     * @returns {Array} Returns `array`.
                                     * @example
                                     *
                                     * var array = [1, 2, 3, 1, 2, 3];
                                     *
                                     * _.pull(array, 2, 3);
                                     * console.log(array);
                                     * // => [1, 1]
                                     */
                                    function pull() {
                                        var args = arguments,
                                            array = args[0];

                                        if (!(array && array.length)) {
                                            return array;
                                        }
                                        var index = 0,
                                            indexOf = getIndexOf(),
                                            length = args.length;

                                        while (++index < length) {
                                            var fromIndex = 0,
                                                value = args[index];

                                            while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
                                                splice.call(array, fromIndex, 1);
                                            }
                                        }
                                        return array;
                                    }

                                    /**
                                     * Removes elements from `array` corresponding to the given indexes and returns
                                     * an array of the removed elements. Indexes may be specified as an array of
                                     * indexes or as individual arguments.
                                     *
                                     * **Note:** Unlike `_.at`, this method mutates `array`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Array
                                     * @param {Array} array The array to modify.
                                     * @param {...(number|number[])} [indexes] The indexes of elements to remove,
                                     *  specified as individual indexes or arrays of indexes.
                                     * @returns {Array} Returns the new array of removed elements.
                                     * @example
                                     *
                                     * var array = [5, 10, 15, 20];
                                     * var evens = _.pullAt(array, 1, 3);
                                     *
                                     * console.log(array);
                                     * // => [5, 15]
                                     *
                                     * console.log(evens);
                                     * // => [10, 20]
                                     */
                                    var pullAt = restParam(function (array, indexes) {
                                        indexes = baseFlatten(indexes);

                                        var result = baseAt(array, indexes);
                                        basePullAt(array, indexes.sort(baseCompareAscending));
                                        return result;
                                    });

                                    /**
                                     * Removes all elements from `array` that `predicate` returns truthy for
                                     * and returns an array of the removed elements. The predicate is bound to
                                     * `thisArg` and invoked with three arguments: (value, index, array).
                                     *
                                     * If a property name is provided for `predicate` the created `_.property`
                                     * style callback returns the property value of the given element.
                                     *
                                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                                     * style callback returns `true` for elements that have a matching property
                                     * value, else `false`.
                                     *
                                     * If an object is provided for `predicate` the created `_.matches` style
                                     * callback returns `true` for elements that have the properties of the given
                                     * object, else `false`.
                                     *
                                     * **Note:** Unlike `_.filter`, this method mutates `array`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Array
                                     * @param {Array} array The array to modify.
                                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                                     *  per iteration.
                                     * @param {*} [thisArg] The `this` binding of `predicate`.
                                     * @returns {Array} Returns the new array of removed elements.
                                     * @example
                                     *
                                     * var array = [1, 2, 3, 4];
                                     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
                                     *
                                     * console.log(array);
                                     * // => [1, 3]
                                     *
                                     * console.log(evens);
                                     * // => [2, 4]
                                     */
                                    function remove(array, predicate, thisArg) {
                                        var result = [];
                                        if (!(array && array.length)) {
                                            return result;
                                        }
                                        var index = -1,
                                            indexes = [],
                                            length = array.length;

                                        predicate = getCallback(predicate, thisArg, 3);
                                        while (++index < length) {
                                            var value = array[index];
                                            if (predicate(value, index, array)) {
                                                result.push(value);
                                                indexes.push(index);
                                            }
                                        }
                                        basePullAt(array, indexes);
                                        return result;
                                    }

                                    /**
                                     * Gets all but the first element of `array`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @alias tail
                                     * @category Array
                                     * @param {Array} array The array to query.
                                     * @returns {Array} Returns the slice of `array`.
                                     * @example
                                     *
                                     * _.rest([1, 2, 3]);
                                     * // => [2, 3]
                                     */
                                    function rest(array) {
                                        return drop(array, 1);
                                    }

                                    /**
                                     * Creates a slice of `array` from `start` up to, but not including, `end`.
                                     *
                                     * **Note:** This method is used instead of `Array#slice` to support node
                                     * lists in IE < 9 and to ensure dense arrays are returned.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Array
                                     * @param {Array} array The array to slice.
                                     * @param {number} [start=0] The start position.
                                     * @param {number} [end=array.length] The end position.
                                     * @returns {Array} Returns the slice of `array`.
                                     */
                                    function slice(array, start, end) {
                                        var length = array ? array.length : 0;
                                        if (!length) {
                                            return [];
                                        }
                                        if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
                                            start = 0;
                                            end = length;
                                        }
                                        return baseSlice(array, start, end);
                                    }

                                    /**
                                     * Uses a binary search to determine the lowest index at which `value` should
                                     * be inserted into `array` in order to maintain its sort order. If an iteratee
                                     * function is provided it is invoked for `value` and each element of `array`
                                     * to compute their sort ranking. The iteratee is bound to `thisArg` and
                                     * invoked with one argument; (value).
                                     *
                                     * If a property name is provided for `iteratee` the created `_.property`
                                     * style callback returns the property value of the given element.
                                     *
                                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                                     * style callback returns `true` for elements that have a matching property
                                     * value, else `false`.
                                     *
                                     * If an object is provided for `iteratee` the created `_.matches` style
                                     * callback returns `true` for elements that have the properties of the given
                                     * object, else `false`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Array
                                     * @param {Array} array The sorted array to inspect.
                                     * @param {*} value The value to evaluate.
                                     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
                                     *  per iteration.
                                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                                     * @returns {number} Returns the index at which `value` should be inserted
                                     *  into `array`.
                                     * @example
                                     *
                                     * _.sortedIndex([30, 50], 40);
                                     * // => 1
                                     *
                                     * _.sortedIndex([4, 4, 5, 5], 5);
                                     * // => 2
                                     *
                                     * var dict = { 'data': { 'thirty': 30, 'forty': 40, 'fifty': 50 } };
                                     *
                                     * // using an iteratee function
                                     * _.sortedIndex(['thirty', 'fifty'], 'forty', function(word) {
     *   return this.data[word];
     * }, dict);
                                     * // => 1
                                     *
                                     * // using the `_.property` callback shorthand
                                     * _.sortedIndex([{ 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
                                     * // => 1
                                     */
                                    var sortedIndex = createSortedIndex();

                                    /**
                                     * This method is like `_.sortedIndex` except that it returns the highest
                                     * index at which `value` should be inserted into `array` in order to
                                     * maintain its sort order.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Array
                                     * @param {Array} array The sorted array to inspect.
                                     * @param {*} value The value to evaluate.
                                     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
                                     *  per iteration.
                                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                                     * @returns {number} Returns the index at which `value` should be inserted
                                     *  into `array`.
                                     * @example
                                     *
                                     * _.sortedLastIndex([4, 4, 5, 5], 5);
                                     * // => 4
                                     */
                                    var sortedLastIndex = createSortedIndex(true);

                                    /**
                                     * Creates a slice of `array` with `n` elements taken from the beginning.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Array
                                     * @param {Array} array The array to query.
                                     * @param {number} [n=1] The number of elements to take.
                                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                                     * @returns {Array} Returns the slice of `array`.
                                     * @example
                                     *
                                     * _.take([1, 2, 3]);
                                     * // => [1]
                                     *
                                     * _.take([1, 2, 3], 2);
                                     * // => [1, 2]
                                     *
                                     * _.take([1, 2, 3], 5);
                                     * // => [1, 2, 3]
                                     *
                                     * _.take([1, 2, 3], 0);
                                     * // => []
                                     */
                                    function take(array, n, guard) {
                                        var length = array ? array.length : 0;
                                        if (!length) {
                                            return [];
                                        }
                                        if (guard ? isIterateeCall(array, n, guard) : n == null) {
                                            n = 1;
                                        }
                                        return baseSlice(array, 0, n < 0 ? 0 : n);
                                    }

                                    /**
                                     * Creates a slice of `array` with `n` elements taken from the end.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Array
                                     * @param {Array} array The array to query.
                                     * @param {number} [n=1] The number of elements to take.
                                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                                     * @returns {Array} Returns the slice of `array`.
                                     * @example
                                     *
                                     * _.takeRight([1, 2, 3]);
                                     * // => [3]
                                     *
                                     * _.takeRight([1, 2, 3], 2);
                                     * // => [2, 3]
                                     *
                                     * _.takeRight([1, 2, 3], 5);
                                     * // => [1, 2, 3]
                                     *
                                     * _.takeRight([1, 2, 3], 0);
                                     * // => []
                                     */
                                    function takeRight(array, n, guard) {
                                        var length = array ? array.length : 0;
                                        if (!length) {
                                            return [];
                                        }
                                        if (guard ? isIterateeCall(array, n, guard) : n == null) {
                                            n = 1;
                                        }
                                        n = length - (+n || 0);
                                        return baseSlice(array, n < 0 ? 0 : n);
                                    }

                                    /**
                                     * Creates a slice of `array` with elements taken from the end. Elements are
                                     * taken until `predicate` returns falsey. The predicate is bound to `thisArg`
                                     * and invoked with three arguments: (value, index, array).
                                     *
                                     * If a property name is provided for `predicate` the created `_.property`
                                     * style callback returns the property value of the given element.
                                     *
                                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                                     * style callback returns `true` for elements that have a matching property
                                     * value, else `false`.
                                     *
                                     * If an object is provided for `predicate` the created `_.matches` style
                                     * callback returns `true` for elements that have the properties of the given
                                     * object, else `false`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Array
                                     * @param {Array} array The array to query.
                                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                                     *  per iteration.
                                     * @param {*} [thisArg] The `this` binding of `predicate`.
                                     * @returns {Array} Returns the slice of `array`.
                                     * @example
                                     *
                                     * _.takeRightWhile([1, 2, 3], function(n) {
     *   return n > 1;
     * });
                                     * // => [2, 3]
                                     *
                                     * var users = [
                                     *   { 'user': 'barney',  'active': true },
                                     *   { 'user': 'fred',    'active': false },
                                     *   { 'user': 'pebbles', 'active': false }
                                     * ];
                                     *
                                     * // using the `_.matches` callback shorthand
                                     * _.pluck(_.takeRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
                                     * // => ['pebbles']
                                     *
                                     * // using the `_.matchesProperty` callback shorthand
                                     * _.pluck(_.takeRightWhile(users, 'active', false), 'user');
                                     * // => ['fred', 'pebbles']
                                     *
                                     * // using the `_.property` callback shorthand
                                     * _.pluck(_.takeRightWhile(users, 'active'), 'user');
                                     * // => []
                                     */
                                    function takeRightWhile(array, predicate, thisArg) {
                                        return (array && array.length)
                                            ? baseWhile(array, getCallback(predicate, thisArg, 3), false, true)
                                            : [];
                                    }

                                    /**
                                     * Creates a slice of `array` with elements taken from the beginning. Elements
                                     * are taken until `predicate` returns falsey. The predicate is bound to
                                     * `thisArg` and invoked with three arguments: (value, index, array).
                                     *
                                     * If a property name is provided for `predicate` the created `_.property`
                                     * style callback returns the property value of the given element.
                                     *
                                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                                     * style callback returns `true` for elements that have a matching property
                                     * value, else `false`.
                                     *
                                     * If an object is provided for `predicate` the created `_.matches` style
                                     * callback returns `true` for elements that have the properties of the given
                                     * object, else `false`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Array
                                     * @param {Array} array The array to query.
                                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                                     *  per iteration.
                                     * @param {*} [thisArg] The `this` binding of `predicate`.
                                     * @returns {Array} Returns the slice of `array`.
                                     * @example
                                     *
                                     * _.takeWhile([1, 2, 3], function(n) {
     *   return n < 3;
     * });
                                     * // => [1, 2]
                                     *
                                     * var users = [
                                     *   { 'user': 'barney',  'active': false },
                                     *   { 'user': 'fred',    'active': false},
                                     *   { 'user': 'pebbles', 'active': true }
                                     * ];
                                     *
                                     * // using the `_.matches` callback shorthand
                                     * _.pluck(_.takeWhile(users, { 'user': 'barney', 'active': false }), 'user');
                                     * // => ['barney']
                                     *
                                     * // using the `_.matchesProperty` callback shorthand
                                     * _.pluck(_.takeWhile(users, 'active', false), 'user');
                                     * // => ['barney', 'fred']
                                     *
                                     * // using the `_.property` callback shorthand
                                     * _.pluck(_.takeWhile(users, 'active'), 'user');
                                     * // => []
                                     */
                                    function takeWhile(array, predicate, thisArg) {
                                        return (array && array.length)
                                            ? baseWhile(array, getCallback(predicate, thisArg, 3))
                                            : [];
                                    }

                                    /**
                                     * Creates an array of unique values, in order, from all of the provided arrays
                                     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
                                     * for equality comparisons.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Array
                                     * @param {...Array} [arrays] The arrays to inspect.
                                     * @returns {Array} Returns the new array of combined values.
                                     * @example
                                     *
                                     * _.union([1, 2], [4, 2], [2, 1]);
                                     * // => [1, 2, 4]
                                     */
                                    var union = restParam(function (arrays) {
                                        return baseUniq(baseFlatten(arrays, false, true));
                                    });

                                    /**
                                     * Creates a duplicate-free version of an array, using
                                     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
                                     * for equality comparisons, in which only the first occurence of each element
                                     * is kept. Providing `true` for `isSorted` performs a faster search algorithm
                                     * for sorted arrays. If an iteratee function is provided it is invoked for
                                     * each element in the array to generate the criterion by which uniqueness
                                     * is computed. The `iteratee` is bound to `thisArg` and invoked with three
                                     * arguments: (value, index, array).
                                     *
                                     * If a property name is provided for `iteratee` the created `_.property`
                                     * style callback returns the property value of the given element.
                                     *
                                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                                     * style callback returns `true` for elements that have a matching property
                                     * value, else `false`.
                                     *
                                     * If an object is provided for `iteratee` the created `_.matches` style
                                     * callback returns `true` for elements that have the properties of the given
                                     * object, else `false`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @alias unique
                                     * @category Array
                                     * @param {Array} array The array to inspect.
                                     * @param {boolean} [isSorted] Specify the array is sorted.
                                     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
                                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                                     * @returns {Array} Returns the new duplicate-value-free array.
                                     * @example
                                     *
                                     * _.uniq([2, 1, 2]);
                                     * // => [2, 1]
                                     *
                                     * // using `isSorted`
                                     * _.uniq([1, 1, 2], true);
                                     * // => [1, 2]
                                     *
                                     * // using an iteratee function
                                     * _.uniq([1, 2.5, 1.5, 2], function(n) {
     *   return this.floor(n);
     * }, Math);
                                     * // => [1, 2.5]
                                     *
                                     * // using the `_.property` callback shorthand
                                     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
                                     * // => [{ 'x': 1 }, { 'x': 2 }]
                                     */
                                    function uniq(array, isSorted, iteratee, thisArg) {
                                        var length = array ? array.length : 0;
                                        if (!length) {
                                            return [];
                                        }
                                        if (isSorted != null && typeof isSorted != 'boolean') {
                                            thisArg = iteratee;
                                            iteratee = isIterateeCall(array, isSorted, thisArg) ? undefined : isSorted;
                                            isSorted = false;
                                        }
                                        var callback = getCallback();
                                        if (!(iteratee == null && callback === baseCallback)) {
                                            iteratee = callback(iteratee, thisArg, 3);
                                        }
                                        return (isSorted && getIndexOf() == baseIndexOf)
                                            ? sortedUniq(array, iteratee)
                                            : baseUniq(array, iteratee);
                                    }

                                    /**
                                     * This method is like `_.zip` except that it accepts an array of grouped
                                     * elements and creates an array regrouping the elements to their pre-zip
                                     * configuration.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Array
                                     * @param {Array} array The array of grouped elements to process.
                                     * @returns {Array} Returns the new array of regrouped elements.
                                     * @example
                                     *
                                     * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);
                                     * // => [['fred', 30, true], ['barney', 40, false]]
                                     *
                                     * _.unzip(zipped);
                                     * // => [['fred', 'barney'], [30, 40], [true, false]]
                                     */
                                    function unzip(array) {
                                        if (!(array && array.length)) {
                                            return [];
                                        }
                                        var index = -1,
                                            length = 0;

                                        array = arrayFilter(array, function (group) {
                                            if (isArrayLike(group)) {
                                                length = nativeMax(group.length, length);
                                                return true;
                                            }
                                        });
                                        var result = Array(length);
                                        while (++index < length) {
                                            result[index] = arrayMap(array, baseProperty(index));
                                        }
                                        return result;
                                    }

                                    /**
                                     * This method is like `_.unzip` except that it accepts an iteratee to specify
                                     * how regrouped values should be combined. The `iteratee` is bound to `thisArg`
                                     * and invoked with four arguments: (accumulator, value, index, group).
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Array
                                     * @param {Array} array The array of grouped elements to process.
                                     * @param {Function} [iteratee] The function to combine regrouped values.
                                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                                     * @returns {Array} Returns the new array of regrouped elements.
                                     * @example
                                     *
                                     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
                                     * // => [[1, 10, 100], [2, 20, 200]]
                                     *
                                     * _.unzipWith(zipped, _.add);
                                     * // => [3, 30, 300]
                                     */
                                    function unzipWith(array, iteratee, thisArg) {
                                        var length = array ? array.length : 0;
                                        if (!length) {
                                            return [];
                                        }
                                        var result = unzip(array);
                                        if (iteratee == null) {
                                            return result;
                                        }
                                        iteratee = bindCallback(iteratee, thisArg, 4);
                                        return arrayMap(result, function (group) {
                                            return arrayReduce(group, iteratee, undefined, true);
                                        });
                                    }

                                    /**
                                     * Creates an array excluding all provided values using
                                     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
                                     * for equality comparisons.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Array
                                     * @param {Array} array The array to filter.
                                     * @param {...*} [values] The values to exclude.
                                     * @returns {Array} Returns the new array of filtered values.
                                     * @example
                                     *
                                     * _.without([1, 2, 1, 3], 1, 2);
                                     * // => [3]
                                     */
                                    var without = restParam(function (array, values) {
                                        return isArrayLike(array)
                                            ? baseDifference(array, values)
                                            : [];
                                    });

                                    /**
                                     * Creates an array of unique values that is the [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
                                     * of the provided arrays.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Array
                                     * @param {...Array} [arrays] The arrays to inspect.
                                     * @returns {Array} Returns the new array of values.
                                     * @example
                                     *
                                     * _.xor([1, 2], [4, 2]);
                                     * // => [1, 4]
                                     */
                                    function xor() {
                                        var index = -1,
                                            length = arguments.length;

                                        while (++index < length) {
                                            var array = arguments[index];
                                            if (isArrayLike(array)) {
                                                var result = result
                                                    ? arrayPush(baseDifference(result, array), baseDifference(array, result))
                                                    : array;
                                            }
                                        }
                                        return result ? baseUniq(result) : [];
                                    }

                                    /**
                                     * Creates an array of grouped elements, the first of which contains the first
                                     * elements of the given arrays, the second of which contains the second elements
                                     * of the given arrays, and so on.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Array
                                     * @param {...Array} [arrays] The arrays to process.
                                     * @returns {Array} Returns the new array of grouped elements.
                                     * @example
                                     *
                                     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
                                     * // => [['fred', 30, true], ['barney', 40, false]]
                                     */
                                    var zip = restParam(unzip);

                                    /**
                                     * The inverse of `_.pairs`; this method returns an object composed from arrays
                                     * of property names and values. Provide either a single two dimensional array,
                                     * e.g. `[[key1, value1], [key2, value2]]` or two arrays, one of property names
                                     * and one of corresponding values.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @alias object
                                     * @category Array
                                     * @param {Array} props The property names.
                                     * @param {Array} [values=[]] The property values.
                                     * @returns {Object} Returns the new object.
                                     * @example
                                     *
                                     * _.zipObject([['fred', 30], ['barney', 40]]);
                                     * // => { 'fred': 30, 'barney': 40 }
                                     *
                                     * _.zipObject(['fred', 'barney'], [30, 40]);
                                     * // => { 'fred': 30, 'barney': 40 }
                                     */
                                    function zipObject(props, values) {
                                        var index = -1,
                                            length = props ? props.length : 0,
                                            result = {};

                                        if (length && !values && !isArray(props[0])) {
                                            values = [];
                                        }
                                        while (++index < length) {
                                            var key = props[index];
                                            if (values) {
                                                result[key] = values[index];
                                            } else if (key) {
                                                result[key[0]] = key[1];
                                            }
                                        }
                                        return result;
                                    }

                                    /**
                                     * This method is like `_.zip` except that it accepts an iteratee to specify
                                     * how grouped values should be combined. The `iteratee` is bound to `thisArg`
                                     * and invoked with four arguments: (accumulator, value, index, group).
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Array
                                     * @param {...Array} [arrays] The arrays to process.
                                     * @param {Function} [iteratee] The function to combine grouped values.
                                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                                     * @returns {Array} Returns the new array of grouped elements.
                                     * @example
                                     *
                                     * _.zipWith([1, 2], [10, 20], [100, 200], _.add);
                                     * // => [111, 222]
                                     */
                                    var zipWith = restParam(function (arrays) {
                                        var length = arrays.length,
                                            iteratee = length > 2 ? arrays[length - 2] : undefined,
                                            thisArg = length > 1 ? arrays[length - 1] : undefined;

                                        if (length > 2 && typeof iteratee == 'function') {
                                            length -= 2;
                                        } else {
                                            iteratee = (length > 1 && typeof thisArg == 'function') ? (--length, thisArg) : undefined;
                                            thisArg = undefined;
                                        }
                                        arrays.length = length;
                                        return unzipWith(arrays, iteratee, thisArg);
                                    });

                                    /*------------------------------------------------------------------------*/

                                    /**
                                     * Creates a `lodash` object that wraps `value` with explicit method
                                     * chaining enabled.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Chain
                                     * @param {*} value The value to wrap.
                                     * @returns {Object} Returns the new `lodash` wrapper instance.
                                     * @example
                                     *
                                     * var users = [
                                     *   { 'user': 'barney',  'age': 36 },
                                     *   { 'user': 'fred',    'age': 40 },
                                     *   { 'user': 'pebbles', 'age': 1 }
                                     * ];
                                     *
                                     * var youngest = _.chain(users)
                                     *   .sortBy('age')
                                     *   .map(function(chr) {
     *     return chr.user + ' is ' + chr.age;
     *   })
                                     *   .first()
                                     *   .value();
                                     * // => 'pebbles is 1'
                                     */
                                    function chain(value) {
                                        var result = lodash(value);
                                        result.__chain__ = true;
                                        return result;
                                    }

                                    /**
                                     * This method invokes `interceptor` and returns `value`. The interceptor is
                                     * bound to `thisArg` and invoked with one argument; (value). The purpose of
                                     * this method is to "tap into" a method chain in order to perform operations
                                     * on intermediate results within the chain.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Chain
                                     * @param {*} value The value to provide to `interceptor`.
                                     * @param {Function} interceptor The function to invoke.
                                     * @param {*} [thisArg] The `this` binding of `interceptor`.
                                     * @returns {*} Returns `value`.
                                     * @example
                                     *
                                     * _([1, 2, 3])
                                     *  .tap(function(array) {
     *    array.pop();
     *  })
                                     *  .reverse()
                                     *  .value();
                                     * // => [2, 1]
                                     */
                                    function tap(value, interceptor, thisArg) {
                                        interceptor.call(thisArg, value);
                                        return value;
                                    }

                                    /**
                                     * This method is like `_.tap` except that it returns the result of `interceptor`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Chain
                                     * @param {*} value The value to provide to `interceptor`.
                                     * @param {Function} interceptor The function to invoke.
                                     * @param {*} [thisArg] The `this` binding of `interceptor`.
                                     * @returns {*} Returns the result of `interceptor`.
                                     * @example
                                     *
                                     * _('  abc  ')
                                     *  .chain()
                                     *  .trim()
                                     *  .thru(function(value) {
     *    return [value];
     *  })
                                     *  .value();
                                     * // => ['abc']
                                     */
                                    function thru(value, interceptor, thisArg) {
                                        return interceptor.call(thisArg, value);
                                    }

                                    /**
                                     * Enables explicit method chaining on the wrapper object.
                                     *
                                     * @name chain
                                     * @memberOf _
                                     * @category Chain
                                     * @returns {Object} Returns the new `lodash` wrapper instance.
                                     * @example
                                     *
                                     * var users = [
                                     *   { 'user': 'barney', 'age': 36 },
                                     *   { 'user': 'fred',   'age': 40 }
                                     * ];
                                     *
                                     * // without explicit chaining
                                     * _(users).first();
                                     * // => { 'user': 'barney', 'age': 36 }
                                     *
                                     * // with explicit chaining
                                     * _(users).chain()
                                     *   .first()
                                     *   .pick('user')
                                     *   .value();
                                     * // => { 'user': 'barney' }
                                     */
                                    function wrapperChain() {
                                        return chain(this);
                                    }

                                    /**
                                     * Executes the chained sequence and returns the wrapped result.
                                     *
                                     * @name commit
                                     * @memberOf _
                                     * @category Chain
                                     * @returns {Object} Returns the new `lodash` wrapper instance.
                                     * @example
                                     *
                                     * var array = [1, 2];
                                     * var wrapped = _(array).push(3);
                                     *
                                     * console.log(array);
                                     * // => [1, 2]
                                     *
                                     * wrapped = wrapped.commit();
                                     * console.log(array);
                                     * // => [1, 2, 3]
                                     *
                                     * wrapped.last();
                                     * // => 3
                                     *
                                     * console.log(array);
                                     * // => [1, 2, 3]
                                     */
                                    function wrapperCommit() {
                                        return new LodashWrapper(this.value(), this.__chain__);
                                    }

                                    /**
                                     * Creates a new array joining a wrapped array with any additional arrays
                                     * and/or values.
                                     *
                                     * @name concat
                                     * @memberOf _
                                     * @category Chain
                                     * @param {...*} [values] The values to concatenate.
                                     * @returns {Array} Returns the new concatenated array.
                                     * @example
                                     *
                                     * var array = [1];
                                     * var wrapped = _(array).concat(2, [3], [[4]]);
                                     *
                                     * console.log(wrapped.value());
                                     * // => [1, 2, 3, [4]]
                                     *
                                     * console.log(array);
                                     * // => [1]
                                     */
                                    var wrapperConcat = restParam(function (values) {
                                        values = baseFlatten(values);
                                        return this.thru(function (array) {
                                            return arrayConcat(isArray(array) ? array : [toObject(array)], values);
                                        });
                                    });

                                    /**
                                     * Creates a clone of the chained sequence planting `value` as the wrapped value.
                                     *
                                     * @name plant
                                     * @memberOf _
                                     * @category Chain
                                     * @returns {Object} Returns the new `lodash` wrapper instance.
                                     * @example
                                     *
                                     * var array = [1, 2];
                                     * var wrapped = _(array).map(function(value) {
     *   return Math.pow(value, 2);
     * });
                                     *
                                     * var other = [3, 4];
                                     * var otherWrapped = wrapped.plant(other);
                                     *
                                     * otherWrapped.value();
                                     * // => [9, 16]
                                     *
                                     * wrapped.value();
                                     * // => [1, 4]
                                     */
                                    function wrapperPlant(value) {
                                        var result,
                                            parent = this;

                                        while (parent instanceof baseLodash) {
                                            var clone = wrapperClone(parent);
                                            if (result) {
                                                previous.__wrapped__ = clone;
                                            } else {
                                                result = clone;
                                            }
                                            var previous = clone;
                                            parent = parent.__wrapped__;
                                        }
                                        previous.__wrapped__ = value;
                                        return result;
                                    }

                                    /**
                                     * Reverses the wrapped array so the first element becomes the last, the
                                     * second element becomes the second to last, and so on.
                                     *
                                     * **Note:** This method mutates the wrapped array.
                                     *
                                     * @name reverse
                                     * @memberOf _
                                     * @category Chain
                                     * @returns {Object} Returns the new reversed `lodash` wrapper instance.
                                     * @example
                                     *
                                     * var array = [1, 2, 3];
                                     *
                                     * _(array).reverse().value()
                                     * // => [3, 2, 1]
                                     *
                                     * console.log(array);
                                     * // => [3, 2, 1]
                                     */
                                    function wrapperReverse() {
                                        var value = this.__wrapped__;

                                        var interceptor = function (value) {
                                            return (wrapped && wrapped.__dir__ < 0) ? value : value.reverse();
                                        };
                                        if (value instanceof LazyWrapper) {
                                            var wrapped = value;
                                            if (this.__actions__.length) {
                                                wrapped = new LazyWrapper(this);
                                            }
                                            wrapped = wrapped.reverse();
                                            wrapped.__actions__.push({
                                                'func': thru,
                                                'args': [interceptor],
                                                'thisArg': undefined
                                            });
                                            return new LodashWrapper(wrapped, this.__chain__);
                                        }
                                        return this.thru(interceptor);
                                    }

                                    /**
                                     * Produces the result of coercing the unwrapped value to a string.
                                     *
                                     * @name toString
                                     * @memberOf _
                                     * @category Chain
                                     * @returns {string} Returns the coerced string value.
                                     * @example
                                     *
                                     * _([1, 2, 3]).toString();
                                     * // => '1,2,3'
                                     */
                                    function wrapperToString() {
                                        return (this.value() + '');
                                    }

                                    /**
                                     * Executes the chained sequence to extract the unwrapped value.
                                     *
                                     * @name value
                                     * @memberOf _
                                     * @alias run, toJSON, valueOf
                                     * @category Chain
                                     * @returns {*} Returns the resolved unwrapped value.
                                     * @example
                                     *
                                     * _([1, 2, 3]).value();
                                     * // => [1, 2, 3]
                                     */
                                    function wrapperValue() {
                                        return baseWrapperValue(this.__wrapped__, this.__actions__);
                                    }

                                    /*------------------------------------------------------------------------*/

                                    /**
                                     * Creates an array of elements corresponding to the given keys, or indexes,
                                     * of `collection`. Keys may be specified as individual arguments or as arrays
                                     * of keys.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Collection
                                     * @param {Array|Object|string} collection The collection to iterate over.
                                     * @param {...(number|number[]|string|string[])} [props] The property names
                                     *  or indexes of elements to pick, specified individually or in arrays.
                                     * @returns {Array} Returns the new array of picked elements.
                                     * @example
                                     *
                                     * _.at(['a', 'b', 'c'], [0, 2]);
                                     * // => ['a', 'c']
                                     *
                                     * _.at(['barney', 'fred', 'pebbles'], 0, 2);
                                     * // => ['barney', 'pebbles']
                                     */
                                    var at = restParam(function (collection, props) {
                                        return baseAt(collection, baseFlatten(props));
                                    });

                                    /**
                                     * Creates an object composed of keys generated from the results of running
                                     * each element of `collection` through `iteratee`. The corresponding value
                                     * of each key is the number of times the key was returned by `iteratee`.
                                     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
                                     * (value, index|key, collection).
                                     *
                                     * If a property name is provided for `iteratee` the created `_.property`
                                     * style callback returns the property value of the given element.
                                     *
                                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                                     * style callback returns `true` for elements that have a matching property
                                     * value, else `false`.
                                     *
                                     * If an object is provided for `iteratee` the created `_.matches` style
                                     * callback returns `true` for elements that have the properties of the given
                                     * object, else `false`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Collection
                                     * @param {Array|Object|string} collection The collection to iterate over.
                                     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
                                     *  per iteration.
                                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                                     * @returns {Object} Returns the composed aggregate object.
                                     * @example
                                     *
                                     * _.countBy([4.3, 6.1, 6.4], function(n) {
     *   return Math.floor(n);
     * });
                                     * // => { '4': 1, '6': 2 }
                                     *
                                     * _.countBy([4.3, 6.1, 6.4], function(n) {
     *   return this.floor(n);
     * }, Math);
                                     * // => { '4': 1, '6': 2 }
                                     *
                                     * _.countBy(['one', 'two', 'three'], 'length');
                                     * // => { '3': 2, '5': 1 }
                                     */
                                    var countBy = createAggregator(function (result, value, key) {
                                        hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
                                    });

                                    /**
                                     * Checks if `predicate` returns truthy for **all** elements of `collection`.
                                     * The predicate is bound to `thisArg` and invoked with three arguments:
                                     * (value, index|key, collection).
                                     *
                                     * If a property name is provided for `predicate` the created `_.property`
                                     * style callback returns the property value of the given element.
                                     *
                                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                                     * style callback returns `true` for elements that have a matching property
                                     * value, else `false`.
                                     *
                                     * If an object is provided for `predicate` the created `_.matches` style
                                     * callback returns `true` for elements that have the properties of the given
                                     * object, else `false`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @alias all
                                     * @category Collection
                                     * @param {Array|Object|string} collection The collection to iterate over.
                                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                                     *  per iteration.
                                     * @param {*} [thisArg] The `this` binding of `predicate`.
                                     * @returns {boolean} Returns `true` if all elements pass the predicate check,
                                     *  else `false`.
                                     * @example
                                     *
                                     * _.every([true, 1, null, 'yes'], Boolean);
                                     * // => false
                                     *
                                     * var users = [
                                     *   { 'user': 'barney', 'active': false },
                                     *   { 'user': 'fred',   'active': false }
                                     * ];
                                     *
                                     * // using the `_.matches` callback shorthand
                                     * _.every(users, { 'user': 'barney', 'active': false });
                                     * // => false
                                     *
                                     * // using the `_.matchesProperty` callback shorthand
                                     * _.every(users, 'active', false);
                                     * // => true
                                     *
                                     * // using the `_.property` callback shorthand
                                     * _.every(users, 'active');
                                     * // => false
                                     */
                                    function every(collection, predicate, thisArg) {
                                        var func = isArray(collection) ? arrayEvery : baseEvery;
                                        if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
                                            predicate = undefined;
                                        }
                                        if (typeof predicate != 'function' || thisArg !== undefined) {
                                            predicate = getCallback(predicate, thisArg, 3);
                                        }
                                        return func(collection, predicate);
                                    }

                                    /**
                                     * Iterates over elements of `collection`, returning an array of all elements
                                     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
                                     * invoked with three arguments: (value, index|key, collection).
                                     *
                                     * If a property name is provided for `predicate` the created `_.property`
                                     * style callback returns the property value of the given element.
                                     *
                                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                                     * style callback returns `true` for elements that have a matching property
                                     * value, else `false`.
                                     *
                                     * If an object is provided for `predicate` the created `_.matches` style
                                     * callback returns `true` for elements that have the properties of the given
                                     * object, else `false`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @alias select
                                     * @category Collection
                                     * @param {Array|Object|string} collection The collection to iterate over.
                                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                                     *  per iteration.
                                     * @param {*} [thisArg] The `this` binding of `predicate`.
                                     * @returns {Array} Returns the new filtered array.
                                     * @example
                                     *
                                     * _.filter([4, 5, 6], function(n) {
     *   return n % 2 == 0;
     * });
                                     * // => [4, 6]
                                     *
                                     * var users = [
                                     *   { 'user': 'barney', 'age': 36, 'active': true },
                                     *   { 'user': 'fred',   'age': 40, 'active': false }
                                     * ];
                                     *
                                     * // using the `_.matches` callback shorthand
                                     * _.pluck(_.filter(users, { 'age': 36, 'active': true }), 'user');
                                     * // => ['barney']
                                     *
                                     * // using the `_.matchesProperty` callback shorthand
                                     * _.pluck(_.filter(users, 'active', false), 'user');
                                     * // => ['fred']
                                     *
                                     * // using the `_.property` callback shorthand
                                     * _.pluck(_.filter(users, 'active'), 'user');
                                     * // => ['barney']
                                     */
                                    function filter(collection, predicate, thisArg) {
                                        var func = isArray(collection) ? arrayFilter : baseFilter;
                                        predicate = getCallback(predicate, thisArg, 3);
                                        return func(collection, predicate);
                                    }

                                    /**
                                     * Iterates over elements of `collection`, returning the first element
                                     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
                                     * invoked with three arguments: (value, index|key, collection).
                                     *
                                     * If a property name is provided for `predicate` the created `_.property`
                                     * style callback returns the property value of the given element.
                                     *
                                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                                     * style callback returns `true` for elements that have a matching property
                                     * value, else `false`.
                                     *
                                     * If an object is provided for `predicate` the created `_.matches` style
                                     * callback returns `true` for elements that have the properties of the given
                                     * object, else `false`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @alias detect
                                     * @category Collection
                                     * @param {Array|Object|string} collection The collection to search.
                                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                                     *  per iteration.
                                     * @param {*} [thisArg] The `this` binding of `predicate`.
                                     * @returns {*} Returns the matched element, else `undefined`.
                                     * @example
                                     *
                                     * var users = [
                                     *   { 'user': 'barney',  'age': 36, 'active': true },
                                     *   { 'user': 'fred',    'age': 40, 'active': false },
                                     *   { 'user': 'pebbles', 'age': 1,  'active': true }
                                     * ];
                                     *
                                     * _.result(_.find(users, function(chr) {
     *   return chr.age < 40;
     * }), 'user');
                                     * // => 'barney'
                                     *
                                     * // using the `_.matches` callback shorthand
                                     * _.result(_.find(users, { 'age': 1, 'active': true }), 'user');
                                     * // => 'pebbles'
                                     *
                                     * // using the `_.matchesProperty` callback shorthand
                                     * _.result(_.find(users, 'active', false), 'user');
                                     * // => 'fred'
                                     *
                                     * // using the `_.property` callback shorthand
                                     * _.result(_.find(users, 'active'), 'user');
                                     * // => 'barney'
                                     */
                                    var find = createFind(baseEach);

                                    /**
                                     * This method is like `_.find` except that it iterates over elements of
                                     * `collection` from right to left.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Collection
                                     * @param {Array|Object|string} collection The collection to search.
                                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                                     *  per iteration.
                                     * @param {*} [thisArg] The `this` binding of `predicate`.
                                     * @returns {*} Returns the matched element, else `undefined`.
                                     * @example
                                     *
                                     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
                                     * // => 3
                                     */
                                    var findLast = createFind(baseEachRight, true);

                                    /**
                                     * Performs a deep comparison between each element in `collection` and the
                                     * source object, returning the first element that has equivalent property
                                     * values.
                                     *
                                     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
                                     * numbers, `Object` objects, regexes, and strings. Objects are compared by
                                     * their own, not inherited, enumerable properties. For comparing a single
                                     * own or inherited property value see `_.matchesProperty`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Collection
                                     * @param {Array|Object|string} collection The collection to search.
                                     * @param {Object} source The object of property values to match.
                                     * @returns {*} Returns the matched element, else `undefined`.
                                     * @example
                                     *
                                     * var users = [
                                     *   { 'user': 'barney', 'age': 36, 'active': true },
                                     *   { 'user': 'fred',   'age': 40, 'active': false }
                                     * ];
                                     *
                                     * _.result(_.findWhere(users, { 'age': 36, 'active': true }), 'user');
                                     * // => 'barney'
                                     *
                                     * _.result(_.findWhere(users, { 'age': 40, 'active': false }), 'user');
                                     * // => 'fred'
                                     */
                                    function findWhere(collection, source) {
                                        return find(collection, baseMatches(source));
                                    }

                                    /**
                                     * Iterates over elements of `collection` invoking `iteratee` for each element.
                                     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
                                     * (value, index|key, collection). Iteratee functions may exit iteration early
                                     * by explicitly returning `false`.
                                     *
                                     * **Note:** As with other "Collections" methods, objects with a "length" property
                                     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
                                     * may be used for object iteration.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @alias each
                                     * @category Collection
                                     * @param {Array|Object|string} collection The collection to iterate over.
                                     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                                     * @returns {Array|Object|string} Returns `collection`.
                                     * @example
                                     *
                                     * _([1, 2]).forEach(function(n) {
     *   console.log(n);
     * }).value();
                                     * // => logs each value from left to right and returns the array
                                     *
                                     * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {
     *   console.log(n, key);
     * });
                                     * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
                                     */
                                    var forEach = createForEach(arrayEach, baseEach);

                                    /**
                                     * This method is like `_.forEach` except that it iterates over elements of
                                     * `collection` from right to left.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @alias eachRight
                                     * @category Collection
                                     * @param {Array|Object|string} collection The collection to iterate over.
                                     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                                     * @returns {Array|Object|string} Returns `collection`.
                                     * @example
                                     *
                                     * _([1, 2]).forEachRight(function(n) {
     *   console.log(n);
     * }).value();
                                     * // => logs each value from right to left and returns the array
                                     */
                                    var forEachRight = createForEach(arrayEachRight, baseEachRight);

                                    /**
                                     * Creates an object composed of keys generated from the results of running
                                     * each element of `collection` through `iteratee`. The corresponding value
                                     * of each key is an array of the elements responsible for generating the key.
                                     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
                                     * (value, index|key, collection).
                                     *
                                     * If a property name is provided for `iteratee` the created `_.property`
                                     * style callback returns the property value of the given element.
                                     *
                                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                                     * style callback returns `true` for elements that have a matching property
                                     * value, else `false`.
                                     *
                                     * If an object is provided for `iteratee` the created `_.matches` style
                                     * callback returns `true` for elements that have the properties of the given
                                     * object, else `false`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Collection
                                     * @param {Array|Object|string} collection The collection to iterate over.
                                     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
                                     *  per iteration.
                                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                                     * @returns {Object} Returns the composed aggregate object.
                                     * @example
                                     *
                                     * _.groupBy([4.2, 6.1, 6.4], function(n) {
     *   return Math.floor(n);
     * });
                                     * // => { '4': [4.2], '6': [6.1, 6.4] }
                                     *
                                     * _.groupBy([4.2, 6.1, 6.4], function(n) {
     *   return this.floor(n);
     * }, Math);
                                     * // => { '4': [4.2], '6': [6.1, 6.4] }
                                     *
                                     * // using the `_.property` callback shorthand
                                     * _.groupBy(['one', 'two', 'three'], 'length');
                                     * // => { '3': ['one', 'two'], '5': ['three'] }
                                     */
                                    var groupBy = createAggregator(function (result, value, key) {
                                        if (hasOwnProperty.call(result, key)) {
                                            result[key].push(value);
                                        } else {
                                            result[key] = [value];
                                        }
                                    });

                                    /**
                                     * Checks if `value` is in `collection` using
                                     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
                                     * for equality comparisons. If `fromIndex` is negative, it is used as the offset
                                     * from the end of `collection`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @alias contains, include
                                     * @category Collection
                                     * @param {Array|Object|string} collection The collection to search.
                                     * @param {*} target The value to search for.
                                     * @param {number} [fromIndex=0] The index to search from.
                                     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
                                     * @returns {boolean} Returns `true` if a matching element is found, else `false`.
                                     * @example
                                     *
                                     * _.includes([1, 2, 3], 1);
                                     * // => true
                                     *
                                     * _.includes([1, 2, 3], 1, 2);
                                     * // => false
                                     *
                                     * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
                                     * // => true
                                     *
                                     * _.includes('pebbles', 'eb');
                                     * // => true
                                     */
                                    function includes(collection, target, fromIndex, guard) {
                                        var length = collection ? getLength(collection) : 0;
                                        if (!isLength(length)) {
                                            collection = values(collection);
                                            length = collection.length;
                                        }
                                        if (typeof fromIndex != 'number' || (guard && isIterateeCall(target, fromIndex, guard))) {
                                            fromIndex = 0;
                                        } else {
                                            fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
                                        }
                                        return (typeof collection == 'string' || !isArray(collection) && isString(collection))
                                            ? (fromIndex <= length && collection.indexOf(target, fromIndex) > -1)
                                            : (!!length && getIndexOf(collection, target, fromIndex) > -1);
                                    }

                                    /**
                                     * Creates an object composed of keys generated from the results of running
                                     * each element of `collection` through `iteratee`. The corresponding value
                                     * of each key is the last element responsible for generating the key. The
                                     * iteratee function is bound to `thisArg` and invoked with three arguments:
                                     * (value, index|key, collection).
                                     *
                                     * If a property name is provided for `iteratee` the created `_.property`
                                     * style callback returns the property value of the given element.
                                     *
                                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                                     * style callback returns `true` for elements that have a matching property
                                     * value, else `false`.
                                     *
                                     * If an object is provided for `iteratee` the created `_.matches` style
                                     * callback returns `true` for elements that have the properties of the given
                                     * object, else `false`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Collection
                                     * @param {Array|Object|string} collection The collection to iterate over.
                                     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
                                     *  per iteration.
                                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                                     * @returns {Object} Returns the composed aggregate object.
                                     * @example
                                     *
                                     * var keyData = [
                                     *   { 'dir': 'left', 'code': 97 },
                                     *   { 'dir': 'right', 'code': 100 }
                                     * ];
                                     *
                                     * _.indexBy(keyData, 'dir');
                                     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
                                     *
                                     * _.indexBy(keyData, function(object) {
     *   return String.fromCharCode(object.code);
     * });
                                     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
                                     *
                                     * _.indexBy(keyData, function(object) {
     *   return this.fromCharCode(object.code);
     * }, String);
                                     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
                                     */
                                    var indexBy = createAggregator(function (result, value, key) {
                                        result[key] = value;
                                    });

                                    /**
                                     * Invokes the method at `path` of each element in `collection`, returning
                                     * an array of the results of each invoked method. Any additional arguments
                                     * are provided to each invoked method. If `methodName` is a function it is
                                     * invoked for, and `this` bound to, each element in `collection`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Collection
                                     * @param {Array|Object|string} collection The collection to iterate over.
                                     * @param {Array|Function|string} path The path of the method to invoke or
                                     *  the function invoked per iteration.
                                     * @param {...*} [args] The arguments to invoke the method with.
                                     * @returns {Array} Returns the array of results.
                                     * @example
                                     *
                                     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
                                     * // => [[1, 5, 7], [1, 2, 3]]
                                     *
                                     * _.invoke([123, 456], String.prototype.split, '');
                                     * // => [['1', '2', '3'], ['4', '5', '6']]
                                     */
                                    var invoke = restParam(function (collection, path, args) {
                                        var index = -1,
                                            isFunc = typeof path == 'function',
                                            isProp = isKey(path),
                                            result = isArrayLike(collection) ? Array(collection.length) : [];

                                        baseEach(collection, function (value) {
                                            var func = isFunc ? path : ((isProp && value != null) ? value[path] : undefined);
                                            result[++index] = func ? func.apply(value, args) : invokePath(value, path, args);
                                        });
                                        return result;
                                    });

                                    /**
                                     * Creates an array of values by running each element in `collection` through
                                     * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three
                                     * arguments: (value, index|key, collection).
                                     *
                                     * If a property name is provided for `iteratee` the created `_.property`
                                     * style callback returns the property value of the given element.
                                     *
                                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                                     * style callback returns `true` for elements that have a matching property
                                     * value, else `false`.
                                     *
                                     * If an object is provided for `iteratee` the created `_.matches` style
                                     * callback returns `true` for elements that have the properties of the given
                                     * object, else `false`.
                                     *
                                     * Many lodash methods are guarded to work as iteratees for methods like
                                     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
                                     *
                                     * The guarded methods are:
                                     * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`,
                                     * `drop`, `dropRight`, `every`, `fill`, `flatten`, `invert`, `max`, `min`,
                                     * `parseInt`, `slice`, `sortBy`, `take`, `takeRight`, `template`, `trim`,
                                     * `trimLeft`, `trimRight`, `trunc`, `random`, `range`, `sample`, `some`,
                                     * `sum`, `uniq`, and `words`
                                     *
                                     * @static
                                     * @memberOf _
                                     * @alias collect
                                     * @category Collection
                                     * @param {Array|Object|string} collection The collection to iterate over.
                                     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
                                     *  per iteration.
                                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                                     * @returns {Array} Returns the new mapped array.
                                     * @example
                                     *
                                     * function timesThree(n) {
     *   return n * 3;
     * }
                                     *
                                     * _.map([1, 2], timesThree);
                                     * // => [3, 6]
                                     *
                                     * _.map({ 'a': 1, 'b': 2 }, timesThree);
                                     * // => [3, 6] (iteration order is not guaranteed)
                                     *
                                     * var users = [
                                     *   { 'user': 'barney' },
                                     *   { 'user': 'fred' }
                                     * ];
                                     *
                                     * // using the `_.property` callback shorthand
                                     * _.map(users, 'user');
                                     * // => ['barney', 'fred']
                                     */
                                    function map(collection, iteratee, thisArg) {
                                        var func = isArray(collection) ? arrayMap : baseMap;
                                        iteratee = getCallback(iteratee, thisArg, 3);
                                        return func(collection, iteratee);
                                    }

                                    /**
                                     * Creates an array of elements split into two groups, the first of which
                                     * contains elements `predicate` returns truthy for, while the second of which
                                     * contains elements `predicate` returns falsey for. The predicate is bound
                                     * to `thisArg` and invoked with three arguments: (value, index|key, collection).
                                     *
                                     * If a property name is provided for `predicate` the created `_.property`
                                     * style callback returns the property value of the given element.
                                     *
                                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                                     * style callback returns `true` for elements that have a matching property
                                     * value, else `false`.
                                     *
                                     * If an object is provided for `predicate` the created `_.matches` style
                                     * callback returns `true` for elements that have the properties of the given
                                     * object, else `false`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Collection
                                     * @param {Array|Object|string} collection The collection to iterate over.
                                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                                     *  per iteration.
                                     * @param {*} [thisArg] The `this` binding of `predicate`.
                                     * @returns {Array} Returns the array of grouped elements.
                                     * @example
                                     *
                                     * _.partition([1, 2, 3], function(n) {
     *   return n % 2;
     * });
                                     * // => [[1, 3], [2]]
                                     *
                                     * _.partition([1.2, 2.3, 3.4], function(n) {
     *   return this.floor(n) % 2;
     * }, Math);
                                     * // => [[1.2, 3.4], [2.3]]
                                     *
                                     * var users = [
                                     *   { 'user': 'barney',  'age': 36, 'active': false },
                                     *   { 'user': 'fred',    'age': 40, 'active': true },
                                     *   { 'user': 'pebbles', 'age': 1,  'active': false }
                                     * ];
                                     *
                                     * var mapper = function(array) {
     *   return _.pluck(array, 'user');
     * };
                                     *
                                     * // using the `_.matches` callback shorthand
                                     * _.map(_.partition(users, { 'age': 1, 'active': false }), mapper);
                                     * // => [['pebbles'], ['barney', 'fred']]
                                     *
                                     * // using the `_.matchesProperty` callback shorthand
                                     * _.map(_.partition(users, 'active', false), mapper);
                                     * // => [['barney', 'pebbles'], ['fred']]
                                     *
                                     * // using the `_.property` callback shorthand
                                     * _.map(_.partition(users, 'active'), mapper);
                                     * // => [['fred'], ['barney', 'pebbles']]
                                     */
                                    var partition = createAggregator(function (result, value, key) {
                                        result[key ? 0 : 1].push(value);
                                    }, function () {
                                        return [[], []];
                                    });

                                    /**
                                     * Gets the property value of `path` from all elements in `collection`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Collection
                                     * @param {Array|Object|string} collection The collection to iterate over.
                                     * @param {Array|string} path The path of the property to pluck.
                                     * @returns {Array} Returns the property values.
                                     * @example
                                     *
                                     * var users = [
                                     *   { 'user': 'barney', 'age': 36 },
                                     *   { 'user': 'fred',   'age': 40 }
                                     * ];
                                     *
                                     * _.pluck(users, 'user');
                                     * // => ['barney', 'fred']
                                     *
                                     * var userIndex = _.indexBy(users, 'user');
                                     * _.pluck(userIndex, 'age');
                                     * // => [36, 40] (iteration order is not guaranteed)
                                     */
                                    function pluck(collection, path) {
                                        return map(collection, property(path));
                                    }

                                    /**
                                     * Reduces `collection` to a value which is the accumulated result of running
                                     * each element in `collection` through `iteratee`, where each successive
                                     * invocation is supplied the return value of the previous. If `accumulator`
                                     * is not provided the first element of `collection` is used as the initial
                                     * value. The `iteratee` is bound to `thisArg` and invoked with four arguments:
                                     * (accumulator, value, index|key, collection).
                                     *
                                     * Many lodash methods are guarded to work as iteratees for methods like
                                     * `_.reduce`, `_.reduceRight`, and `_.transform`.
                                     *
                                     * The guarded methods are:
                                     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `sortByAll`,
                                     * and `sortByOrder`
                                     *
                                     * @static
                                     * @memberOf _
                                     * @alias foldl, inject
                                     * @category Collection
                                     * @param {Array|Object|string} collection The collection to iterate over.
                                     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                                     * @param {*} [accumulator] The initial value.
                                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                                     * @returns {*} Returns the accumulated value.
                                     * @example
                                     *
                                     * _.reduce([1, 2], function(total, n) {
     *   return total + n;
     * });
                                     * // => 3
                                     *
                                     * _.reduce({ 'a': 1, 'b': 2 }, function(result, n, key) {
     *   result[key] = n * 3;
     *   return result;
     * }, {});
                                     * // => { 'a': 3, 'b': 6 } (iteration order is not guaranteed)
                                     */
                                    var reduce = createReduce(arrayReduce, baseEach);

                                    /**
                                     * This method is like `_.reduce` except that it iterates over elements of
                                     * `collection` from right to left.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @alias foldr
                                     * @category Collection
                                     * @param {Array|Object|string} collection The collection to iterate over.
                                     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                                     * @param {*} [accumulator] The initial value.
                                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                                     * @returns {*} Returns the accumulated value.
                                     * @example
                                     *
                                     * var array = [[0, 1], [2, 3], [4, 5]];
                                     *
                                     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
                                     * // => [4, 5, 2, 3, 0, 1]
                                     */
                                    var reduceRight = createReduce(arrayReduceRight, baseEachRight);

                                    /**
                                     * The opposite of `_.filter`; this method returns the elements of `collection`
                                     * that `predicate` does **not** return truthy for.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Collection
                                     * @param {Array|Object|string} collection The collection to iterate over.
                                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                                     *  per iteration.
                                     * @param {*} [thisArg] The `this` binding of `predicate`.
                                     * @returns {Array} Returns the new filtered array.
                                     * @example
                                     *
                                     * _.reject([1, 2, 3, 4], function(n) {
     *   return n % 2 == 0;
     * });
                                     * // => [1, 3]
                                     *
                                     * var users = [
                                     *   { 'user': 'barney', 'age': 36, 'active': false },
                                     *   { 'user': 'fred',   'age': 40, 'active': true }
                                     * ];
                                     *
                                     * // using the `_.matches` callback shorthand
                                     * _.pluck(_.reject(users, { 'age': 40, 'active': true }), 'user');
                                     * // => ['barney']
                                     *
                                     * // using the `_.matchesProperty` callback shorthand
                                     * _.pluck(_.reject(users, 'active', false), 'user');
                                     * // => ['fred']
                                     *
                                     * // using the `_.property` callback shorthand
                                     * _.pluck(_.reject(users, 'active'), 'user');
                                     * // => ['barney']
                                     */
                                    function reject(collection, predicate, thisArg) {
                                        var func = isArray(collection) ? arrayFilter : baseFilter;
                                        predicate = getCallback(predicate, thisArg, 3);
                                        return func(collection, function (value, index, collection) {
                                            return !predicate(value, index, collection);
                                        });
                                    }

                                    /**
                                     * Gets a random element or `n` random elements from a collection.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Collection
                                     * @param {Array|Object|string} collection The collection to sample.
                                     * @param {number} [n] The number of elements to sample.
                                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                                     * @returns {*} Returns the random sample(s).
                                     * @example
                                     *
                                     * _.sample([1, 2, 3, 4]);
                                     * // => 2
                                     *
                                     * _.sample([1, 2, 3, 4], 2);
                                     * // => [3, 1]
                                     */
                                    function sample(collection, n, guard) {
                                        if (guard ? isIterateeCall(collection, n, guard) : n == null) {
                                            collection = toIterable(collection);
                                            var length = collection.length;
                                            return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
                                        }
                                        var index = -1,
                                            result = toArray(collection),
                                            length = result.length,
                                            lastIndex = length - 1;

                                        n = nativeMin(n < 0 ? 0 : (+n || 0), length);
                                        while (++index < n) {
                                            var rand = baseRandom(index, lastIndex),
                                                value = result[rand];

                                            result[rand] = result[index];
                                            result[index] = value;
                                        }
                                        result.length = n;
                                        return result;
                                    }

                                    /**
                                     * Creates an array of shuffled values, using a version of the
                                     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Collection
                                     * @param {Array|Object|string} collection The collection to shuffle.
                                     * @returns {Array} Returns the new shuffled array.
                                     * @example
                                     *
                                     * _.shuffle([1, 2, 3, 4]);
                                     * // => [4, 1, 3, 2]
                                     */
                                    function shuffle(collection) {
                                        return sample(collection, POSITIVE_INFINITY);
                                    }

                                    /**
                                     * Gets the size of `collection` by returning its length for array-like
                                     * values or the number of own enumerable properties for objects.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Collection
                                     * @param {Array|Object|string} collection The collection to inspect.
                                     * @returns {number} Returns the size of `collection`.
                                     * @example
                                     *
                                     * _.size([1, 2, 3]);
                                     * // => 3
                                     *
                                     * _.size({ 'a': 1, 'b': 2 });
                                     * // => 2
                                     *
                                     * _.size('pebbles');
                                     * // => 7
                                     */
                                    function size(collection) {
                                        var length = collection ? getLength(collection) : 0;
                                        return isLength(length) ? length : keys(collection).length;
                                    }

                                    /**
                                     * Checks if `predicate` returns truthy for **any** element of `collection`.
                                     * The function returns as soon as it finds a passing value and does not iterate
                                     * over the entire collection. The predicate is bound to `thisArg` and invoked
                                     * with three arguments: (value, index|key, collection).
                                     *
                                     * If a property name is provided for `predicate` the created `_.property`
                                     * style callback returns the property value of the given element.
                                     *
                                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                                     * style callback returns `true` for elements that have a matching property
                                     * value, else `false`.
                                     *
                                     * If an object is provided for `predicate` the created `_.matches` style
                                     * callback returns `true` for elements that have the properties of the given
                                     * object, else `false`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @alias any
                                     * @category Collection
                                     * @param {Array|Object|string} collection The collection to iterate over.
                                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                                     *  per iteration.
                                     * @param {*} [thisArg] The `this` binding of `predicate`.
                                     * @returns {boolean} Returns `true` if any element passes the predicate check,
                                     *  else `false`.
                                     * @example
                                     *
                                     * _.some([null, 0, 'yes', false], Boolean);
                                     * // => true
                                     *
                                     * var users = [
                                     *   { 'user': 'barney', 'active': true },
                                     *   { 'user': 'fred',   'active': false }
                                     * ];
                                     *
                                     * // using the `_.matches` callback shorthand
                                     * _.some(users, { 'user': 'barney', 'active': false });
                                     * // => false
                                     *
                                     * // using the `_.matchesProperty` callback shorthand
                                     * _.some(users, 'active', false);
                                     * // => true
                                     *
                                     * // using the `_.property` callback shorthand
                                     * _.some(users, 'active');
                                     * // => true
                                     */
                                    function some(collection, predicate, thisArg) {
                                        var func = isArray(collection) ? arraySome : baseSome;
                                        if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
                                            predicate = undefined;
                                        }
                                        if (typeof predicate != 'function' || thisArg !== undefined) {
                                            predicate = getCallback(predicate, thisArg, 3);
                                        }
                                        return func(collection, predicate);
                                    }

                                    /**
                                     * Creates an array of elements, sorted in ascending order by the results of
                                     * running each element in a collection through `iteratee`. This method performs
                                     * a stable sort, that is, it preserves the original sort order of equal elements.
                                     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
                                     * (value, index|key, collection).
                                     *
                                     * If a property name is provided for `iteratee` the created `_.property`
                                     * style callback returns the property value of the given element.
                                     *
                                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                                     * style callback returns `true` for elements that have a matching property
                                     * value, else `false`.
                                     *
                                     * If an object is provided for `iteratee` the created `_.matches` style
                                     * callback returns `true` for elements that have the properties of the given
                                     * object, else `false`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Collection
                                     * @param {Array|Object|string} collection The collection to iterate over.
                                     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
                                     *  per iteration.
                                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                                     * @returns {Array} Returns the new sorted array.
                                     * @example
                                     *
                                     * _.sortBy([1, 2, 3], function(n) {
     *   return Math.sin(n);
     * });
                                     * // => [3, 1, 2]
                                     *
                                     * _.sortBy([1, 2, 3], function(n) {
     *   return this.sin(n);
     * }, Math);
                                     * // => [3, 1, 2]
                                     *
                                     * var users = [
                                     *   { 'user': 'fred' },
                                     *   { 'user': 'pebbles' },
                                     *   { 'user': 'barney' }
                                     * ];
                                     *
                                     * // using the `_.property` callback shorthand
                                     * _.pluck(_.sortBy(users, 'user'), 'user');
                                     * // => ['barney', 'fred', 'pebbles']
                                     */
                                    function sortBy(collection, iteratee, thisArg) {
                                        if (collection == null) {
                                            return [];
                                        }
                                        if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
                                            iteratee = undefined;
                                        }
                                        var index = -1;
                                        iteratee = getCallback(iteratee, thisArg, 3);

                                        var result = baseMap(collection, function (value, key, collection) {
                                            return {
                                                'criteria': iteratee(value, key, collection),
                                                'index': ++index,
                                                'value': value
                                            };
                                        });
                                        return baseSortBy(result, compareAscending);
                                    }

                                    /**
                                     * This method is like `_.sortBy` except that it can sort by multiple iteratees
                                     * or property names.
                                     *
                                     * If a property name is provided for an iteratee the created `_.property`
                                     * style callback returns the property value of the given element.
                                     *
                                     * If an object is provided for an iteratee the created `_.matches` style
                                     * callback returns `true` for elements that have the properties of the given
                                     * object, else `false`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Collection
                                     * @param {Array|Object|string} collection The collection to iterate over.
                                     * @param {...(Function|Function[]|Object|Object[]|string|string[])} iteratees
                                     *  The iteratees to sort by, specified as individual values or arrays of values.
                                     * @returns {Array} Returns the new sorted array.
                                     * @example
                                     *
                                     * var users = [
                                     *   { 'user': 'fred',   'age': 48 },
                                     *   { 'user': 'barney', 'age': 36 },
                                     *   { 'user': 'fred',   'age': 42 },
                                     *   { 'user': 'barney', 'age': 34 }
                                     * ];
                                     *
                                     * _.map(_.sortByAll(users, ['user', 'age']), _.values);
                                     * // => [['barney', 34], ['barney', 36], ['fred', 42], ['fred', 48]]
                                     *
                                     * _.map(_.sortByAll(users, 'user', function(chr) {
     *   return Math.floor(chr.age / 10);
     * }), _.values);
                                     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
                                     */
                                    var sortByAll = restParam(function (collection, iteratees) {
                                        if (collection == null) {
                                            return [];
                                        }
                                        var guard = iteratees[2];
                                        if (guard && isIterateeCall(iteratees[0], iteratees[1], guard)) {
                                            iteratees.length = 1;
                                        }
                                        return baseSortByOrder(collection, baseFlatten(iteratees), []);
                                    });

                                    /**
                                     * This method is like `_.sortByAll` except that it allows specifying the
                                     * sort orders of the iteratees to sort by. If `orders` is unspecified, all
                                     * values are sorted in ascending order. Otherwise, a value is sorted in
                                     * ascending order if its corresponding order is "asc", and descending if "desc".
                                     *
                                     * If a property name is provided for an iteratee the created `_.property`
                                     * style callback returns the property value of the given element.
                                     *
                                     * If an object is provided for an iteratee the created `_.matches` style
                                     * callback returns `true` for elements that have the properties of the given
                                     * object, else `false`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Collection
                                     * @param {Array|Object|string} collection The collection to iterate over.
                                     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
                                     * @param {boolean[]} [orders] The sort orders of `iteratees`.
                                     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
                                     * @returns {Array} Returns the new sorted array.
                                     * @example
                                     *
                                     * var users = [
                                     *   { 'user': 'fred',   'age': 48 },
                                     *   { 'user': 'barney', 'age': 34 },
                                     *   { 'user': 'fred',   'age': 42 },
                                     *   { 'user': 'barney', 'age': 36 }
                                     * ];
                                     *
                                     * // sort by `user` in ascending order and by `age` in descending order
                                     * _.map(_.sortByOrder(users, ['user', 'age'], ['asc', 'desc']), _.values);
                                     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
                                     */
                                    function sortByOrder(collection, iteratees, orders, guard) {
                                        if (collection == null) {
                                            return [];
                                        }
                                        if (guard && isIterateeCall(iteratees, orders, guard)) {
                                            orders = undefined;
                                        }
                                        if (!isArray(iteratees)) {
                                            iteratees = iteratees == null ? [] : [iteratees];
                                        }
                                        if (!isArray(orders)) {
                                            orders = orders == null ? [] : [orders];
                                        }
                                        return baseSortByOrder(collection, iteratees, orders);
                                    }

                                    /**
                                     * Performs a deep comparison between each element in `collection` and the
                                     * source object, returning an array of all elements that have equivalent
                                     * property values.
                                     *
                                     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
                                     * numbers, `Object` objects, regexes, and strings. Objects are compared by
                                     * their own, not inherited, enumerable properties. For comparing a single
                                     * own or inherited property value see `_.matchesProperty`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Collection
                                     * @param {Array|Object|string} collection The collection to search.
                                     * @param {Object} source The object of property values to match.
                                     * @returns {Array} Returns the new filtered array.
                                     * @example
                                     *
                                     * var users = [
                                     *   { 'user': 'barney', 'age': 36, 'active': false, 'pets': ['hoppy'] },
                                     *   { 'user': 'fred',   'age': 40, 'active': true, 'pets': ['baby puss', 'dino'] }
                                     * ];
                                     *
                                     * _.pluck(_.where(users, { 'age': 36, 'active': false }), 'user');
                                     * // => ['barney']
                                     *
                                     * _.pluck(_.where(users, { 'pets': ['dino'] }), 'user');
                                     * // => ['fred']
                                     */
                                    function where(collection, source) {
                                        return filter(collection, baseMatches(source));
                                    }

                                    /*------------------------------------------------------------------------*/

                                    /**
                                     * Gets the number of milliseconds that have elapsed since the Unix epoch
                                     * (1 January 1970 00:00:00 UTC).
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Date
                                     * @example
                                     *
                                     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
                                     * // => logs the number of milliseconds it took for the deferred function to be invoked
                                     */
                                    var now = nativeNow || function () {
                                        return new Date().getTime();
                                    };

                                    /*------------------------------------------------------------------------*/

                                    /**
                                     * The opposite of `_.before`; this method creates a function that invokes
                                     * `func` once it is called `n` or more times.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Function
                                     * @param {number} n The number of calls before `func` is invoked.
                                     * @param {Function} func The function to restrict.
                                     * @returns {Function} Returns the new restricted function.
                                     * @example
                                     *
                                     * var saves = ['profile', 'settings'];
                                     *
                                     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
                                     *
                                     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
                                     * // => logs 'done saving!' after the two async saves have completed
                                     */
                                    function after(n, func) {
                                        if (typeof func != 'function') {
                                            if (typeof n == 'function') {
                                                var temp = n;
                                                n = func;
                                                func = temp;
                                            } else {
                                                throw new TypeError(FUNC_ERROR_TEXT);
                                            }
                                        }
                                        n = nativeIsFinite(n = +n) ? n : 0;
                                        return function () {
                                            if (--n < 1) {
                                                return func.apply(this, arguments);
                                            }
                                        };
                                    }

                                    /**
                                     * Creates a function that accepts up to `n` arguments ignoring any
                                     * additional arguments.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Function
                                     * @param {Function} func The function to cap arguments for.
                                     * @param {number} [n=func.length] The arity cap.
                                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                                     * @returns {Function} Returns the new function.
                                     * @example
                                     *
                                     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
                                     * // => [6, 8, 10]
                                     */
                                    function ary(func, n, guard) {
                                        if (guard && isIterateeCall(func, n, guard)) {
                                            n = undefined;
                                        }
                                        n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);
                                        return createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);
                                    }

                                    /**
                                     * Creates a function that invokes `func`, with the `this` binding and arguments
                                     * of the created function, while it is called less than `n` times. Subsequent
                                     * calls to the created function return the result of the last `func` invocation.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Function
                                     * @param {number} n The number of calls at which `func` is no longer invoked.
                                     * @param {Function} func The function to restrict.
                                     * @returns {Function} Returns the new restricted function.
                                     * @example
                                     *
                                     * jQuery('#add').on('click', _.before(5, addContactToList));
                                     * // => allows adding up to 4 contacts to the list
                                     */
                                    function before(n, func) {
                                        var result;
                                        if (typeof func != 'function') {
                                            if (typeof n == 'function') {
                                                var temp = n;
                                                n = func;
                                                func = temp;
                                            } else {
                                                throw new TypeError(FUNC_ERROR_TEXT);
                                            }
                                        }
                                        return function () {
                                            if (--n > 0) {
                                                result = func.apply(this, arguments);
                                            }
                                            if (n <= 1) {
                                                func = undefined;
                                            }
                                            return result;
                                        };
                                    }

                                    /**
                                     * Creates a function that invokes `func` with the `this` binding of `thisArg`
                                     * and prepends any additional `_.bind` arguments to those provided to the
                                     * bound function.
                                     *
                                     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
                                     * may be used as a placeholder for partially applied arguments.
                                     *
                                     * **Note:** Unlike native `Function#bind` this method does not set the "length"
                                     * property of bound functions.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Function
                                     * @param {Function} func The function to bind.
                                     * @param {*} thisArg The `this` binding of `func`.
                                     * @param {...*} [partials] The arguments to be partially applied.
                                     * @returns {Function} Returns the new bound function.
                                     * @example
                                     *
                                     * var greet = function(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * };
                                     *
                                     * var object = { 'user': 'fred' };
                                     *
                                     * var bound = _.bind(greet, object, 'hi');
                                     * bound('!');
                                     * // => 'hi fred!'
                                     *
                                     * // using placeholders
                                     * var bound = _.bind(greet, object, _, '!');
                                     * bound('hi');
                                     * // => 'hi fred!'
                                     */
                                    var bind = restParam(function (func, thisArg, partials) {
                                        var bitmask = BIND_FLAG;
                                        if (partials.length) {
                                            var holders = replaceHolders(partials, bind.placeholder);
                                            bitmask |= PARTIAL_FLAG;
                                        }
                                        return createWrapper(func, bitmask, thisArg, partials, holders);
                                    });

                                    /**
                                     * Binds methods of an object to the object itself, overwriting the existing
                                     * method. Method names may be specified as individual arguments or as arrays
                                     * of method names. If no method names are provided all enumerable function
                                     * properties, own and inherited, of `object` are bound.
                                     *
                                     * **Note:** This method does not set the "length" property of bound functions.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Function
                                     * @param {Object} object The object to bind and assign the bound methods to.
                                     * @param {...(string|string[])} [methodNames] The object method names to bind,
                                     *  specified as individual method names or arrays of method names.
                                     * @returns {Object} Returns `object`.
                                     * @example
                                     *
                                     * var view = {
     *   'label': 'docs',
     *   'onClick': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
                                     *
                                     * _.bindAll(view);
                                     * jQuery('#docs').on('click', view.onClick);
                                     * // => logs 'clicked docs' when the element is clicked
                                     */
                                    var bindAll = restParam(function (object, methodNames) {
                                        methodNames = methodNames.length ? baseFlatten(methodNames) : functions(object);

                                        var index = -1,
                                            length = methodNames.length;

                                        while (++index < length) {
                                            var key = methodNames[index];
                                            object[key] = createWrapper(object[key], BIND_FLAG, object);
                                        }
                                        return object;
                                    });

                                    /**
                                     * Creates a function that invokes the method at `object[key]` and prepends
                                     * any additional `_.bindKey` arguments to those provided to the bound function.
                                     *
                                     * This method differs from `_.bind` by allowing bound functions to reference
                                     * methods that may be redefined or don't yet exist.
                                     * See [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
                                     * for more details.
                                     *
                                     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
                                     * builds, may be used as a placeholder for partially applied arguments.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Function
                                     * @param {Object} object The object the method belongs to.
                                     * @param {string} key The key of the method.
                                     * @param {...*} [partials] The arguments to be partially applied.
                                     * @returns {Function} Returns the new bound function.
                                     * @example
                                     *
                                     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
                                     *
                                     * var bound = _.bindKey(object, 'greet', 'hi');
                                     * bound('!');
                                     * // => 'hi fred!'
                                     *
                                     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
                                     *
                                     * bound('!');
                                     * // => 'hiya fred!'
                                     *
                                     * // using placeholders
                                     * var bound = _.bindKey(object, 'greet', _, '!');
                                     * bound('hi');
                                     * // => 'hiya fred!'
                                     */
                                    var bindKey = restParam(function (object, key, partials) {
                                        var bitmask = BIND_FLAG | BIND_KEY_FLAG;
                                        if (partials.length) {
                                            var holders = replaceHolders(partials, bindKey.placeholder);
                                            bitmask |= PARTIAL_FLAG;
                                        }
                                        return createWrapper(key, bitmask, object, partials, holders);
                                    });

                                    /**
                                     * Creates a function that accepts one or more arguments of `func` that when
                                     * called either invokes `func` returning its result, if all `func` arguments
                                     * have been provided, or returns a function that accepts one or more of the
                                     * remaining `func` arguments, and so on. The arity of `func` may be specified
                                     * if `func.length` is not sufficient.
                                     *
                                     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
                                     * may be used as a placeholder for provided arguments.
                                     *
                                     * **Note:** This method does not set the "length" property of curried functions.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Function
                                     * @param {Function} func The function to curry.
                                     * @param {number} [arity=func.length] The arity of `func`.
                                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                                     * @returns {Function} Returns the new curried function.
                                     * @example
                                     *
                                     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
                                     *
                                     * var curried = _.curry(abc);
                                     *
                                     * curried(1)(2)(3);
                                     * // => [1, 2, 3]
                                     *
                                     * curried(1, 2)(3);
                                     * // => [1, 2, 3]
                                     *
                                     * curried(1, 2, 3);
                                     * // => [1, 2, 3]
                                     *
                                     * // using placeholders
                                     * curried(1)(_, 3)(2);
                                     * // => [1, 2, 3]
                                     */
                                    var curry = createCurry(CURRY_FLAG);

                                    /**
                                     * This method is like `_.curry` except that arguments are applied to `func`
                                     * in the manner of `_.partialRight` instead of `_.partial`.
                                     *
                                     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
                                     * builds, may be used as a placeholder for provided arguments.
                                     *
                                     * **Note:** This method does not set the "length" property of curried functions.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Function
                                     * @param {Function} func The function to curry.
                                     * @param {number} [arity=func.length] The arity of `func`.
                                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                                     * @returns {Function} Returns the new curried function.
                                     * @example
                                     *
                                     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
                                     *
                                     * var curried = _.curryRight(abc);
                                     *
                                     * curried(3)(2)(1);
                                     * // => [1, 2, 3]
                                     *
                                     * curried(2, 3)(1);
                                     * // => [1, 2, 3]
                                     *
                                     * curried(1, 2, 3);
                                     * // => [1, 2, 3]
                                     *
                                     * // using placeholders
                                     * curried(3)(1, _)(2);
                                     * // => [1, 2, 3]
                                     */
                                    var curryRight = createCurry(CURRY_RIGHT_FLAG);

                                    /**
                                     * Creates a debounced function that delays invoking `func` until after `wait`
                                     * milliseconds have elapsed since the last time the debounced function was
                                     * invoked. The debounced function comes with a `cancel` method to cancel
                                     * delayed invocations. Provide an options object to indicate that `func`
                                     * should be invoked on the leading and/or trailing edge of the `wait` timeout.
                                     * Subsequent calls to the debounced function return the result of the last
                                     * `func` invocation.
                                     *
                                     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
                                     * on the trailing edge of the timeout only if the the debounced function is
                                     * invoked more than once during the `wait` timeout.
                                     *
                                     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
                                     * for details over the differences between `_.debounce` and `_.throttle`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Function
                                     * @param {Function} func The function to debounce.
                                     * @param {number} [wait=0] The number of milliseconds to delay.
                                     * @param {Object} [options] The options object.
                                     * @param {boolean} [options.leading=false] Specify invoking on the leading
                                     *  edge of the timeout.
                                     * @param {number} [options.maxWait] The maximum time `func` is allowed to be
                                     *  delayed before it is invoked.
                                     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
                                     *  edge of the timeout.
                                     * @returns {Function} Returns the new debounced function.
                                     * @example
                                     *
                                     * // avoid costly calculations while the window size is in flux
                                     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
                                     *
                                     * // invoke `sendMail` when the click event is fired, debouncing subsequent calls
                                     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
                                     *
                                     * // ensure `batchLog` is invoked once after 1 second of debounced calls
                                     * var source = new EventSource('/stream');
                                     * jQuery(source).on('message', _.debounce(batchLog, 250, {
     *   'maxWait': 1000
     * }));
                                     *
                                     * // cancel a debounced call
                                     * var todoChanges = _.debounce(batchLog, 1000);
                                     * Object.observe(models.todo, todoChanges);
                                     *
                                     * Object.observe(models, function(changes) {
     *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {
     *     todoChanges.cancel();
     *   }
     * }, ['delete']);
                                     *
                                     * // ...at some point `models.todo` is changed
                                     * models.todo.completed = true;
                                     *
                                     * // ...before 1 second has passed `models.todo` is deleted
                                     * // which cancels the debounced `todoChanges` call
                                     * delete models.todo;
                                     */
                                    function debounce(func, wait, options) {
                                        var args,
                                            maxTimeoutId,
                                            result,
                                            stamp,
                                            thisArg,
                                            timeoutId,
                                            trailingCall,
                                            lastCalled = 0,
                                            maxWait = false,
                                            trailing = true;

                                        if (typeof func != 'function') {
                                            throw new TypeError(FUNC_ERROR_TEXT);
                                        }
                                        wait = wait < 0 ? 0 : (+wait || 0);
                                        if (options === true) {
                                            var leading = true;
                                            trailing = false;
                                        } else if (isObject(options)) {
                                            leading = !!options.leading;
                                            maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
                                            trailing = 'trailing' in options ? !!options.trailing : trailing;
                                        }

                                        function cancel() {
                                            if (timeoutId) {
                                                clearTimeout(timeoutId);
                                            }
                                            if (maxTimeoutId) {
                                                clearTimeout(maxTimeoutId);
                                            }
                                            lastCalled = 0;
                                            maxTimeoutId = timeoutId = trailingCall = undefined;
                                        }

                                        function complete(isCalled, id) {
                                            if (id) {
                                                clearTimeout(id);
                                            }
                                            maxTimeoutId = timeoutId = trailingCall = undefined;
                                            if (isCalled) {
                                                lastCalled = now();
                                                result = func.apply(thisArg, args);
                                                if (!timeoutId && !maxTimeoutId) {
                                                    args = thisArg = undefined;
                                                }
                                            }
                                        }

                                        function delayed() {
                                            var remaining = wait - (now() - stamp);
                                            if (remaining <= 0 || remaining > wait) {
                                                complete(trailingCall, maxTimeoutId);
                                            } else {
                                                timeoutId = setTimeout(delayed, remaining);
                                            }
                                        }

                                        function maxDelayed() {
                                            complete(trailing, timeoutId);
                                        }

                                        function debounced() {
                                            args = arguments;
                                            stamp = now();
                                            thisArg = this;
                                            trailingCall = trailing && (timeoutId || !leading);

                                            if (maxWait === false) {
                                                var leadingCall = leading && !timeoutId;
                                            } else {
                                                if (!maxTimeoutId && !leading) {
                                                    lastCalled = stamp;
                                                }
                                                var remaining = maxWait - (stamp - lastCalled),
                                                    isCalled = remaining <= 0 || remaining > maxWait;

                                                if (isCalled) {
                                                    if (maxTimeoutId) {
                                                        maxTimeoutId = clearTimeout(maxTimeoutId);
                                                    }
                                                    lastCalled = stamp;
                                                    result = func.apply(thisArg, args);
                                                }
                                                else if (!maxTimeoutId) {
                                                    maxTimeoutId = setTimeout(maxDelayed, remaining);
                                                }
                                            }
                                            if (isCalled && timeoutId) {
                                                timeoutId = clearTimeout(timeoutId);
                                            }
                                            else if (!timeoutId && wait !== maxWait) {
                                                timeoutId = setTimeout(delayed, wait);
                                            }
                                            if (leadingCall) {
                                                isCalled = true;
                                                result = func.apply(thisArg, args);
                                            }
                                            if (isCalled && !timeoutId && !maxTimeoutId) {
                                                args = thisArg = undefined;
                                            }
                                            return result;
                                        }

                                        debounced.cancel = cancel;
                                        return debounced;
                                    }

                                    /**
                                     * Defers invoking the `func` until the current call stack has cleared. Any
                                     * additional arguments are provided to `func` when it is invoked.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Function
                                     * @param {Function} func The function to defer.
                                     * @param {...*} [args] The arguments to invoke the function with.
                                     * @returns {number} Returns the timer id.
                                     * @example
                                     *
                                     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
                                     * // logs 'deferred' after one or more milliseconds
                                     */
                                    var defer = restParam(function (func, args) {
                                        return baseDelay(func, 1, args);
                                    });

                                    /**
                                     * Invokes `func` after `wait` milliseconds. Any additional arguments are
                                     * provided to `func` when it is invoked.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Function
                                     * @param {Function} func The function to delay.
                                     * @param {number} wait The number of milliseconds to delay invocation.
                                     * @param {...*} [args] The arguments to invoke the function with.
                                     * @returns {number} Returns the timer id.
                                     * @example
                                     *
                                     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
                                     * // => logs 'later' after one second
                                     */
                                    var delay = restParam(function (func, wait, args) {
                                        return baseDelay(func, wait, args);
                                    });

                                    /**
                                     * Creates a function that returns the result of invoking the provided
                                     * functions with the `this` binding of the created function, where each
                                     * successive invocation is supplied the return value of the previous.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Function
                                     * @param {...Function} [funcs] Functions to invoke.
                                     * @returns {Function} Returns the new function.
                                     * @example
                                     *
                                     * function square(n) {
     *   return n * n;
     * }
                                     *
                                     * var addSquare = _.flow(_.add, square);
                                     * addSquare(1, 2);
                                     * // => 9
                                     */
                                    var flow = createFlow();

                                    /**
                                     * This method is like `_.flow` except that it creates a function that
                                     * invokes the provided functions from right to left.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @alias backflow, compose
                                     * @category Function
                                     * @param {...Function} [funcs] Functions to invoke.
                                     * @returns {Function} Returns the new function.
                                     * @example
                                     *
                                     * function square(n) {
     *   return n * n;
     * }
                                     *
                                     * var addSquare = _.flowRight(square, _.add);
                                     * addSquare(1, 2);
                                     * // => 9
                                     */
                                    var flowRight = createFlow(true);

                                    /**
                                     * Creates a function that memoizes the result of `func`. If `resolver` is
                                     * provided it determines the cache key for storing the result based on the
                                     * arguments provided to the memoized function. By default, the first argument
                                     * provided to the memoized function is coerced to a string and used as the
                                     * cache key. The `func` is invoked with the `this` binding of the memoized
                                     * function.
                                     *
                                     * **Note:** The cache is exposed as the `cache` property on the memoized
                                     * function. Its creation may be customized by replacing the `_.memoize.Cache`
                                     * constructor with one whose instances implement the [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)
                                     * method interface of `get`, `has`, and `set`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Function
                                     * @param {Function} func The function to have its output memoized.
                                     * @param {Function} [resolver] The function to resolve the cache key.
                                     * @returns {Function} Returns the new memoizing function.
                                     * @example
                                     *
                                     * var upperCase = _.memoize(function(string) {
     *   return string.toUpperCase();
     * });
                                     *
                                     * upperCase('fred');
                                     * // => 'FRED'
                                     *
                                     * // modifying the result cache
                                     * upperCase.cache.set('fred', 'BARNEY');
                                     * upperCase('fred');
                                     * // => 'BARNEY'
                                     *
                                     * // replacing `_.memoize.Cache`
                                     * var object = { 'user': 'fred' };
                                     * var other = { 'user': 'barney' };
                                     * var identity = _.memoize(_.identity);
                                     *
                                     * identity(object);
                                     * // => { 'user': 'fred' }
                                     * identity(other);
                                     * // => { 'user': 'fred' }
                                     *
                                     * _.memoize.Cache = WeakMap;
                                     * var identity = _.memoize(_.identity);
                                     *
                                     * identity(object);
                                     * // => { 'user': 'fred' }
                                     * identity(other);
                                     * // => { 'user': 'barney' }
                                     */
                                    function memoize(func, resolver) {
                                        if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
                                            throw new TypeError(FUNC_ERROR_TEXT);
                                        }
                                        var memoized = function () {
                                            var args = arguments,
                                                key = resolver ? resolver.apply(this, args) : args[0],
                                                cache = memoized.cache;

                                            if (cache.has(key)) {
                                                return cache.get(key);
                                            }
                                            var result = func.apply(this, args);
                                            memoized.cache = cache.set(key, result);
                                            return result;
                                        };
                                        memoized.cache = new memoize.Cache;
                                        return memoized;
                                    }

                                    /**
                                     * Creates a function that runs each argument through a corresponding
                                     * transform function.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Function
                                     * @param {Function} func The function to wrap.
                                     * @param {...(Function|Function[])} [transforms] The functions to transform
                                     * arguments, specified as individual functions or arrays of functions.
                                     * @returns {Function} Returns the new function.
                                     * @example
                                     *
                                     * function doubled(n) {
     *   return n * 2;
     * }
                                     *
                                     * function square(n) {
     *   return n * n;
     * }
                                     *
                                     * var modded = _.modArgs(function(x, y) {
     *   return [x, y];
     * }, square, doubled);
                                     *
                                     * modded(1, 2);
                                     * // => [1, 4]
                                     *
                                     * modded(5, 10);
                                     * // => [25, 20]
                                     */
                                    var modArgs = restParam(function (func, transforms) {
                                        transforms = baseFlatten(transforms);
                                        if (typeof func != 'function' || !arrayEvery(transforms, baseIsFunction)) {
                                            throw new TypeError(FUNC_ERROR_TEXT);
                                        }
                                        var length = transforms.length;
                                        return restParam(function (args) {
                                            var index = nativeMin(args.length, length);
                                            while (index--) {
                                                args[index] = transforms[index](args[index]);
                                            }
                                            return func.apply(this, args);
                                        });
                                    });

                                    /**
                                     * Creates a function that negates the result of the predicate `func`. The
                                     * `func` predicate is invoked with the `this` binding and arguments of the
                                     * created function.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Function
                                     * @param {Function} predicate The predicate to negate.
                                     * @returns {Function} Returns the new function.
                                     * @example
                                     *
                                     * function isEven(n) {
     *   return n % 2 == 0;
     * }
                                     *
                                     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
                                     * // => [1, 3, 5]
                                     */
                                    function negate(predicate) {
                                        if (typeof predicate != 'function') {
                                            throw new TypeError(FUNC_ERROR_TEXT);
                                        }
                                        return function () {
                                            return !predicate.apply(this, arguments);
                                        };
                                    }

                                    /**
                                     * Creates a function that is restricted to invoking `func` once. Repeat calls
                                     * to the function return the value of the first call. The `func` is invoked
                                     * with the `this` binding and arguments of the created function.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Function
                                     * @param {Function} func The function to restrict.
                                     * @returns {Function} Returns the new restricted function.
                                     * @example
                                     *
                                     * var initialize = _.once(createApplication);
                                     * initialize();
                                     * initialize();
                                     * // `initialize` invokes `createApplication` once
                                     */
                                    function once(func) {
                                        return before(2, func);
                                    }

                                    /**
                                     * Creates a function that invokes `func` with `partial` arguments prepended
                                     * to those provided to the new function. This method is like `_.bind` except
                                     * it does **not** alter the `this` binding.
                                     *
                                     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
                                     * builds, may be used as a placeholder for partially applied arguments.
                                     *
                                     * **Note:** This method does not set the "length" property of partially
                                     * applied functions.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Function
                                     * @param {Function} func The function to partially apply arguments to.
                                     * @param {...*} [partials] The arguments to be partially applied.
                                     * @returns {Function} Returns the new partially applied function.
                                     * @example
                                     *
                                     * var greet = function(greeting, name) {
     *   return greeting + ' ' + name;
     * };
                                     *
                                     * var sayHelloTo = _.partial(greet, 'hello');
                                     * sayHelloTo('fred');
                                     * // => 'hello fred'
                                     *
                                     * // using placeholders
                                     * var greetFred = _.partial(greet, _, 'fred');
                                     * greetFred('hi');
                                     * // => 'hi fred'
                                     */
                                    var partial = createPartial(PARTIAL_FLAG);

                                    /**
                                     * This method is like `_.partial` except that partially applied arguments
                                     * are appended to those provided to the new function.
                                     *
                                     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
                                     * builds, may be used as a placeholder for partially applied arguments.
                                     *
                                     * **Note:** This method does not set the "length" property of partially
                                     * applied functions.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Function
                                     * @param {Function} func The function to partially apply arguments to.
                                     * @param {...*} [partials] The arguments to be partially applied.
                                     * @returns {Function} Returns the new partially applied function.
                                     * @example
                                     *
                                     * var greet = function(greeting, name) {
     *   return greeting + ' ' + name;
     * };
                                     *
                                     * var greetFred = _.partialRight(greet, 'fred');
                                     * greetFred('hi');
                                     * // => 'hi fred'
                                     *
                                     * // using placeholders
                                     * var sayHelloTo = _.partialRight(greet, 'hello', _);
                                     * sayHelloTo('fred');
                                     * // => 'hello fred'
                                     */
                                    var partialRight = createPartial(PARTIAL_RIGHT_FLAG);

                                    /**
                                     * Creates a function that invokes `func` with arguments arranged according
                                     * to the specified indexes where the argument value at the first index is
                                     * provided as the first argument, the argument value at the second index is
                                     * provided as the second argument, and so on.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Function
                                     * @param {Function} func The function to rearrange arguments for.
                                     * @param {...(number|number[])} indexes The arranged argument indexes,
                                     *  specified as individual indexes or arrays of indexes.
                                     * @returns {Function} Returns the new function.
                                     * @example
                                     *
                                     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, 2, 0, 1);
                                     *
                                     * rearged('b', 'c', 'a')
                                     * // => ['a', 'b', 'c']
                                     *
                                     * var map = _.rearg(_.map, [1, 0]);
                                     * map(function(n) {
     *   return n * 3;
     * }, [1, 2, 3]);
                                     * // => [3, 6, 9]
                                     */
                                    var rearg = restParam(function (func, indexes) {
                                        return createWrapper(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes));
                                    });

                                    /**
                                     * Creates a function that invokes `func` with the `this` binding of the
                                     * created function and arguments from `start` and beyond provided as an array.
                                     *
                                     * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Function
                                     * @param {Function} func The function to apply a rest parameter to.
                                     * @param {number} [start=func.length-1] The start position of the rest parameter.
                                     * @returns {Function} Returns the new function.
                                     * @example
                                     *
                                     * var say = _.restParam(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
                                     *
                                     * say('hello', 'fred', 'barney', 'pebbles');
                                     * // => 'hello fred, barney, & pebbles'
                                     */
                                    function restParam(func, start) {
                                        if (typeof func != 'function') {
                                            throw new TypeError(FUNC_ERROR_TEXT);
                                        }
                                        start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
                                        return function () {
                                            var args = arguments,
                                                index = -1,
                                                length = nativeMax(args.length - start, 0),
                                                rest = Array(length);

                                            while (++index < length) {
                                                rest[index] = args[start + index];
                                            }
                                            switch (start) {
                                                case 0:
                                                    return func.call(this, rest);
                                                case 1:
                                                    return func.call(this, args[0], rest);
                                                case 2:
                                                    return func.call(this, args[0], args[1], rest);
                                            }
                                            var otherArgs = Array(start + 1);
                                            index = -1;
                                            while (++index < start) {
                                                otherArgs[index] = args[index];
                                            }
                                            otherArgs[start] = rest;
                                            return func.apply(this, otherArgs);
                                        };
                                    }

                                    /**
                                     * Creates a function that invokes `func` with the `this` binding of the created
                                     * function and an array of arguments much like [`Function#apply`](https://es5.github.io/#x15.3.4.3).
                                     *
                                     * **Note:** This method is based on the [spread operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator).
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Function
                                     * @param {Function} func The function to spread arguments over.
                                     * @returns {Function} Returns the new function.
                                     * @example
                                     *
                                     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
                                     *
                                     * say(['fred', 'hello']);
                                     * // => 'fred says hello'
                                     *
                                     * // with a Promise
                                     * var numbers = Promise.all([
                                     *   Promise.resolve(40),
                                     *   Promise.resolve(36)
                                     * ]);
                                     *
                                     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
                                     * // => a Promise of 76
                                     */
                                    function spread(func) {
                                        if (typeof func != 'function') {
                                            throw new TypeError(FUNC_ERROR_TEXT);
                                        }
                                        return function (array) {
                                            return func.apply(this, array);
                                        };
                                    }

                                    /**
                                     * Creates a throttled function that only invokes `func` at most once per
                                     * every `wait` milliseconds. The throttled function comes with a `cancel`
                                     * method to cancel delayed invocations. Provide an options object to indicate
                                     * that `func` should be invoked on the leading and/or trailing edge of the
                                     * `wait` timeout. Subsequent calls to the throttled function return the
                                     * result of the last `func` call.
                                     *
                                     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
                                     * on the trailing edge of the timeout only if the the throttled function is
                                     * invoked more than once during the `wait` timeout.
                                     *
                                     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
                                     * for details over the differences between `_.throttle` and `_.debounce`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Function
                                     * @param {Function} func The function to throttle.
                                     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
                                     * @param {Object} [options] The options object.
                                     * @param {boolean} [options.leading=true] Specify invoking on the leading
                                     *  edge of the timeout.
                                     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
                                     *  edge of the timeout.
                                     * @returns {Function} Returns the new throttled function.
                                     * @example
                                     *
                                     * // avoid excessively updating the position while scrolling
                                     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
                                     *
                                     * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes
                                     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
     *   'trailing': false
     * }));
                                     *
                                     * // cancel a trailing throttled call
                                     * jQuery(window).on('popstate', throttled.cancel);
                                     */
                                    function throttle(func, wait, options) {
                                        var leading = true,
                                            trailing = true;

                                        if (typeof func != 'function') {
                                            throw new TypeError(FUNC_ERROR_TEXT);
                                        }
                                        if (options === false) {
                                            leading = false;
                                        } else if (isObject(options)) {
                                            leading = 'leading' in options ? !!options.leading : leading;
                                            trailing = 'trailing' in options ? !!options.trailing : trailing;
                                        }
                                        return debounce(func, wait, {
                                            'leading': leading,
                                            'maxWait': +wait,
                                            'trailing': trailing
                                        });
                                    }

                                    /**
                                     * Creates a function that provides `value` to the wrapper function as its
                                     * first argument. Any additional arguments provided to the function are
                                     * appended to those provided to the wrapper function. The wrapper is invoked
                                     * with the `this` binding of the created function.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Function
                                     * @param {*} value The value to wrap.
                                     * @param {Function} wrapper The wrapper function.
                                     * @returns {Function} Returns the new function.
                                     * @example
                                     *
                                     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
                                     *
                                     * p('fred, barney, & pebbles');
                                     * // => '<p>fred, barney, &amp; pebbles</p>'
                                     */
                                    function wrap(value, wrapper) {
                                        wrapper = wrapper == null ? identity : wrapper;
                                        return createWrapper(wrapper, PARTIAL_FLAG, undefined, [value], []);
                                    }

                                    /*------------------------------------------------------------------------*/

                                    /**
                                     * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,
                                     * otherwise they are assigned by reference. If `customizer` is provided it is
                                     * invoked to produce the cloned values. If `customizer` returns `undefined`
                                     * cloning is handled by the method instead. The `customizer` is bound to
                                     * `thisArg` and invoked with two argument; (value [, index|key, object]).
                                     *
                                     * **Note:** This method is loosely based on the
                                     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
                                     * The enumerable properties of `arguments` objects and objects created by
                                     * constructors other than `Object` are cloned to plain `Object` objects. An
                                     * empty object is returned for uncloneable values such as functions, DOM nodes,
                                     * Maps, Sets, and WeakMaps.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Lang
                                     * @param {*} value The value to clone.
                                     * @param {boolean} [isDeep] Specify a deep clone.
                                     * @param {Function} [customizer] The function to customize cloning values.
                                     * @param {*} [thisArg] The `this` binding of `customizer`.
                                     * @returns {*} Returns the cloned value.
                                     * @example
                                     *
                                     * var users = [
                                     *   { 'user': 'barney' },
                                     *   { 'user': 'fred' }
                                     * ];
                                     *
                                     * var shallow = _.clone(users);
                                     * shallow[0] === users[0];
                                     * // => true
                                     *
                                     * var deep = _.clone(users, true);
                                     * deep[0] === users[0];
                                     * // => false
                                     *
                                     * // using a customizer callback
                                     * var el = _.clone(document.body, function(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * });
                                     *
                                     * el === document.body
                                     * // => false
                                     * el.nodeName
                                     * // => BODY
                                     * el.childNodes.length;
                                     * // => 0
                                     */
                                    function clone(value, isDeep, customizer, thisArg) {
                                        if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
                                            isDeep = false;
                                        }
                                        else if (typeof isDeep == 'function') {
                                            thisArg = customizer;
                                            customizer = isDeep;
                                            isDeep = false;
                                        }
                                        return typeof customizer == 'function'
                                            ? baseClone(value, isDeep, bindCallback(customizer, thisArg, 1))
                                            : baseClone(value, isDeep);
                                    }

                                    /**
                                     * Creates a deep clone of `value`. If `customizer` is provided it is invoked
                                     * to produce the cloned values. If `customizer` returns `undefined` cloning
                                     * is handled by the method instead. The `customizer` is bound to `thisArg`
                                     * and invoked with two argument; (value [, index|key, object]).
                                     *
                                     * **Note:** This method is loosely based on the
                                     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
                                     * The enumerable properties of `arguments` objects and objects created by
                                     * constructors other than `Object` are cloned to plain `Object` objects. An
                                     * empty object is returned for uncloneable values such as functions, DOM nodes,
                                     * Maps, Sets, and WeakMaps.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Lang
                                     * @param {*} value The value to deep clone.
                                     * @param {Function} [customizer] The function to customize cloning values.
                                     * @param {*} [thisArg] The `this` binding of `customizer`.
                                     * @returns {*} Returns the deep cloned value.
                                     * @example
                                     *
                                     * var users = [
                                     *   { 'user': 'barney' },
                                     *   { 'user': 'fred' }
                                     * ];
                                     *
                                     * var deep = _.cloneDeep(users);
                                     * deep[0] === users[0];
                                     * // => false
                                     *
                                     * // using a customizer callback
                                     * var el = _.cloneDeep(document.body, function(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * });
                                     *
                                     * el === document.body
                                     * // => false
                                     * el.nodeName
                                     * // => BODY
                                     * el.childNodes.length;
                                     * // => 20
                                     */
                                    function cloneDeep(value, customizer, thisArg) {
                                        return typeof customizer == 'function'
                                            ? baseClone(value, true, bindCallback(customizer, thisArg, 1))
                                            : baseClone(value, true);
                                    }

                                    /**
                                     * Checks if `value` is greater than `other`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Lang
                                     * @param {*} value The value to compare.
                                     * @param {*} other The other value to compare.
                                     * @returns {boolean} Returns `true` if `value` is greater than `other`, else `false`.
                                     * @example
                                     *
                                     * _.gt(3, 1);
                                     * // => true
                                     *
                                     * _.gt(3, 3);
                                     * // => false
                                     *
                                     * _.gt(1, 3);
                                     * // => false
                                     */
                                    function gt(value, other) {
                                        return value > other;
                                    }

                                    /**
                                     * Checks if `value` is greater than or equal to `other`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Lang
                                     * @param {*} value The value to compare.
                                     * @param {*} other The other value to compare.
                                     * @returns {boolean} Returns `true` if `value` is greater than or equal to `other`, else `false`.
                                     * @example
                                     *
                                     * _.gte(3, 1);
                                     * // => true
                                     *
                                     * _.gte(3, 3);
                                     * // => true
                                     *
                                     * _.gte(1, 3);
                                     * // => false
                                     */
                                    function gte(value, other) {
                                        return value >= other;
                                    }

                                    /**
                                     * Checks if `value` is classified as an `arguments` object.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Lang
                                     * @param {*} value The value to check.
                                     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
                                     * @example
                                     *
                                     * _.isArguments(function() { return arguments; }());
                                     * // => true
                                     *
                                     * _.isArguments([1, 2, 3]);
                                     * // => false
                                     */
                                    function isArguments(value) {
                                        return isObjectLike(value) && isArrayLike(value) &&
                                            hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
                                    }

                                    /**
                                     * Checks if `value` is classified as an `Array` object.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Lang
                                     * @param {*} value The value to check.
                                     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
                                     * @example
                                     *
                                     * _.isArray([1, 2, 3]);
                                     * // => true
                                     *
                                     * _.isArray(function() { return arguments; }());
                                     * // => false
                                     */
                                    var isArray = nativeIsArray || function (value) {
                                        return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
                                    };

                                    /**
                                     * Checks if `value` is classified as a boolean primitive or object.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Lang
                                     * @param {*} value The value to check.
                                     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
                                     * @example
                                     *
                                     * _.isBoolean(false);
                                     * // => true
                                     *
                                     * _.isBoolean(null);
                                     * // => false
                                     */
                                    function isBoolean(value) {
                                        return value === true || value === false || (isObjectLike(value) && objToString.call(value) == boolTag);
                                    }

                                    /**
                                     * Checks if `value` is classified as a `Date` object.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Lang
                                     * @param {*} value The value to check.
                                     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
                                     * @example
                                     *
                                     * _.isDate(new Date);
                                     * // => true
                                     *
                                     * _.isDate('Mon April 23 2012');
                                     * // => false
                                     */
                                    function isDate(value) {
                                        return isObjectLike(value) && objToString.call(value) == dateTag;
                                    }

                                    /**
                                     * Checks if `value` is a DOM element.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Lang
                                     * @param {*} value The value to check.
                                     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
                                     * @example
                                     *
                                     * _.isElement(document.body);
                                     * // => true
                                     *
                                     * _.isElement('<body>');
                                     * // => false
                                     */
                                    function isElement(value) {
                                        return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
                                    }

                                    /**
                                     * Checks if `value` is empty. A value is considered empty unless it is an
                                     * `arguments` object, array, string, or jQuery-like collection with a length
                                     * greater than `0` or an object with own enumerable properties.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Lang
                                     * @param {Array|Object|string} value The value to inspect.
                                     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
                                     * @example
                                     *
                                     * _.isEmpty(null);
                                     * // => true
                                     *
                                     * _.isEmpty(true);
                                     * // => true
                                     *
                                     * _.isEmpty(1);
                                     * // => true
                                     *
                                     * _.isEmpty([1, 2, 3]);
                                     * // => false
                                     *
                                     * _.isEmpty({ 'a': 1 });
                                     * // => false
                                     */
                                    function isEmpty(value) {
                                        if (value == null) {
                                            return true;
                                        }
                                        if (isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) ||
                                                (isObjectLike(value) && isFunction(value.splice)))) {
                                            return !value.length;
                                        }
                                        return !keys(value).length;
                                    }

                                    /**
                                     * Performs a deep comparison between two values to determine if they are
                                     * equivalent. If `customizer` is provided it is invoked to compare values.
                                     * If `customizer` returns `undefined` comparisons are handled by the method
                                     * instead. The `customizer` is bound to `thisArg` and invoked with three
                                     * arguments: (value, other [, index|key]).
                                     *
                                     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
                                     * numbers, `Object` objects, regexes, and strings. Objects are compared by
                                     * their own, not inherited, enumerable properties. Functions and DOM nodes
                                     * are **not** supported. Provide a customizer function to extend support
                                     * for comparing other values.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @alias eq
                                     * @category Lang
                                     * @param {*} value The value to compare.
                                     * @param {*} other The other value to compare.
                                     * @param {Function} [customizer] The function to customize value comparisons.
                                     * @param {*} [thisArg] The `this` binding of `customizer`.
                                     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
                                     * @example
                                     *
                                     * var object = { 'user': 'fred' };
                                     * var other = { 'user': 'fred' };
                                     *
                                     * object == other;
                                     * // => false
                                     *
                                     * _.isEqual(object, other);
                                     * // => true
                                     *
                                     * // using a customizer callback
                                     * var array = ['hello', 'goodbye'];
                                     * var other = ['hi', 'goodbye'];
                                     *
                                     * _.isEqual(array, other, function(value, other) {
     *   if (_.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/)) {
     *     return true;
     *   }
     * });
                                     * // => true
                                     */
                                    function isEqual(value, other, customizer, thisArg) {
                                        customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
                                        var result = customizer ? customizer(value, other) : undefined;
                                        return result === undefined ? baseIsEqual(value, other, customizer) : !!result;
                                    }

                                    /**
                                     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
                                     * `SyntaxError`, `TypeError`, or `URIError` object.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Lang
                                     * @param {*} value The value to check.
                                     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
                                     * @example
                                     *
                                     * _.isError(new Error);
                                     * // => true
                                     *
                                     * _.isError(Error);
                                     * // => false
                                     */
                                    function isError(value) {
                                        return isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag;
                                    }

                                    /**
                                     * Checks if `value` is a finite primitive number.
                                     *
                                     * **Note:** This method is based on [`Number.isFinite`](http://ecma-international.org/ecma-262/6.0/#sec-number.isfinite).
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Lang
                                     * @param {*} value The value to check.
                                     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
                                     * @example
                                     *
                                     * _.isFinite(10);
                                     * // => true
                                     *
                                     * _.isFinite('10');
                                     * // => false
                                     *
                                     * _.isFinite(true);
                                     * // => false
                                     *
                                     * _.isFinite(Object(10));
                                     * // => false
                                     *
                                     * _.isFinite(Infinity);
                                     * // => false
                                     */
                                    function isFinite(value) {
                                        return typeof value == 'number' && nativeIsFinite(value);
                                    }

                                    /**
                                     * Checks if `value` is classified as a `Function` object.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Lang
                                     * @param {*} value The value to check.
                                     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
                                     * @example
                                     *
                                     * _.isFunction(_);
                                     * // => true
                                     *
                                     * _.isFunction(/abc/);
                                     * // => false
                                     */
                                    function isFunction(value) {
                                        // The use of `Object#toString` avoids issues with the `typeof` operator
                                        // in older versions of Chrome and Safari which return 'function' for regexes
                                        // and Safari 8 equivalents which return 'object' for typed array constructors.
                                        return isObject(value) && objToString.call(value) == funcTag;
                                    }

                                    /**
                                     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
                                     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Lang
                                     * @param {*} value The value to check.
                                     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
                                     * @example
                                     *
                                     * _.isObject({});
                                     * // => true
                                     *
                                     * _.isObject([1, 2, 3]);
                                     * // => true
                                     *
                                     * _.isObject(1);
                                     * // => false
                                     */
                                    function isObject(value) {
                                        // Avoid a V8 JIT bug in Chrome 19-20.
                                        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
                                        var type = typeof value;
                                        return !!value && (type == 'object' || type == 'function');
                                    }

                                    /**
                                     * Performs a deep comparison between `object` and `source` to determine if
                                     * `object` contains equivalent property values. If `customizer` is provided
                                     * it is invoked to compare values. If `customizer` returns `undefined`
                                     * comparisons are handled by the method instead. The `customizer` is bound
                                     * to `thisArg` and invoked with three arguments: (value, other, index|key).
                                     *
                                     * **Note:** This method supports comparing properties of arrays, booleans,
                                     * `Date` objects, numbers, `Object` objects, regexes, and strings. Functions
                                     * and DOM nodes are **not** supported. Provide a customizer function to extend
                                     * support for comparing other values.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Lang
                                     * @param {Object} object The object to inspect.
                                     * @param {Object} source The object of property values to match.
                                     * @param {Function} [customizer] The function to customize value comparisons.
                                     * @param {*} [thisArg] The `this` binding of `customizer`.
                                     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
                                     * @example
                                     *
                                     * var object = { 'user': 'fred', 'age': 40 };
                                     *
                                     * _.isMatch(object, { 'age': 40 });
                                     * // => true
                                     *
                                     * _.isMatch(object, { 'age': 36 });
                                     * // => false
                                     *
                                     * // using a customizer callback
                                     * var object = { 'greeting': 'hello' };
                                     * var source = { 'greeting': 'hi' };
                                     *
                                     * _.isMatch(object, source, function(value, other) {
     *   return _.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/) || undefined;
     * });
                                     * // => true
                                     */
                                    function isMatch(object, source, customizer, thisArg) {
                                        customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
                                        return baseIsMatch(object, getMatchData(source), customizer);
                                    }

                                    /**
                                     * Checks if `value` is `NaN`.
                                     *
                                     * **Note:** This method is not the same as [`isNaN`](https://es5.github.io/#x15.1.2.4)
                                     * which returns `true` for `undefined` and other non-numeric values.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Lang
                                     * @param {*} value The value to check.
                                     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
                                     * @example
                                     *
                                     * _.isNaN(NaN);
                                     * // => true
                                     *
                                     * _.isNaN(new Number(NaN));
                                     * // => true
                                     *
                                     * isNaN(undefined);
                                     * // => true
                                     *
                                     * _.isNaN(undefined);
                                     * // => false
                                     */
                                    function isNaN(value) {
                                        // An `NaN` primitive is the only value that is not equal to itself.
                                        // Perform the `toStringTag` check first to avoid errors with some host objects in IE.
                                        return isNumber(value) && value != +value;
                                    }

                                    /**
                                     * Checks if `value` is a native function.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Lang
                                     * @param {*} value The value to check.
                                     * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
                                     * @example
                                     *
                                     * _.isNative(Array.prototype.push);
                                     * // => true
                                     *
                                     * _.isNative(_);
                                     * // => false
                                     */
                                    function isNative(value) {
                                        if (value == null) {
                                            return false;
                                        }
                                        if (isFunction(value)) {
                                            return reIsNative.test(fnToString.call(value));
                                        }
                                        return isObjectLike(value) && reIsHostCtor.test(value);
                                    }

                                    /**
                                     * Checks if `value` is `null`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Lang
                                     * @param {*} value The value to check.
                                     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
                                     * @example
                                     *
                                     * _.isNull(null);
                                     * // => true
                                     *
                                     * _.isNull(void 0);
                                     * // => false
                                     */
                                    function isNull(value) {
                                        return value === null;
                                    }

                                    /**
                                     * Checks if `value` is classified as a `Number` primitive or object.
                                     *
                                     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
                                     * as numbers, use the `_.isFinite` method.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Lang
                                     * @param {*} value The value to check.
                                     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
                                     * @example
                                     *
                                     * _.isNumber(8.4);
                                     * // => true
                                     *
                                     * _.isNumber(NaN);
                                     * // => true
                                     *
                                     * _.isNumber('8.4');
                                     * // => false
                                     */
                                    function isNumber(value) {
                                        return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag);
                                    }

                                    /**
                                     * Checks if `value` is a plain object, that is, an object created by the
                                     * `Object` constructor or one with a `[[Prototype]]` of `null`.
                                     *
                                     * **Note:** This method assumes objects created by the `Object` constructor
                                     * have no inherited enumerable properties.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Lang
                                     * @param {*} value The value to check.
                                     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
                                     * @example
                                     *
                                     * function Foo() {
     *   this.a = 1;
     * }
                                     *
                                     * _.isPlainObject(new Foo);
                                     * // => false
                                     *
                                     * _.isPlainObject([1, 2, 3]);
                                     * // => false
                                     *
                                     * _.isPlainObject({ 'x': 0, 'y': 0 });
                                     * // => true
                                     *
                                     * _.isPlainObject(Object.create(null));
                                     * // => true
                                     */
                                    function isPlainObject(value) {
                                        var Ctor;

                                        // Exit early for non `Object` objects.
                                        if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isArguments(value)) ||
                                            (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
                                            return false;
                                        }
                                        // IE < 9 iterates inherited properties before own properties. If the first
                                        // iterated property is an object's own property then there are no inherited
                                        // enumerable properties.
                                        var result;
                                        // In most environments an object's own properties are iterated before
                                        // its inherited properties. If the last iterated property is an object's
                                        // own property then there are no inherited enumerable properties.
                                        baseForIn(value, function (subValue, key) {
                                            result = key;
                                        });
                                        return result === undefined || hasOwnProperty.call(value, result);
                                    }

                                    /**
                                     * Checks if `value` is classified as a `RegExp` object.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Lang
                                     * @param {*} value The value to check.
                                     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
                                     * @example
                                     *
                                     * _.isRegExp(/abc/);
                                     * // => true
                                     *
                                     * _.isRegExp('/abc/');
                                     * // => false
                                     */
                                    function isRegExp(value) {
                                        return isObject(value) && objToString.call(value) == regexpTag;
                                    }

                                    /**
                                     * Checks if `value` is classified as a `String` primitive or object.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Lang
                                     * @param {*} value The value to check.
                                     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
                                     * @example
                                     *
                                     * _.isString('abc');
                                     * // => true
                                     *
                                     * _.isString(1);
                                     * // => false
                                     */
                                    function isString(value) {
                                        return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);
                                    }

                                    /**
                                     * Checks if `value` is classified as a typed array.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Lang
                                     * @param {*} value The value to check.
                                     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
                                     * @example
                                     *
                                     * _.isTypedArray(new Uint8Array);
                                     * // => true
                                     *
                                     * _.isTypedArray([]);
                                     * // => false
                                     */
                                    function isTypedArray(value) {
                                        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
                                    }

                                    /**
                                     * Checks if `value` is `undefined`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Lang
                                     * @param {*} value The value to check.
                                     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
                                     * @example
                                     *
                                     * _.isUndefined(void 0);
                                     * // => true
                                     *
                                     * _.isUndefined(null);
                                     * // => false
                                     */
                                    function isUndefined(value) {
                                        return value === undefined;
                                    }

                                    /**
                                     * Checks if `value` is less than `other`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Lang
                                     * @param {*} value The value to compare.
                                     * @param {*} other The other value to compare.
                                     * @returns {boolean} Returns `true` if `value` is less than `other`, else `false`.
                                     * @example
                                     *
                                     * _.lt(1, 3);
                                     * // => true
                                     *
                                     * _.lt(3, 3);
                                     * // => false
                                     *
                                     * _.lt(3, 1);
                                     * // => false
                                     */
                                    function lt(value, other) {
                                        return value < other;
                                    }

                                    /**
                                     * Checks if `value` is less than or equal to `other`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Lang
                                     * @param {*} value The value to compare.
                                     * @param {*} other The other value to compare.
                                     * @returns {boolean} Returns `true` if `value` is less than or equal to `other`, else `false`.
                                     * @example
                                     *
                                     * _.lte(1, 3);
                                     * // => true
                                     *
                                     * _.lte(3, 3);
                                     * // => true
                                     *
                                     * _.lte(3, 1);
                                     * // => false
                                     */
                                    function lte(value, other) {
                                        return value <= other;
                                    }

                                    /**
                                     * Converts `value` to an array.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Lang
                                     * @param {*} value The value to convert.
                                     * @returns {Array} Returns the converted array.
                                     * @example
                                     *
                                     * (function() {
     *   return _.toArray(arguments).slice(1);
     * }(1, 2, 3));
                                     * // => [2, 3]
                                     */
                                    function toArray(value) {
                                        var length = value ? getLength(value) : 0;
                                        if (!isLength(length)) {
                                            return values(value);
                                        }
                                        if (!length) {
                                            return [];
                                        }
                                        return arrayCopy(value);
                                    }

                                    /**
                                     * Converts `value` to a plain object flattening inherited enumerable
                                     * properties of `value` to own properties of the plain object.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Lang
                                     * @param {*} value The value to convert.
                                     * @returns {Object} Returns the converted plain object.
                                     * @example
                                     *
                                     * function Foo() {
     *   this.b = 2;
     * }
                                     *
                                     * Foo.prototype.c = 3;
                                     *
                                     * _.assign({ 'a': 1 }, new Foo);
                                     * // => { 'a': 1, 'b': 2 }
                                     *
                                     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
                                     * // => { 'a': 1, 'b': 2, 'c': 3 }
                                     */
                                    function toPlainObject(value) {
                                        return baseCopy(value, keysIn(value));
                                    }

                                    /*------------------------------------------------------------------------*/

                                    /**
                                     * Recursively merges own enumerable properties of the source object(s), that
                                     * don't resolve to `undefined` into the destination object. Subsequent sources
                                     * overwrite property assignments of previous sources. If `customizer` is
                                     * provided it is invoked to produce the merged values of the destination and
                                     * source properties. If `customizer` returns `undefined` merging is handled
                                     * by the method instead. The `customizer` is bound to `thisArg` and invoked
                                     * with five arguments: (objectValue, sourceValue, key, object, source).
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Object
                                     * @param {Object} object The destination object.
                                     * @param {...Object} [sources] The source objects.
                                     * @param {Function} [customizer] The function to customize assigned values.
                                     * @param {*} [thisArg] The `this` binding of `customizer`.
                                     * @returns {Object} Returns `object`.
                                     * @example
                                     *
                                     * var users = {
     *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
     * };
                                     *
                                     * var ages = {
     *   'data': [{ 'age': 36 }, { 'age': 40 }]
     * };
                                     *
                                     * _.merge(users, ages);
                                     * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
                                     *
                                     * // using a customizer callback
                                     * var object = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
                                     *
                                     * var other = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
                                     *
                                     * _.merge(object, other, function(a, b) {
     *   if (_.isArray(a)) {
     *     return a.concat(b);
     *   }
     * });
                                     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
                                     */
                                    var merge = createAssigner(baseMerge);

                                    /**
                                     * Assigns own enumerable properties of source object(s) to the destination
                                     * object. Subsequent sources overwrite property assignments of previous sources.
                                     * If `customizer` is provided it is invoked to produce the assigned values.
                                     * The `customizer` is bound to `thisArg` and invoked with five arguments:
                                     * (objectValue, sourceValue, key, object, source).
                                     *
                                     * **Note:** This method mutates `object` and is based on
                                     * [`Object.assign`](http://ecma-international.org/ecma-262/6.0/#sec-object.assign).
                                     *
                                     * @static
                                     * @memberOf _
                                     * @alias extend
                                     * @category Object
                                     * @param {Object} object The destination object.
                                     * @param {...Object} [sources] The source objects.
                                     * @param {Function} [customizer] The function to customize assigned values.
                                     * @param {*} [thisArg] The `this` binding of `customizer`.
                                     * @returns {Object} Returns `object`.
                                     * @example
                                     *
                                     * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
                                     * // => { 'user': 'fred', 'age': 40 }
                                     *
                                     * // using a customizer callback
                                     * var defaults = _.partialRight(_.assign, function(value, other) {
     *   return _.isUndefined(value) ? other : value;
     * });
                                     *
                                     * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
                                     * // => { 'user': 'barney', 'age': 36 }
                                     */
                                    var assign = createAssigner(function (object, source, customizer) {
                                        return customizer
                                            ? assignWith(object, source, customizer)
                                            : baseAssign(object, source);
                                    });

                                    /**
                                     * Creates an object that inherits from the given `prototype` object. If a
                                     * `properties` object is provided its own enumerable properties are assigned
                                     * to the created object.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Object
                                     * @param {Object} prototype The object to inherit from.
                                     * @param {Object} [properties] The properties to assign to the object.
                                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                                     * @returns {Object} Returns the new object.
                                     * @example
                                     *
                                     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
                                     *
                                     * function Circle() {
     *   Shape.call(this);
     * }
                                     *
                                     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
                                     *
                                     * var circle = new Circle;
                                     * circle instanceof Circle;
                                     * // => true
                                     *
                                     * circle instanceof Shape;
                                     * // => true
                                     */
                                    function create(prototype, properties, guard) {
                                        var result = baseCreate(prototype);
                                        if (guard && isIterateeCall(prototype, properties, guard)) {
                                            properties = undefined;
                                        }
                                        return properties ? baseAssign(result, properties) : result;
                                    }

                                    /**
                                     * Assigns own enumerable properties of source object(s) to the destination
                                     * object for all destination properties that resolve to `undefined`. Once a
                                     * property is set, additional values of the same property are ignored.
                                     *
                                     * **Note:** This method mutates `object`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Object
                                     * @param {Object} object The destination object.
                                     * @param {...Object} [sources] The source objects.
                                     * @returns {Object} Returns `object`.
                                     * @example
                                     *
                                     * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
                                     * // => { 'user': 'barney', 'age': 36 }
                                     */
                                    var defaults = createDefaults(assign, assignDefaults);

                                    /**
                                     * This method is like `_.defaults` except that it recursively assigns
                                     * default properties.
                                     *
                                     * **Note:** This method mutates `object`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Object
                                     * @param {Object} object The destination object.
                                     * @param {...Object} [sources] The source objects.
                                     * @returns {Object} Returns `object`.
                                     * @example
                                     *
                                     * _.defaultsDeep({ 'user': { 'name': 'barney' } }, { 'user': { 'name': 'fred', 'age': 36 } });
                                     * // => { 'user': { 'name': 'barney', 'age': 36 } }
                                     *
                                     */
                                    var defaultsDeep = createDefaults(merge, mergeDefaults);

                                    /**
                                     * This method is like `_.find` except that it returns the key of the first
                                     * element `predicate` returns truthy for instead of the element itself.
                                     *
                                     * If a property name is provided for `predicate` the created `_.property`
                                     * style callback returns the property value of the given element.
                                     *
                                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                                     * style callback returns `true` for elements that have a matching property
                                     * value, else `false`.
                                     *
                                     * If an object is provided for `predicate` the created `_.matches` style
                                     * callback returns `true` for elements that have the properties of the given
                                     * object, else `false`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Object
                                     * @param {Object} object The object to search.
                                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                                     *  per iteration.
                                     * @param {*} [thisArg] The `this` binding of `predicate`.
                                     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
                                     * @example
                                     *
                                     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
                                     *
                                     * _.findKey(users, function(chr) {
     *   return chr.age < 40;
     * });
                                     * // => 'barney' (iteration order is not guaranteed)
                                     *
                                     * // using the `_.matches` callback shorthand
                                     * _.findKey(users, { 'age': 1, 'active': true });
                                     * // => 'pebbles'
                                     *
                                     * // using the `_.matchesProperty` callback shorthand
                                     * _.findKey(users, 'active', false);
                                     * // => 'fred'
                                     *
                                     * // using the `_.property` callback shorthand
                                     * _.findKey(users, 'active');
                                     * // => 'barney'
                                     */
                                    var findKey = createFindKey(baseForOwn);

                                    /**
                                     * This method is like `_.findKey` except that it iterates over elements of
                                     * a collection in the opposite order.
                                     *
                                     * If a property name is provided for `predicate` the created `_.property`
                                     * style callback returns the property value of the given element.
                                     *
                                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                                     * style callback returns `true` for elements that have a matching property
                                     * value, else `false`.
                                     *
                                     * If an object is provided for `predicate` the created `_.matches` style
                                     * callback returns `true` for elements that have the properties of the given
                                     * object, else `false`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Object
                                     * @param {Object} object The object to search.
                                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                                     *  per iteration.
                                     * @param {*} [thisArg] The `this` binding of `predicate`.
                                     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
                                     * @example
                                     *
                                     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
                                     *
                                     * _.findLastKey(users, function(chr) {
     *   return chr.age < 40;
     * });
                                     * // => returns `pebbles` assuming `_.findKey` returns `barney`
                                     *
                                     * // using the `_.matches` callback shorthand
                                     * _.findLastKey(users, { 'age': 36, 'active': true });
                                     * // => 'barney'
                                     *
                                     * // using the `_.matchesProperty` callback shorthand
                                     * _.findLastKey(users, 'active', false);
                                     * // => 'fred'
                                     *
                                     * // using the `_.property` callback shorthand
                                     * _.findLastKey(users, 'active');
                                     * // => 'pebbles'
                                     */
                                    var findLastKey = createFindKey(baseForOwnRight);

                                    /**
                                     * Iterates over own and inherited enumerable properties of an object invoking
                                     * `iteratee` for each property. The `iteratee` is bound to `thisArg` and invoked
                                     * with three arguments: (value, key, object). Iteratee functions may exit
                                     * iteration early by explicitly returning `false`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Object
                                     * @param {Object} object The object to iterate over.
                                     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                                     * @returns {Object} Returns `object`.
                                     * @example
                                     *
                                     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
                                     *
                                     * Foo.prototype.c = 3;
                                     *
                                     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
                                     * // => logs 'a', 'b', and 'c' (iteration order is not guaranteed)
                                     */
                                    var forIn = createForIn(baseFor);

                                    /**
                                     * This method is like `_.forIn` except that it iterates over properties of
                                     * `object` in the opposite order.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Object
                                     * @param {Object} object The object to iterate over.
                                     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                                     * @returns {Object} Returns `object`.
                                     * @example
                                     *
                                     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
                                     *
                                     * Foo.prototype.c = 3;
                                     *
                                     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
                                     * // => logs 'c', 'b', and 'a' assuming `_.forIn ` logs 'a', 'b', and 'c'
                                     */
                                    var forInRight = createForIn(baseForRight);

                                    /**
                                     * Iterates over own enumerable properties of an object invoking `iteratee`
                                     * for each property. The `iteratee` is bound to `thisArg` and invoked with
                                     * three arguments: (value, key, object). Iteratee functions may exit iteration
                                     * early by explicitly returning `false`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Object
                                     * @param {Object} object The object to iterate over.
                                     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                                     * @returns {Object} Returns `object`.
                                     * @example
                                     *
                                     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
                                     *
                                     * Foo.prototype.c = 3;
                                     *
                                     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
                                     * // => logs 'a' and 'b' (iteration order is not guaranteed)
                                     */
                                    var forOwn = createForOwn(baseForOwn);

                                    /**
                                     * This method is like `_.forOwn` except that it iterates over properties of
                                     * `object` in the opposite order.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Object
                                     * @param {Object} object The object to iterate over.
                                     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                                     * @returns {Object} Returns `object`.
                                     * @example
                                     *
                                     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
                                     *
                                     * Foo.prototype.c = 3;
                                     *
                                     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
                                     * // => logs 'b' and 'a' assuming `_.forOwn` logs 'a' and 'b'
                                     */
                                    var forOwnRight = createForOwn(baseForOwnRight);

                                    /**
                                     * Creates an array of function property names from all enumerable properties,
                                     * own and inherited, of `object`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @alias methods
                                     * @category Object
                                     * @param {Object} object The object to inspect.
                                     * @returns {Array} Returns the new array of property names.
                                     * @example
                                     *
                                     * _.functions(_);
                                     * // => ['after', 'ary', 'assign', ...]
                                     */
                                    function functions(object) {
                                        return baseFunctions(object, keysIn(object));
                                    }

                                    /**
                                     * Gets the property value at `path` of `object`. If the resolved value is
                                     * `undefined` the `defaultValue` is used in its place.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Object
                                     * @param {Object} object The object to query.
                                     * @param {Array|string} path The path of the property to get.
                                     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
                                     * @returns {*} Returns the resolved value.
                                     * @example
                                     *
                                     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
                                     *
                                     * _.get(object, 'a[0].b.c');
                                     * // => 3
                                     *
                                     * _.get(object, ['a', '0', 'b', 'c']);
                                     * // => 3
                                     *
                                     * _.get(object, 'a.b.c', 'default');
                                     * // => 'default'
                                     */
                                    function get(object, path, defaultValue) {
                                        var result = object == null ? undefined : baseGet(object, toPath(path), path + '');
                                        return result === undefined ? defaultValue : result;
                                    }

                                    /**
                                     * Checks if `path` is a direct property.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Object
                                     * @param {Object} object The object to query.
                                     * @param {Array|string} path The path to check.
                                     * @returns {boolean} Returns `true` if `path` is a direct property, else `false`.
                                     * @example
                                     *
                                     * var object = { 'a': { 'b': { 'c': 3 } } };
                                     *
                                     * _.has(object, 'a');
                                     * // => true
                                     *
                                     * _.has(object, 'a.b.c');
                                     * // => true
                                     *
                                     * _.has(object, ['a', 'b', 'c']);
                                     * // => true
                                     */
                                    function has(object, path) {
                                        if (object == null) {
                                            return false;
                                        }
                                        var result = hasOwnProperty.call(object, path);
                                        if (!result && !isKey(path)) {
                                            path = toPath(path);
                                            object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
                                            if (object == null) {
                                                return false;
                                            }
                                            path = last(path);
                                            result = hasOwnProperty.call(object, path);
                                        }
                                        return result || (isLength(object.length) && isIndex(path, object.length) &&
                                            (isArray(object) || isArguments(object)));
                                    }

                                    /**
                                     * Creates an object composed of the inverted keys and values of `object`.
                                     * If `object` contains duplicate values, subsequent values overwrite property
                                     * assignments of previous values unless `multiValue` is `true`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Object
                                     * @param {Object} object The object to invert.
                                     * @param {boolean} [multiValue] Allow multiple values per key.
                                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                                     * @returns {Object} Returns the new inverted object.
                                     * @example
                                     *
                                     * var object = { 'a': 1, 'b': 2, 'c': 1 };
                                     *
                                     * _.invert(object);
                                     * // => { '1': 'c', '2': 'b' }
                                     *
                                     * // with `multiValue`
                                     * _.invert(object, true);
                                     * // => { '1': ['a', 'c'], '2': ['b'] }
                                     */
                                    function invert(object, multiValue, guard) {
                                        if (guard && isIterateeCall(object, multiValue, guard)) {
                                            multiValue = undefined;
                                        }
                                        var index = -1,
                                            props = keys(object),
                                            length = props.length,
                                            result = {};

                                        while (++index < length) {
                                            var key = props[index],
                                                value = object[key];

                                            if (multiValue) {
                                                if (hasOwnProperty.call(result, value)) {
                                                    result[value].push(key);
                                                } else {
                                                    result[value] = [key];
                                                }
                                            }
                                            else {
                                                result[value] = key;
                                            }
                                        }
                                        return result;
                                    }

                                    /**
                                     * Creates an array of the own enumerable property names of `object`.
                                     *
                                     * **Note:** Non-object values are coerced to objects. See the
                                     * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
                                     * for more details.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Object
                                     * @param {Object} object The object to query.
                                     * @returns {Array} Returns the array of property names.
                                     * @example
                                     *
                                     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
                                     *
                                     * Foo.prototype.c = 3;
                                     *
                                     * _.keys(new Foo);
                                     * // => ['a', 'b'] (iteration order is not guaranteed)
                                     *
                                     * _.keys('hi');
                                     * // => ['0', '1']
                                     */
                                    var keys = !nativeKeys ? shimKeys : function (object) {
                                        var Ctor = object == null ? undefined : object.constructor;
                                        if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
                                            (typeof object != 'function' && isArrayLike(object))) {
                                            return shimKeys(object);
                                        }
                                        return isObject(object) ? nativeKeys(object) : [];
                                    };

                                    /**
                                     * Creates an array of the own and inherited enumerable property names of `object`.
                                     *
                                     * **Note:** Non-object values are coerced to objects.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Object
                                     * @param {Object} object The object to query.
                                     * @returns {Array} Returns the array of property names.
                                     * @example
                                     *
                                     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
                                     *
                                     * Foo.prototype.c = 3;
                                     *
                                     * _.keysIn(new Foo);
                                     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
                                     */
                                    function keysIn(object) {
                                        if (object == null) {
                                            return [];
                                        }
                                        if (!isObject(object)) {
                                            object = Object(object);
                                        }
                                        var length = object.length;
                                        length = (length && isLength(length) &&
                                            (isArray(object) || isArguments(object)) && length) || 0;

                                        var Ctor = object.constructor,
                                            index = -1,
                                            isProto = typeof Ctor == 'function' && Ctor.prototype === object,
                                            result = Array(length),
                                            skipIndexes = length > 0;

                                        while (++index < length) {
                                            result[index] = (index + '');
                                        }
                                        for (var key in object) {
                                            if (!(skipIndexes && isIndex(key, length)) &&
                                                !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
                                                result.push(key);
                                            }
                                        }
                                        return result;
                                    }

                                    /**
                                     * The opposite of `_.mapValues`; this method creates an object with the
                                     * same values as `object` and keys generated by running each own enumerable
                                     * property of `object` through `iteratee`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Object
                                     * @param {Object} object The object to iterate over.
                                     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
                                     *  per iteration.
                                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                                     * @returns {Object} Returns the new mapped object.
                                     * @example
                                     *
                                     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
                                     * // => { 'a1': 1, 'b2': 2 }
                                     */
                                    var mapKeys = createObjectMapper(true);

                                    /**
                                     * Creates an object with the same keys as `object` and values generated by
                                     * running each own enumerable property of `object` through `iteratee`. The
                                     * iteratee function is bound to `thisArg` and invoked with three arguments:
                                     * (value, key, object).
                                     *
                                     * If a property name is provided for `iteratee` the created `_.property`
                                     * style callback returns the property value of the given element.
                                     *
                                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                                     * style callback returns `true` for elements that have a matching property
                                     * value, else `false`.
                                     *
                                     * If an object is provided for `iteratee` the created `_.matches` style
                                     * callback returns `true` for elements that have the properties of the given
                                     * object, else `false`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Object
                                     * @param {Object} object The object to iterate over.
                                     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
                                     *  per iteration.
                                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                                     * @returns {Object} Returns the new mapped object.
                                     * @example
                                     *
                                     * _.mapValues({ 'a': 1, 'b': 2 }, function(n) {
     *   return n * 3;
     * });
                                     * // => { 'a': 3, 'b': 6 }
                                     *
                                     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
                                     *
                                     * // using the `_.property` callback shorthand
                                     * _.mapValues(users, 'age');
                                     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
                                     */
                                    var mapValues = createObjectMapper();

                                    /**
                                     * The opposite of `_.pick`; this method creates an object composed of the
                                     * own and inherited enumerable properties of `object` that are not omitted.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Object
                                     * @param {Object} object The source object.
                                     * @param {Function|...(string|string[])} [predicate] The function invoked per
                                     *  iteration or property names to omit, specified as individual property
                                     *  names or arrays of property names.
                                     * @param {*} [thisArg] The `this` binding of `predicate`.
                                     * @returns {Object} Returns the new object.
                                     * @example
                                     *
                                     * var object = { 'user': 'fred', 'age': 40 };
                                     *
                                     * _.omit(object, 'age');
                                     * // => { 'user': 'fred' }
                                     *
                                     * _.omit(object, _.isNumber);
                                     * // => { 'user': 'fred' }
                                     */
                                    var omit = restParam(function (object, props) {
                                        if (object == null) {
                                            return {};
                                        }
                                        if (typeof props[0] != 'function') {
                                            var props = arrayMap(baseFlatten(props), String);
                                            return pickByArray(object, baseDifference(keysIn(object), props));
                                        }
                                        var predicate = bindCallback(props[0], props[1], 3);
                                        return pickByCallback(object, function (value, key, object) {
                                            return !predicate(value, key, object);
                                        });
                                    });

                                    /**
                                     * Creates a two dimensional array of the key-value pairs for `object`,
                                     * e.g. `[[key1, value1], [key2, value2]]`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Object
                                     * @param {Object} object The object to query.
                                     * @returns {Array} Returns the new array of key-value pairs.
                                     * @example
                                     *
                                     * _.pairs({ 'barney': 36, 'fred': 40 });
                                     * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
                                     */
                                    function pairs(object) {
                                        object = toObject(object);

                                        var index = -1,
                                            props = keys(object),
                                            length = props.length,
                                            result = Array(length);

                                        while (++index < length) {
                                            var key = props[index];
                                            result[index] = [key, object[key]];
                                        }
                                        return result;
                                    }

                                    /**
                                     * Creates an object composed of the picked `object` properties. Property
                                     * names may be specified as individual arguments or as arrays of property
                                     * names. If `predicate` is provided it is invoked for each property of `object`
                                     * picking the properties `predicate` returns truthy for. The predicate is
                                     * bound to `thisArg` and invoked with three arguments: (value, key, object).
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Object
                                     * @param {Object} object The source object.
                                     * @param {Function|...(string|string[])} [predicate] The function invoked per
                                     *  iteration or property names to pick, specified as individual property
                                     *  names or arrays of property names.
                                     * @param {*} [thisArg] The `this` binding of `predicate`.
                                     * @returns {Object} Returns the new object.
                                     * @example
                                     *
                                     * var object = { 'user': 'fred', 'age': 40 };
                                     *
                                     * _.pick(object, 'user');
                                     * // => { 'user': 'fred' }
                                     *
                                     * _.pick(object, _.isString);
                                     * // => { 'user': 'fred' }
                                     */
                                    var pick = restParam(function (object, props) {
                                        if (object == null) {
                                            return {};
                                        }
                                        return typeof props[0] == 'function'
                                            ? pickByCallback(object, bindCallback(props[0], props[1], 3))
                                            : pickByArray(object, baseFlatten(props));
                                    });

                                    /**
                                     * This method is like `_.get` except that if the resolved value is a function
                                     * it is invoked with the `this` binding of its parent object and its result
                                     * is returned.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Object
                                     * @param {Object} object The object to query.
                                     * @param {Array|string} path The path of the property to resolve.
                                     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
                                     * @returns {*} Returns the resolved value.
                                     * @example
                                     *
                                     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
                                     *
                                     * _.result(object, 'a[0].b.c1');
                                     * // => 3
                                     *
                                     * _.result(object, 'a[0].b.c2');
                                     * // => 4
                                     *
                                     * _.result(object, 'a.b.c', 'default');
                                     * // => 'default'
                                     *
                                     * _.result(object, 'a.b.c', _.constant('default'));
                                     * // => 'default'
                                     */
                                    function result(object, path, defaultValue) {
                                        var result = object == null ? undefined : object[path];
                                        if (result === undefined) {
                                            if (object != null && !isKey(path, object)) {
                                                path = toPath(path);
                                                object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
                                                result = object == null ? undefined : object[last(path)];
                                            }
                                            result = result === undefined ? defaultValue : result;
                                        }
                                        return isFunction(result) ? result.call(object) : result;
                                    }

                                    /**
                                     * Sets the property value of `path` on `object`. If a portion of `path`
                                     * does not exist it is created.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Object
                                     * @param {Object} object The object to augment.
                                     * @param {Array|string} path The path of the property to set.
                                     * @param {*} value The value to set.
                                     * @returns {Object} Returns `object`.
                                     * @example
                                     *
                                     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
                                     *
                                     * _.set(object, 'a[0].b.c', 4);
                                     * console.log(object.a[0].b.c);
                                     * // => 4
                                     *
                                     * _.set(object, 'x[0].y.z', 5);
                                     * console.log(object.x[0].y.z);
                                     * // => 5
                                     */
                                    function set(object, path, value) {
                                        if (object == null) {
                                            return object;
                                        }
                                        var pathKey = (path + '');
                                        path = (object[pathKey] != null || isKey(path, object)) ? [pathKey] : toPath(path);

                                        var index = -1,
                                            length = path.length,
                                            lastIndex = length - 1,
                                            nested = object;

                                        while (nested != null && ++index < length) {
                                            var key = path[index];
                                            if (isObject(nested)) {
                                                if (index == lastIndex) {
                                                    nested[key] = value;
                                                } else if (nested[key] == null) {
                                                    nested[key] = isIndex(path[index + 1]) ? [] : {};
                                                }
                                            }
                                            nested = nested[key];
                                        }
                                        return object;
                                    }

                                    /**
                                     * An alternative to `_.reduce`; this method transforms `object` to a new
                                     * `accumulator` object which is the result of running each of its own enumerable
                                     * properties through `iteratee`, with each invocation potentially mutating
                                     * the `accumulator` object. The `iteratee` is bound to `thisArg` and invoked
                                     * with four arguments: (accumulator, value, key, object). Iteratee functions
                                     * may exit iteration early by explicitly returning `false`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Object
                                     * @param {Array|Object} object The object to iterate over.
                                     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                                     * @param {*} [accumulator] The custom accumulator value.
                                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                                     * @returns {*} Returns the accumulated value.
                                     * @example
                                     *
                                     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * });
                                     * // => [4, 9]
                                     *
                                     * _.transform({ 'a': 1, 'b': 2 }, function(result, n, key) {
     *   result[key] = n * 3;
     * });
                                     * // => { 'a': 3, 'b': 6 }
                                     */
                                    function transform(object, iteratee, accumulator, thisArg) {
                                        var isArr = isArray(object) || isTypedArray(object);
                                        iteratee = getCallback(iteratee, thisArg, 4);

                                        if (accumulator == null) {
                                            if (isArr || isObject(object)) {
                                                var Ctor = object.constructor;
                                                if (isArr) {
                                                    accumulator = isArray(object) ? new Ctor : [];
                                                } else {
                                                    accumulator = baseCreate(isFunction(Ctor) ? Ctor.prototype : undefined);
                                                }
                                            } else {
                                                accumulator = {};
                                            }
                                        }
                                        (isArr ? arrayEach : baseForOwn)(object, function (value, index, object) {
                                            return iteratee(accumulator, value, index, object);
                                        });
                                        return accumulator;
                                    }

                                    /**
                                     * Creates an array of the own enumerable property values of `object`.
                                     *
                                     * **Note:** Non-object values are coerced to objects.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Object
                                     * @param {Object} object The object to query.
                                     * @returns {Array} Returns the array of property values.
                                     * @example
                                     *
                                     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
                                     *
                                     * Foo.prototype.c = 3;
                                     *
                                     * _.values(new Foo);
                                     * // => [1, 2] (iteration order is not guaranteed)
                                     *
                                     * _.values('hi');
                                     * // => ['h', 'i']
                                     */
                                    function values(object) {
                                        return baseValues(object, keys(object));
                                    }

                                    /**
                                     * Creates an array of the own and inherited enumerable property values
                                     * of `object`.
                                     *
                                     * **Note:** Non-object values are coerced to objects.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Object
                                     * @param {Object} object The object to query.
                                     * @returns {Array} Returns the array of property values.
                                     * @example
                                     *
                                     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
                                     *
                                     * Foo.prototype.c = 3;
                                     *
                                     * _.valuesIn(new Foo);
                                     * // => [1, 2, 3] (iteration order is not guaranteed)
                                     */
                                    function valuesIn(object) {
                                        return baseValues(object, keysIn(object));
                                    }

                                    /*------------------------------------------------------------------------*/

                                    /**
                                     * Checks if `n` is between `start` and up to but not including, `end`. If
                                     * `end` is not specified it is set to `start` with `start` then set to `0`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Number
                                     * @param {number} n The number to check.
                                     * @param {number} [start=0] The start of the range.
                                     * @param {number} end The end of the range.
                                     * @returns {boolean} Returns `true` if `n` is in the range, else `false`.
                                     * @example
                                     *
                                     * _.inRange(3, 2, 4);
                                     * // => true
                                     *
                                     * _.inRange(4, 8);
                                     * // => true
                                     *
                                     * _.inRange(4, 2);
                                     * // => false
                                     *
                                     * _.inRange(2, 2);
                                     * // => false
                                     *
                                     * _.inRange(1.2, 2);
                                     * // => true
                                     *
                                     * _.inRange(5.2, 4);
                                     * // => false
                                     */
                                    function inRange(value, start, end) {
                                        start = +start || 0;
                                        if (end === undefined) {
                                            end = start;
                                            start = 0;
                                        } else {
                                            end = +end || 0;
                                        }
                                        return value >= nativeMin(start, end) && value < nativeMax(start, end);
                                    }

                                    /**
                                     * Produces a random number between `min` and `max` (inclusive). If only one
                                     * argument is provided a number between `0` and the given number is returned.
                                     * If `floating` is `true`, or either `min` or `max` are floats, a floating-point
                                     * number is returned instead of an integer.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Number
                                     * @param {number} [min=0] The minimum possible value.
                                     * @param {number} [max=1] The maximum possible value.
                                     * @param {boolean} [floating] Specify returning a floating-point number.
                                     * @returns {number} Returns the random number.
                                     * @example
                                     *
                                     * _.random(0, 5);
                                     * // => an integer between 0 and 5
                                     *
                                     * _.random(5);
                                     * // => also an integer between 0 and 5
                                     *
                                     * _.random(5, true);
                                     * // => a floating-point number between 0 and 5
                                     *
                                     * _.random(1.2, 5.2);
                                     * // => a floating-point number between 1.2 and 5.2
                                     */
                                    function random(min, max, floating) {
                                        if (floating && isIterateeCall(min, max, floating)) {
                                            max = floating = undefined;
                                        }
                                        var noMin = min == null,
                                            noMax = max == null;

                                        if (floating == null) {
                                            if (noMax && typeof min == 'boolean') {
                                                floating = min;
                                                min = 1;
                                            }
                                            else if (typeof max == 'boolean') {
                                                floating = max;
                                                noMax = true;
                                            }
                                        }
                                        if (noMin && noMax) {
                                            max = 1;
                                            noMax = false;
                                        }
                                        min = +min || 0;
                                        if (noMax) {
                                            max = min;
                                            min = 0;
                                        } else {
                                            max = +max || 0;
                                        }
                                        if (floating || min % 1 || max % 1) {
                                            var rand = nativeRandom();
                                            return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
                                        }
                                        return baseRandom(min, max);
                                    }

                                    /*------------------------------------------------------------------------*/

                                    /**
                                     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category String
                                     * @param {string} [string=''] The string to convert.
                                     * @returns {string} Returns the camel cased string.
                                     * @example
                                     *
                                     * _.camelCase('Foo Bar');
                                     * // => 'fooBar'
                                     *
                                     * _.camelCase('--foo-bar');
                                     * // => 'fooBar'
                                     *
                                     * _.camelCase('__foo_bar__');
                                     * // => 'fooBar'
                                     */
                                    var camelCase = createCompounder(function (result, word, index) {
                                        word = word.toLowerCase();
                                        return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);
                                    });

                                    /**
                                     * Capitalizes the first character of `string`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category String
                                     * @param {string} [string=''] The string to capitalize.
                                     * @returns {string} Returns the capitalized string.
                                     * @example
                                     *
                                     * _.capitalize('fred');
                                     * // => 'Fred'
                                     */
                                    function capitalize(string) {
                                        string = baseToString(string);
                                        return string && (string.charAt(0).toUpperCase() + string.slice(1));
                                    }

                                    /**
                                     * Deburrs `string` by converting [latin-1 supplementary letters](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
                                     * to basic latin letters and removing [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category String
                                     * @param {string} [string=''] The string to deburr.
                                     * @returns {string} Returns the deburred string.
                                     * @example
                                     *
                                     * _.deburr('dj vu');
                                     * // => 'deja vu'
                                     */
                                    function deburr(string) {
                                        string = baseToString(string);
                                        return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');
                                    }

                                    /**
                                     * Checks if `string` ends with the given target string.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category String
                                     * @param {string} [string=''] The string to search.
                                     * @param {string} [target] The string to search for.
                                     * @param {number} [position=string.length] The position to search from.
                                     * @returns {boolean} Returns `true` if `string` ends with `target`, else `false`.
                                     * @example
                                     *
                                     * _.endsWith('abc', 'c');
                                     * // => true
                                     *
                                     * _.endsWith('abc', 'b');
                                     * // => false
                                     *
                                     * _.endsWith('abc', 'b', 2);
                                     * // => true
                                     */
                                    function endsWith(string, target, position) {
                                        string = baseToString(string);
                                        target = (target + '');

                                        var length = string.length;
                                        position = position === undefined
                                            ? length
                                            : nativeMin(position < 0 ? 0 : (+position || 0), length);

                                        position -= target.length;
                                        return position >= 0 && string.indexOf(target, position) == position;
                                    }

                                    /**
                                     * Converts the characters "&", "<", ">", '"', "'", and "\`", in `string` to
                                     * their corresponding HTML entities.
                                     *
                                     * **Note:** No other characters are escaped. To escape additional characters
                                     * use a third-party library like [_he_](https://mths.be/he).
                                     *
                                     * Though the ">" character is escaped for symmetry, characters like
                                     * ">" and "/" don't need escaping in HTML and have no special meaning
                                     * unless they're part of a tag or unquoted attribute value.
                                     * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
                                     * (under "semi-related fun fact") for more details.
                                     *
                                     * Backticks are escaped because in Internet Explorer < 9, they can break out
                                     * of attribute values or HTML comments. See [#59](https://html5sec.org/#59),
                                     * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and
                                     * [#133](https://html5sec.org/#133) of the [HTML5 Security Cheatsheet](https://html5sec.org/)
                                     * for more details.
                                     *
                                     * When working with HTML you should always [quote attribute values](http://wonko.com/post/html-escaping)
                                     * to reduce XSS vectors.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category String
                                     * @param {string} [string=''] The string to escape.
                                     * @returns {string} Returns the escaped string.
                                     * @example
                                     *
                                     * _.escape('fred, barney, & pebbles');
                                     * // => 'fred, barney, &amp; pebbles'
                                     */
                                    function escape(string) {
                                        // Reset `lastIndex` because in IE < 9 `String#replace` does not.
                                        string = baseToString(string);
                                        return (string && reHasUnescapedHtml.test(string))
                                            ? string.replace(reUnescapedHtml, escapeHtmlChar)
                                            : string;
                                    }

                                    /**
                                     * Escapes the `RegExp` special characters "\", "/", "^", "$", ".", "|", "?",
                                     * "*", "+", "(", ")", "[", "]", "{" and "}" in `string`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category String
                                     * @param {string} [string=''] The string to escape.
                                     * @returns {string} Returns the escaped string.
                                     * @example
                                     *
                                     * _.escapeRegExp('[lodash](https://lodash.com/)');
                                     * // => '\[lodash\]\(https:\/\/lodash\.com\/\)'
                                     */
                                    function escapeRegExp(string) {
                                        string = baseToString(string);
                                        return (string && reHasRegExpChars.test(string))
                                            ? string.replace(reRegExpChars, escapeRegExpChar)
                                            : (string || '(?:)');
                                    }

                                    /**
                                     * Converts `string` to [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category String
                                     * @param {string} [string=''] The string to convert.
                                     * @returns {string} Returns the kebab cased string.
                                     * @example
                                     *
                                     * _.kebabCase('Foo Bar');
                                     * // => 'foo-bar'
                                     *
                                     * _.kebabCase('fooBar');
                                     * // => 'foo-bar'
                                     *
                                     * _.kebabCase('__foo_bar__');
                                     * // => 'foo-bar'
                                     */
                                    var kebabCase = createCompounder(function (result, word, index) {
                                        return result + (index ? '-' : '') + word.toLowerCase();
                                    });

                                    /**
                                     * Pads `string` on the left and right sides if it's shorter than `length`.
                                     * Padding characters are truncated if they can't be evenly divided by `length`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category String
                                     * @param {string} [string=''] The string to pad.
                                     * @param {number} [length=0] The padding length.
                                     * @param {string} [chars=' '] The string used as padding.
                                     * @returns {string} Returns the padded string.
                                     * @example
                                     *
                                     * _.pad('abc', 8);
                                     * // => '  abc   '
                                     *
                                     * _.pad('abc', 8, '_-');
                                     * // => '_-abc_-_'
                                     *
                                     * _.pad('abc', 3);
                                     * // => 'abc'
                                     */
                                    function pad(string, length, chars) {
                                        string = baseToString(string);
                                        length = +length;

                                        var strLength = string.length;
                                        if (strLength >= length || !nativeIsFinite(length)) {
                                            return string;
                                        }
                                        var mid = (length - strLength) / 2,
                                            leftLength = nativeFloor(mid),
                                            rightLength = nativeCeil(mid);

                                        chars = createPadding('', rightLength, chars);
                                        return chars.slice(0, leftLength) + string + chars;
                                    }

                                    /**
                                     * Pads `string` on the left side if it's shorter than `length`. Padding
                                     * characters are truncated if they exceed `length`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category String
                                     * @param {string} [string=''] The string to pad.
                                     * @param {number} [length=0] The padding length.
                                     * @param {string} [chars=' '] The string used as padding.
                                     * @returns {string} Returns the padded string.
                                     * @example
                                     *
                                     * _.padLeft('abc', 6);
                                     * // => '   abc'
                                     *
                                     * _.padLeft('abc', 6, '_-');
                                     * // => '_-_abc'
                                     *
                                     * _.padLeft('abc', 3);
                                     * // => 'abc'
                                     */
                                    var padLeft = createPadDir();

                                    /**
                                     * Pads `string` on the right side if it's shorter than `length`. Padding
                                     * characters are truncated if they exceed `length`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category String
                                     * @param {string} [string=''] The string to pad.
                                     * @param {number} [length=0] The padding length.
                                     * @param {string} [chars=' '] The string used as padding.
                                     * @returns {string} Returns the padded string.
                                     * @example
                                     *
                                     * _.padRight('abc', 6);
                                     * // => 'abc   '
                                     *
                                     * _.padRight('abc', 6, '_-');
                                     * // => 'abc_-_'
                                     *
                                     * _.padRight('abc', 3);
                                     * // => 'abc'
                                     */
                                    var padRight = createPadDir(true);

                                    /**
                                     * Converts `string` to an integer of the specified radix. If `radix` is
                                     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a hexadecimal,
                                     * in which case a `radix` of `16` is used.
                                     *
                                     * **Note:** This method aligns with the [ES5 implementation](https://es5.github.io/#E)
                                     * of `parseInt`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category String
                                     * @param {string} string The string to convert.
                                     * @param {number} [radix] The radix to interpret `value` by.
                                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                                     * @returns {number} Returns the converted integer.
                                     * @example
                                     *
                                     * _.parseInt('08');
                                     * // => 8
                                     *
                                     * _.map(['6', '08', '10'], _.parseInt);
                                     * // => [6, 8, 10]
                                     */
                                    function parseInt(string, radix, guard) {
                                        // Firefox < 21 and Opera < 15 follow ES3 for `parseInt`.
                                        // Chrome fails to trim leading <BOM> whitespace characters.
                                        // See https://code.google.com/p/v8/issues/detail?id=3109 for more details.
                                        if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
                                            radix = 0;
                                        } else if (radix) {
                                            radix = +radix;
                                        }
                                        string = trim(string);
                                        return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));
                                    }

                                    /**
                                     * Repeats the given string `n` times.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category String
                                     * @param {string} [string=''] The string to repeat.
                                     * @param {number} [n=0] The number of times to repeat the string.
                                     * @returns {string} Returns the repeated string.
                                     * @example
                                     *
                                     * _.repeat('*', 3);
                                     * // => '***'
                                     *
                                     * _.repeat('abc', 2);
                                     * // => 'abcabc'
                                     *
                                     * _.repeat('abc', 0);
                                     * // => ''
                                     */
                                    function repeat(string, n) {
                                        var result = '';
                                        string = baseToString(string);
                                        n = +n;
                                        if (n < 1 || !string || !nativeIsFinite(n)) {
                                            return result;
                                        }
                                        // Leverage the exponentiation by squaring algorithm for a faster repeat.
                                        // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
                                        do {
                                            if (n % 2) {
                                                result += string;
                                            }
                                            n = nativeFloor(n / 2);
                                            string += string;
                                        } while (n);

                                        return result;
                                    }

                                    /**
                                     * Converts `string` to [snake case](https://en.wikipedia.org/wiki/Snake_case).
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category String
                                     * @param {string} [string=''] The string to convert.
                                     * @returns {string} Returns the snake cased string.
                                     * @example
                                     *
                                     * _.snakeCase('Foo Bar');
                                     * // => 'foo_bar'
                                     *
                                     * _.snakeCase('fooBar');
                                     * // => 'foo_bar'
                                     *
                                     * _.snakeCase('--foo-bar');
                                     * // => 'foo_bar'
                                     */
                                    var snakeCase = createCompounder(function (result, word, index) {
                                        return result + (index ? '_' : '') + word.toLowerCase();
                                    });

                                    /**
                                     * Converts `string` to [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category String
                                     * @param {string} [string=''] The string to convert.
                                     * @returns {string} Returns the start cased string.
                                     * @example
                                     *
                                     * _.startCase('--foo-bar');
                                     * // => 'Foo Bar'
                                     *
                                     * _.startCase('fooBar');
                                     * // => 'Foo Bar'
                                     *
                                     * _.startCase('__foo_bar__');
                                     * // => 'Foo Bar'
                                     */
                                    var startCase = createCompounder(function (result, word, index) {
                                        return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));
                                    });

                                    /**
                                     * Checks if `string` starts with the given target string.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category String
                                     * @param {string} [string=''] The string to search.
                                     * @param {string} [target] The string to search for.
                                     * @param {number} [position=0] The position to search from.
                                     * @returns {boolean} Returns `true` if `string` starts with `target`, else `false`.
                                     * @example
                                     *
                                     * _.startsWith('abc', 'a');
                                     * // => true
                                     *
                                     * _.startsWith('abc', 'b');
                                     * // => false
                                     *
                                     * _.startsWith('abc', 'b', 1);
                                     * // => true
                                     */
                                    function startsWith(string, target, position) {
                                        string = baseToString(string);
                                        position = position == null
                                            ? 0
                                            : nativeMin(position < 0 ? 0 : (+position || 0), string.length);

                                        return string.lastIndexOf(target, position) == position;
                                    }

                                    /**
                                     * Creates a compiled template function that can interpolate data properties
                                     * in "interpolate" delimiters, HTML-escape interpolated data properties in
                                     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
                                     * properties may be accessed as free variables in the template. If a setting
                                     * object is provided it takes precedence over `_.templateSettings` values.
                                     *
                                     * **Note:** In the development build `_.template` utilizes
                                     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
                                     * for easier debugging.
                                     *
                                     * For more information on precompiling templates see
                                     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
                                     *
                                     * For more information on Chrome extension sandboxes see
                                     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category String
                                     * @param {string} [string=''] The template string.
                                     * @param {Object} [options] The options object.
                                     * @param {RegExp} [options.escape] The HTML "escape" delimiter.
                                     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
                                     * @param {Object} [options.imports] An object to import into the template as free variables.
                                     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
                                     * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.
                                     * @param {string} [options.variable] The data object variable name.
                                     * @param- {Object} [otherOptions] Enables the legacy `options` param signature.
                                     * @returns {Function} Returns the compiled template function.
                                     * @example
                                     *
                                     * // using the "interpolate" delimiter to create a compiled template
                                     * var compiled = _.template('hello <%= user %>!');
                                     * compiled({ 'user': 'fred' });
                                     * // => 'hello fred!'
                                     *
                                     * // using the HTML "escape" delimiter to escape data property values
                                     * var compiled = _.template('<b><%- value %></b>');
                                     * compiled({ 'value': '<script>' });
                                     * // => '<b>&lt;script&gt;</b>'
                                     *
                                     * // using the "evaluate" delimiter to execute JavaScript and generate HTML
                                     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
                                     * compiled({ 'users': ['fred', 'barney'] });
                                     * // => '<li>fred</li><li>barney</li>'
                                     *
                                     * // using the internal `print` function in "evaluate" delimiters
                                     * var compiled = _.template('<% print("hello " + user); %>!');
                                     * compiled({ 'user': 'barney' });
                                     * // => 'hello barney!'
                                     *
                                     * // using the ES delimiter as an alternative to the default "interpolate" delimiter
                                     * var compiled = _.template('hello ${ user }!');
                                     * compiled({ 'user': 'pebbles' });
                                     * // => 'hello pebbles!'
                                     *
                                     * // using custom template delimiters
                                     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
                                     * var compiled = _.template('hello {{ user }}!');
                                     * compiled({ 'user': 'mustache' });
                                     * // => 'hello mustache!'
                                     *
                                     * // using backslashes to treat delimiters as plain text
                                     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
                                     * compiled({ 'value': 'ignored' });
                                     * // => '<%- value %>'
                                     *
                                     * // using the `imports` option to import `jQuery` as `jq`
                                     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
                                     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
                                     * compiled({ 'users': ['fred', 'barney'] });
                                     * // => '<li>fred</li><li>barney</li>'
                                     *
                                     * // using the `sourceURL` option to specify a custom sourceURL for the template
                                     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
                                     * compiled(data);
                                     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
                                     *
                                     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
                                     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
                                     * compiled.source;
                                     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
                                     *
                                     * // using the `source` property to inline compiled templates for meaningful
                                     * // line numbers in error messages and a stack trace
                                     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
                                     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
                                     * ');
                                     */
                                    function template(string, options, otherOptions) {
                                        // Based on John Resig's `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)
                                        // and Laura Doktorova's doT.js (https://github.com/olado/doT).
                                        var settings = lodash.templateSettings;

                                        if (otherOptions && isIterateeCall(string, options, otherOptions)) {
                                            options = otherOptions = undefined;
                                        }
                                        string = baseToString(string);
                                        options = assignWith(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);

                                        var imports = assignWith(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),
                                            importsKeys = keys(imports),
                                            importsValues = baseValues(imports, importsKeys);

                                        var isEscaping,
                                            isEvaluating,
                                            index = 0,
                                            interpolate = options.interpolate || reNoMatch,
                                            source = "__p += '";

                                        // Compile the regexp to match each delimiter.
                                        var reDelimiters = RegExp(
                                            (options.escape || reNoMatch).source + '|' +
                                            interpolate.source + '|' +
                                            (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
                                            (options.evaluate || reNoMatch).source + '|$'
                                            , 'g');

                                        // Use a sourceURL for easier debugging.
                                        var sourceURL = '//# sourceURL=' +
                                            ('sourceURL' in options
                                                    ? options.sourceURL
                                                    : ('lodash.templateSources[' + (++templateCounter) + ']')
                                            ) + '\n';

                                        string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                                            interpolateValue || (interpolateValue = esTemplateValue);

                                            // Escape characters that can't be included in string literals.
                                            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

                                            // Replace delimiters with snippets.
                                            if (escapeValue) {
                                                isEscaping = true;
                                                source += "' +\n__e(" + escapeValue + ") +\n'";
                                            }
                                            if (evaluateValue) {
                                                isEvaluating = true;
                                                source += "';\n" + evaluateValue + ";\n__p += '";
                                            }
                                            if (interpolateValue) {
                                                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
                                            }
                                            index = offset + match.length;

                                            // The JS engine embedded in Adobe products requires returning the `match`
                                            // string in order to produce the correct `offset` value.
                                            return match;
                                        });

                                        source += "';\n";

                                        // If `variable` is not specified wrap a with-statement around the generated
                                        // code to add the data object to the top of the scope chain.
                                        var variable = options.variable;
                                        if (!variable) {
                                            source = 'with (obj) {\n' + source + '\n}\n';
                                        }
                                        // Cleanup code by stripping empty strings.
                                        source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
                                            .replace(reEmptyStringMiddle, '$1')
                                            .replace(reEmptyStringTrailing, '$1;');

                                        // Frame code as the function body.
                                        source = 'function(' + (variable || 'obj') + ') {\n' +
                                            (variable
                                                    ? ''
                                                    : 'obj || (obj = {});\n'
                                            ) +
                                            "var __t, __p = ''" +
                                            (isEscaping
                                                    ? ', __e = _.escape'
                                                    : ''
                                            ) +
                                            (isEvaluating
                                                    ? ', __j = Array.prototype.join;\n' +
                                                    "function print() { __p += __j.call(arguments, '') }\n"
                                                    : ';\n'
                                            ) +
                                            source +
                                            'return __p\n}';

                                        var result = attempt(function () {
                                            return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
                                        });

                                        // Provide the compiled function's source by its `toString` method or
                                        // the `source` property as a convenience for inlining compiled templates.
                                        result.source = source;
                                        if (isError(result)) {
                                            throw result;
                                        }
                                        return result;
                                    }

                                    /**
                                     * Removes leading and trailing whitespace or specified characters from `string`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category String
                                     * @param {string} [string=''] The string to trim.
                                     * @param {string} [chars=whitespace] The characters to trim.
                                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                                     * @returns {string} Returns the trimmed string.
                                     * @example
                                     *
                                     * _.trim('  abc  ');
                                     * // => 'abc'
                                     *
                                     * _.trim('-_-abc-_-', '_-');
                                     * // => 'abc'
                                     *
                                     * _.map(['  foo  ', '  bar  '], _.trim);
                                     * // => ['foo', 'bar']
                                     */
                                    function trim(string, chars, guard) {
                                        var value = string;
                                        string = baseToString(string);
                                        if (!string) {
                                            return string;
                                        }
                                        if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
                                            return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
                                        }
                                        chars = (chars + '');
                                        return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
                                    }

                                    /**
                                     * Removes leading whitespace or specified characters from `string`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category String
                                     * @param {string} [string=''] The string to trim.
                                     * @param {string} [chars=whitespace] The characters to trim.
                                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                                     * @returns {string} Returns the trimmed string.
                                     * @example
                                     *
                                     * _.trimLeft('  abc  ');
                                     * // => 'abc  '
                                     *
                                     * _.trimLeft('-_-abc-_-', '_-');
                                     * // => 'abc-_-'
                                     */
                                    function trimLeft(string, chars, guard) {
                                        var value = string;
                                        string = baseToString(string);
                                        if (!string) {
                                            return string;
                                        }
                                        if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
                                            return string.slice(trimmedLeftIndex(string));
                                        }
                                        return string.slice(charsLeftIndex(string, (chars + '')));
                                    }

                                    /**
                                     * Removes trailing whitespace or specified characters from `string`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category String
                                     * @param {string} [string=''] The string to trim.
                                     * @param {string} [chars=whitespace] The characters to trim.
                                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                                     * @returns {string} Returns the trimmed string.
                                     * @example
                                     *
                                     * _.trimRight('  abc  ');
                                     * // => '  abc'
                                     *
                                     * _.trimRight('-_-abc-_-', '_-');
                                     * // => '-_-abc'
                                     */
                                    function trimRight(string, chars, guard) {
                                        var value = string;
                                        string = baseToString(string);
                                        if (!string) {
                                            return string;
                                        }
                                        if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
                                            return string.slice(0, trimmedRightIndex(string) + 1);
                                        }
                                        return string.slice(0, charsRightIndex(string, (chars + '')) + 1);
                                    }

                                    /**
                                     * Truncates `string` if it's longer than the given maximum string length.
                                     * The last characters of the truncated string are replaced with the omission
                                     * string which defaults to "...".
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category String
                                     * @param {string} [string=''] The string to truncate.
                                     * @param {Object|number} [options] The options object or maximum string length.
                                     * @param {number} [options.length=30] The maximum string length.
                                     * @param {string} [options.omission='...'] The string to indicate text is omitted.
                                     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
                                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                                     * @returns {string} Returns the truncated string.
                                     * @example
                                     *
                                     * _.trunc('hi-diddly-ho there, neighborino');
                                     * // => 'hi-diddly-ho there, neighbo...'
                                     *
                                     * _.trunc('hi-diddly-ho there, neighborino', 24);
                                     * // => 'hi-diddly-ho there, n...'
                                     *
                                     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
                                     * // => 'hi-diddly-ho there,...'
                                     *
                                     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
                                     * // => 'hi-diddly-ho there...'
                                     *
                                     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
                                     * // => 'hi-diddly-ho there, neig [...]'
                                     */
                                    function trunc(string, options, guard) {
                                        if (guard && isIterateeCall(string, options, guard)) {
                                            options = undefined;
                                        }
                                        var length = DEFAULT_TRUNC_LENGTH,
                                            omission = DEFAULT_TRUNC_OMISSION;

                                        if (options != null) {
                                            if (isObject(options)) {
                                                var separator = 'separator' in options ? options.separator : separator;
                                                length = 'length' in options ? (+options.length || 0) : length;
                                                omission = 'omission' in options ? baseToString(options.omission) : omission;
                                            } else {
                                                length = +options || 0;
                                            }
                                        }
                                        string = baseToString(string);
                                        if (length >= string.length) {
                                            return string;
                                        }
                                        var end = length - omission.length;
                                        if (end < 1) {
                                            return omission;
                                        }
                                        var result = string.slice(0, end);
                                        if (separator == null) {
                                            return result + omission;
                                        }
                                        if (isRegExp(separator)) {
                                            if (string.slice(end).search(separator)) {
                                                var match,
                                                    newEnd,
                                                    substring = string.slice(0, end);

                                                if (!separator.global) {
                                                    separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');
                                                }
                                                separator.lastIndex = 0;
                                                while ((match = separator.exec(substring))) {
                                                    newEnd = match.index;
                                                }
                                                result = result.slice(0, newEnd == null ? end : newEnd);
                                            }
                                        } else if (string.indexOf(separator, end) != end) {
                                            var index = result.lastIndexOf(separator);
                                            if (index > -1) {
                                                result = result.slice(0, index);
                                            }
                                        }
                                        return result + omission;
                                    }

                                    /**
                                     * The inverse of `_.escape`; this method converts the HTML entities
                                     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to their
                                     * corresponding characters.
                                     *
                                     * **Note:** No other HTML entities are unescaped. To unescape additional HTML
                                     * entities use a third-party library like [_he_](https://mths.be/he).
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category String
                                     * @param {string} [string=''] The string to unescape.
                                     * @returns {string} Returns the unescaped string.
                                     * @example
                                     *
                                     * _.unescape('fred, barney, &amp; pebbles');
                                     * // => 'fred, barney, & pebbles'
                                     */
                                    function unescape(string) {
                                        string = baseToString(string);
                                        return (string && reHasEscapedHtml.test(string))
                                            ? string.replace(reEscapedHtml, unescapeHtmlChar)
                                            : string;
                                    }

                                    /**
                                     * Splits `string` into an array of its words.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category String
                                     * @param {string} [string=''] The string to inspect.
                                     * @param {RegExp|string} [pattern] The pattern to match words.
                                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                                     * @returns {Array} Returns the words of `string`.
                                     * @example
                                     *
                                     * _.words('fred, barney, & pebbles');
                                     * // => ['fred', 'barney', 'pebbles']
                                     *
                                     * _.words('fred, barney, & pebbles', /[^, ]+/g);
                                     * // => ['fred', 'barney', '&', 'pebbles']
                                     */
                                    function words(string, pattern, guard) {
                                        if (guard && isIterateeCall(string, pattern, guard)) {
                                            pattern = undefined;
                                        }
                                        string = baseToString(string);
                                        return string.match(pattern || reWords) || [];
                                    }

                                    /*------------------------------------------------------------------------*/

                                    /**
                                     * Attempts to invoke `func`, returning either the result or the caught error
                                     * object. Any additional arguments are provided to `func` when it is invoked.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Utility
                                     * @param {Function} func The function to attempt.
                                     * @returns {*} Returns the `func` result or error object.
                                     * @example
                                     *
                                     * // avoid throwing errors for invalid selectors
                                     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
                                     *
                                     * if (_.isError(elements)) {
     *   elements = [];
     * }
                                     */
                                    var attempt = restParam(function (func, args) {
                                        try {
                                            return func.apply(undefined, args);
                                        } catch (e) {
                                            return isError(e) ? e : new Error(e);
                                        }
                                    });

                                    /**
                                     * Creates a function that invokes `func` with the `this` binding of `thisArg`
                                     * and arguments of the created function. If `func` is a property name the
                                     * created callback returns the property value for a given element. If `func`
                                     * is an object the created callback returns `true` for elements that contain
                                     * the equivalent object properties, otherwise it returns `false`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @alias iteratee
                                     * @category Utility
                                     * @param {*} [func=_.identity] The value to convert to a callback.
                                     * @param {*} [thisArg] The `this` binding of `func`.
                                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                                     * @returns {Function} Returns the callback.
                                     * @example
                                     *
                                     * var users = [
                                     *   { 'user': 'barney', 'age': 36 },
                                     *   { 'user': 'fred',   'age': 40 }
                                     * ];
                                     *
                                     * // wrap to create custom callback shorthands
                                     * _.callback = _.wrap(_.callback, function(callback, func, thisArg) {
     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(func);
     *   if (!match) {
     *     return callback(func, thisArg);
     *   }
     *   return function(object) {
     *     return match[2] == 'gt'
     *       ? object[match[1]] > match[3]
     *       : object[match[1]] < match[3];
     *   };
     * });
                                     *
                                     * _.filter(users, 'age__gt36');
                                     * // => [{ 'user': 'fred', 'age': 40 }]
                                     */
                                    function callback(func, thisArg, guard) {
                                        if (guard && isIterateeCall(func, thisArg, guard)) {
                                            thisArg = undefined;
                                        }
                                        return isObjectLike(func)
                                            ? matches(func)
                                            : baseCallback(func, thisArg);
                                    }

                                    /**
                                     * Creates a function that returns `value`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Utility
                                     * @param {*} value The value to return from the new function.
                                     * @returns {Function} Returns the new function.
                                     * @example
                                     *
                                     * var object = { 'user': 'fred' };
                                     * var getter = _.constant(object);
                                     *
                                     * getter() === object;
                                     * // => true
                                     */
                                    function constant(value) {
                                        return function () {
                                            return value;
                                        };
                                    }

                                    /**
                                     * This method returns the first argument provided to it.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Utility
                                     * @param {*} value Any value.
                                     * @returns {*} Returns `value`.
                                     * @example
                                     *
                                     * var object = { 'user': 'fred' };
                                     *
                                     * _.identity(object) === object;
                                     * // => true
                                     */
                                    function identity(value) {
                                        return value;
                                    }

                                    /**
                                     * Creates a function that performs a deep comparison between a given object
                                     * and `source`, returning `true` if the given object has equivalent property
                                     * values, else `false`.
                                     *
                                     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
                                     * numbers, `Object` objects, regexes, and strings. Objects are compared by
                                     * their own, not inherited, enumerable properties. For comparing a single
                                     * own or inherited property value see `_.matchesProperty`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Utility
                                     * @param {Object} source The object of property values to match.
                                     * @returns {Function} Returns the new function.
                                     * @example
                                     *
                                     * var users = [
                                     *   { 'user': 'barney', 'age': 36, 'active': true },
                                     *   { 'user': 'fred',   'age': 40, 'active': false }
                                     * ];
                                     *
                                     * _.filter(users, _.matches({ 'age': 40, 'active': false }));
                                     * // => [{ 'user': 'fred', 'age': 40, 'active': false }]
                                     */
                                    function matches(source) {
                                        return baseMatches(baseClone(source, true));
                                    }

                                    /**
                                     * Creates a function that compares the property value of `path` on a given
                                     * object to `value`.
                                     *
                                     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
                                     * numbers, `Object` objects, regexes, and strings. Objects are compared by
                                     * their own, not inherited, enumerable properties.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Utility
                                     * @param {Array|string} path The path of the property to get.
                                     * @param {*} srcValue The value to match.
                                     * @returns {Function} Returns the new function.
                                     * @example
                                     *
                                     * var users = [
                                     *   { 'user': 'barney' },
                                     *   { 'user': 'fred' }
                                     * ];
                                     *
                                     * _.find(users, _.matchesProperty('user', 'fred'));
                                     * // => { 'user': 'fred' }
                                     */
                                    function matchesProperty(path, srcValue) {
                                        return baseMatchesProperty(path, baseClone(srcValue, true));
                                    }

                                    /**
                                     * Creates a function that invokes the method at `path` on a given object.
                                     * Any additional arguments are provided to the invoked method.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Utility
                                     * @param {Array|string} path The path of the method to invoke.
                                     * @param {...*} [args] The arguments to invoke the method with.
                                     * @returns {Function} Returns the new function.
                                     * @example
                                     *
                                     * var objects = [
                                     *   { 'a': { 'b': { 'c': _.constant(2) } } },
                                     *   { 'a': { 'b': { 'c': _.constant(1) } } }
                                     * ];
                                     *
                                     * _.map(objects, _.method('a.b.c'));
                                     * // => [2, 1]
                                     *
                                     * _.invoke(_.sortBy(objects, _.method(['a', 'b', 'c'])), 'a.b.c');
                                     * // => [1, 2]
                                     */
                                    var method = restParam(function (path, args) {
                                        return function (object) {
                                            return invokePath(object, path, args);
                                        };
                                    });

                                    /**
                                     * The opposite of `_.method`; this method creates a function that invokes
                                     * the method at a given path on `object`. Any additional arguments are
                                     * provided to the invoked method.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Utility
                                     * @param {Object} object The object to query.
                                     * @param {...*} [args] The arguments to invoke the method with.
                                     * @returns {Function} Returns the new function.
                                     * @example
                                     *
                                     * var array = _.times(3, _.constant),
                                     *     object = { 'a': array, 'b': array, 'c': array };
                                     *
                                     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
                                     * // => [2, 0]
                                     *
                                     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
                                     * // => [2, 0]
                                     */
                                    var methodOf = restParam(function (object, args) {
                                        return function (path) {
                                            return invokePath(object, path, args);
                                        };
                                    });

                                    /**
                                     * Adds all own enumerable function properties of a source object to the
                                     * destination object. If `object` is a function then methods are added to
                                     * its prototype as well.
                                     *
                                     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
                                     * avoid conflicts caused by modifying the original.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Utility
                                     * @param {Function|Object} [object=lodash] The destination object.
                                     * @param {Object} source The object of functions to add.
                                     * @param {Object} [options] The options object.
                                     * @param {boolean} [options.chain=true] Specify whether the functions added
                                     *  are chainable.
                                     * @returns {Function|Object} Returns `object`.
                                     * @example
                                     *
                                     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
                                     *
                                     * _.mixin({ 'vowels': vowels });
                                     * _.vowels('fred');
                                     * // => ['e']
                                     *
                                     * _('fred').vowels().value();
                                     * // => ['e']
                                     *
                                     * _.mixin({ 'vowels': vowels }, { 'chain': false });
                                     * _('fred').vowels();
                                     * // => ['e']
                                     */
                                    function mixin(object, source, options) {
                                        if (options == null) {
                                            var isObj = isObject(source),
                                                props = isObj ? keys(source) : undefined,
                                                methodNames = (props && props.length) ? baseFunctions(source, props) : undefined;

                                            if (!(methodNames ? methodNames.length : isObj)) {
                                                methodNames = false;
                                                options = source;
                                                source = object;
                                                object = this;
                                            }
                                        }
                                        if (!methodNames) {
                                            methodNames = baseFunctions(source, keys(source));
                                        }
                                        var chain = true,
                                            index = -1,
                                            isFunc = isFunction(object),
                                            length = methodNames.length;

                                        if (options === false) {
                                            chain = false;
                                        } else if (isObject(options) && 'chain' in options) {
                                            chain = options.chain;
                                        }
                                        while (++index < length) {
                                            var methodName = methodNames[index],
                                                func = source[methodName];

                                            object[methodName] = func;
                                            if (isFunc) {
                                                object.prototype[methodName] = (function (func) {
                                                    return function () {
                                                        var chainAll = this.__chain__;
                                                        if (chain || chainAll) {
                                                            var result = object(this.__wrapped__),
                                                                actions = result.__actions__ = arrayCopy(this.__actions__);

                                                            actions.push({
                                                                'func': func,
                                                                'args': arguments,
                                                                'thisArg': object
                                                            });
                                                            result.__chain__ = chainAll;
                                                            return result;
                                                        }
                                                        return func.apply(object, arrayPush([this.value()], arguments));
                                                    };
                                                }(func));
                                            }
                                        }
                                        return object;
                                    }

                                    /**
                                     * Reverts the `_` variable to its previous value and returns a reference to
                                     * the `lodash` function.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Utility
                                     * @returns {Function} Returns the `lodash` function.
                                     * @example
                                     *
                                     * var lodash = _.noConflict();
                                     */
                                    function noConflict() {
                                        root._ = oldDash;
                                        return this;
                                    }

                                    /**
                                     * A no-operation function that returns `undefined` regardless of the
                                     * arguments it receives.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Utility
                                     * @example
                                     *
                                     * var object = { 'user': 'fred' };
                                     *
                                     * _.noop(object) === undefined;
                                     * // => true
                                     */
                                    function noop() {
                                        // No operation performed.
                                    }

                                    /**
                                     * Creates a function that returns the property value at `path` on a
                                     * given object.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Utility
                                     * @param {Array|string} path The path of the property to get.
                                     * @returns {Function} Returns the new function.
                                     * @example
                                     *
                                     * var objects = [
                                     *   { 'a': { 'b': { 'c': 2 } } },
                                     *   { 'a': { 'b': { 'c': 1 } } }
                                     * ];
                                     *
                                     * _.map(objects, _.property('a.b.c'));
                                     * // => [2, 1]
                                     *
                                     * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');
                                     * // => [1, 2]
                                     */
                                    function property(path) {
                                        return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
                                    }

                                    /**
                                     * The opposite of `_.property`; this method creates a function that returns
                                     * the property value at a given path on `object`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Utility
                                     * @param {Object} object The object to query.
                                     * @returns {Function} Returns the new function.
                                     * @example
                                     *
                                     * var array = [0, 1, 2],
                                     *     object = { 'a': array, 'b': array, 'c': array };
                                     *
                                     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
                                     * // => [2, 0]
                                     *
                                     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
                                     * // => [2, 0]
                                     */
                                    function propertyOf(object) {
                                        return function (path) {
                                            return baseGet(object, toPath(path), path + '');
                                        };
                                    }

                                    /**
                                     * Creates an array of numbers (positive and/or negative) progressing from
                                     * `start` up to, but not including, `end`. If `end` is not specified it is
                                     * set to `start` with `start` then set to `0`. If `end` is less than `start`
                                     * a zero-length range is created unless a negative `step` is specified.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Utility
                                     * @param {number} [start=0] The start of the range.
                                     * @param {number} end The end of the range.
                                     * @param {number} [step=1] The value to increment or decrement by.
                                     * @returns {Array} Returns the new array of numbers.
                                     * @example
                                     *
                                     * _.range(4);
                                     * // => [0, 1, 2, 3]
                                     *
                                     * _.range(1, 5);
                                     * // => [1, 2, 3, 4]
                                     *
                                     * _.range(0, 20, 5);
                                     * // => [0, 5, 10, 15]
                                     *
                                     * _.range(0, -4, -1);
                                     * // => [0, -1, -2, -3]
                                     *
                                     * _.range(1, 4, 0);
                                     * // => [1, 1, 1]
                                     *
                                     * _.range(0);
                                     * // => []
                                     */
                                    function range(start, end, step) {
                                        if (step && isIterateeCall(start, end, step)) {
                                            end = step = undefined;
                                        }
                                        start = +start || 0;
                                        step = step == null ? 1 : (+step || 0);

                                        if (end == null) {
                                            end = start;
                                            start = 0;
                                        } else {
                                            end = +end || 0;
                                        }
                                        // Use `Array(length)` so engines like Chakra and V8 avoid slower modes.
                                        // See https://youtu.be/XAqIpGU8ZZk#t=17m25s for more details.
                                        var index = -1,
                                            length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
                                            result = Array(length);

                                        while (++index < length) {
                                            result[index] = start;
                                            start += step;
                                        }
                                        return result;
                                    }

                                    /**
                                     * Invokes the iteratee function `n` times, returning an array of the results
                                     * of each invocation. The `iteratee` is bound to `thisArg` and invoked with
                                     * one argument; (index).
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Utility
                                     * @param {number} n The number of times to invoke `iteratee`.
                                     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                                     * @returns {Array} Returns the array of results.
                                     * @example
                                     *
                                     * var diceRolls = _.times(3, _.partial(_.random, 1, 6, false));
                                     * // => [3, 6, 4]
                                     *
                                     * _.times(3, function(n) {
     *   mage.castSpell(n);
     * });
                                     * // => invokes `mage.castSpell(n)` three times with `n` of `0`, `1`, and `2`
                                     *
                                     * _.times(3, function(n) {
     *   this.cast(n);
     * }, mage);
                                     * // => also invokes `mage.castSpell(n)` three times
                                     */
                                    function times(n, iteratee, thisArg) {
                                        n = nativeFloor(n);

                                        // Exit early to avoid a JSC JIT bug in Safari 8
                                        // where `Array(0)` is treated as `Array(1)`.
                                        if (n < 1 || !nativeIsFinite(n)) {
                                            return [];
                                        }
                                        var index = -1,
                                            result = Array(nativeMin(n, MAX_ARRAY_LENGTH));

                                        iteratee = bindCallback(iteratee, thisArg, 1);
                                        while (++index < n) {
                                            if (index < MAX_ARRAY_LENGTH) {
                                                result[index] = iteratee(index);
                                            } else {
                                                iteratee(index);
                                            }
                                        }
                                        return result;
                                    }

                                    /**
                                     * Generates a unique ID. If `prefix` is provided the ID is appended to it.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Utility
                                     * @param {string} [prefix] The value to prefix the ID with.
                                     * @returns {string} Returns the unique ID.
                                     * @example
                                     *
                                     * _.uniqueId('contact_');
                                     * // => 'contact_104'
                                     *
                                     * _.uniqueId();
                                     * // => '105'
                                     */
                                    function uniqueId(prefix) {
                                        var id = ++idCounter;
                                        return baseToString(prefix) + id;
                                    }

                                    /*------------------------------------------------------------------------*/

                                    /**
                                     * Adds two numbers.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Math
                                     * @param {number} augend The first number to add.
                                     * @param {number} addend The second number to add.
                                     * @returns {number} Returns the sum.
                                     * @example
                                     *
                                     * _.add(6, 4);
                                     * // => 10
                                     */
                                    function add(augend, addend) {
                                        return (+augend || 0) + (+addend || 0);
                                    }

                                    /**
                                     * Calculates `n` rounded up to `precision`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Math
                                     * @param {number} n The number to round up.
                                     * @param {number} [precision=0] The precision to round up to.
                                     * @returns {number} Returns the rounded up number.
                                     * @example
                                     *
                                     * _.ceil(4.006);
                                     * // => 5
                                     *
                                     * _.ceil(6.004, 2);
                                     * // => 6.01
                                     *
                                     * _.ceil(6040, -2);
                                     * // => 6100
                                     */
                                    var ceil = createRound('ceil');

                                    /**
                                     * Calculates `n` rounded down to `precision`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Math
                                     * @param {number} n The number to round down.
                                     * @param {number} [precision=0] The precision to round down to.
                                     * @returns {number} Returns the rounded down number.
                                     * @example
                                     *
                                     * _.floor(4.006);
                                     * // => 4
                                     *
                                     * _.floor(0.046, 2);
                                     * // => 0.04
                                     *
                                     * _.floor(4060, -2);
                                     * // => 4000
                                     */
                                    var floor = createRound('floor');

                                    /**
                                     * Gets the maximum value of `collection`. If `collection` is empty or falsey
                                     * `-Infinity` is returned. If an iteratee function is provided it is invoked
                                     * for each value in `collection` to generate the criterion by which the value
                                     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
                                     * arguments: (value, index, collection).
                                     *
                                     * If a property name is provided for `iteratee` the created `_.property`
                                     * style callback returns the property value of the given element.
                                     *
                                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                                     * style callback returns `true` for elements that have a matching property
                                     * value, else `false`.
                                     *
                                     * If an object is provided for `iteratee` the created `_.matches` style
                                     * callback returns `true` for elements that have the properties of the given
                                     * object, else `false`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Math
                                     * @param {Array|Object|string} collection The collection to iterate over.
                                     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
                                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                                     * @returns {*} Returns the maximum value.
                                     * @example
                                     *
                                     * _.max([4, 2, 8, 6]);
                                     * // => 8
                                     *
                                     * _.max([]);
                                     * // => -Infinity
                                     *
                                     * var users = [
                                     *   { 'user': 'barney', 'age': 36 },
                                     *   { 'user': 'fred',   'age': 40 }
                                     * ];
                                     *
                                     * _.max(users, function(chr) {
     *   return chr.age;
     * });
                                     * // => { 'user': 'fred', 'age': 40 }
                                     *
                                     * // using the `_.property` callback shorthand
                                     * _.max(users, 'age');
                                     * // => { 'user': 'fred', 'age': 40 }
                                     */
                                    var max = createExtremum(gt, NEGATIVE_INFINITY);

                                    /**
                                     * Gets the minimum value of `collection`. If `collection` is empty or falsey
                                     * `Infinity` is returned. If an iteratee function is provided it is invoked
                                     * for each value in `collection` to generate the criterion by which the value
                                     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
                                     * arguments: (value, index, collection).
                                     *
                                     * If a property name is provided for `iteratee` the created `_.property`
                                     * style callback returns the property value of the given element.
                                     *
                                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                                     * style callback returns `true` for elements that have a matching property
                                     * value, else `false`.
                                     *
                                     * If an object is provided for `iteratee` the created `_.matches` style
                                     * callback returns `true` for elements that have the properties of the given
                                     * object, else `false`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Math
                                     * @param {Array|Object|string} collection The collection to iterate over.
                                     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
                                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                                     * @returns {*} Returns the minimum value.
                                     * @example
                                     *
                                     * _.min([4, 2, 8, 6]);
                                     * // => 2
                                     *
                                     * _.min([]);
                                     * // => Infinity
                                     *
                                     * var users = [
                                     *   { 'user': 'barney', 'age': 36 },
                                     *   { 'user': 'fred',   'age': 40 }
                                     * ];
                                     *
                                     * _.min(users, function(chr) {
     *   return chr.age;
     * });
                                     * // => { 'user': 'barney', 'age': 36 }
                                     *
                                     * // using the `_.property` callback shorthand
                                     * _.min(users, 'age');
                                     * // => { 'user': 'barney', 'age': 36 }
                                     */
                                    var min = createExtremum(lt, POSITIVE_INFINITY);

                                    /**
                                     * Calculates `n` rounded to `precision`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Math
                                     * @param {number} n The number to round.
                                     * @param {number} [precision=0] The precision to round to.
                                     * @returns {number} Returns the rounded number.
                                     * @example
                                     *
                                     * _.round(4.006);
                                     * // => 4
                                     *
                                     * _.round(4.006, 2);
                                     * // => 4.01
                                     *
                                     * _.round(4060, -2);
                                     * // => 4100
                                     */
                                    var round = createRound('round');

                                    /**
                                     * Gets the sum of the values in `collection`.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @category Math
                                     * @param {Array|Object|string} collection The collection to iterate over.
                                     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
                                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                                     * @returns {number} Returns the sum.
                                     * @example
                                     *
                                     * _.sum([4, 6]);
                                     * // => 10
                                     *
                                     * _.sum({ 'a': 4, 'b': 6 });
                                     * // => 10
                                     *
                                     * var objects = [
                                     *   { 'n': 4 },
                                     *   { 'n': 6 }
                                     * ];
                                     *
                                     * _.sum(objects, function(object) {
     *   return object.n;
     * });
                                     * // => 10
                                     *
                                     * // using the `_.property` callback shorthand
                                     * _.sum(objects, 'n');
                                     * // => 10
                                     */
                                    function sum(collection, iteratee, thisArg) {
                                        if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
                                            iteratee = undefined;
                                        }
                                        iteratee = getCallback(iteratee, thisArg, 3);
                                        return iteratee.length == 1
                                            ? arraySum(isArray(collection) ? collection : toIterable(collection), iteratee)
                                            : baseSum(collection, iteratee);
                                    }

                                    /*------------------------------------------------------------------------*/

                                    // Ensure wrappers are instances of `baseLodash`.
                                    lodash.prototype = baseLodash.prototype;

                                    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
                                    LodashWrapper.prototype.constructor = LodashWrapper;

                                    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
                                    LazyWrapper.prototype.constructor = LazyWrapper;

                                    // Add functions to the `Map` cache.
                                    MapCache.prototype['delete'] = mapDelete;
                                    MapCache.prototype.get = mapGet;
                                    MapCache.prototype.has = mapHas;
                                    MapCache.prototype.set = mapSet;

                                    // Add functions to the `Set` cache.
                                    SetCache.prototype.push = cachePush;

                                    // Assign cache to `_.memoize`.
                                    memoize.Cache = MapCache;

                                    // Add functions that return wrapped values when chaining.
                                    lodash.after = after;
                                    lodash.ary = ary;
                                    lodash.assign = assign;
                                    lodash.at = at;
                                    lodash.before = before;
                                    lodash.bind = bind;
                                    lodash.bindAll = bindAll;
                                    lodash.bindKey = bindKey;
                                    lodash.callback = callback;
                                    lodash.chain = chain;
                                    lodash.chunk = chunk;
                                    lodash.compact = compact;
                                    lodash.constant = constant;
                                    lodash.countBy = countBy;
                                    lodash.create = create;
                                    lodash.curry = curry;
                                    lodash.curryRight = curryRight;
                                    lodash.debounce = debounce;
                                    lodash.defaults = defaults;
                                    lodash.defaultsDeep = defaultsDeep;
                                    lodash.defer = defer;
                                    lodash.delay = delay;
                                    lodash.difference = difference;
                                    lodash.drop = drop;
                                    lodash.dropRight = dropRight;
                                    lodash.dropRightWhile = dropRightWhile;
                                    lodash.dropWhile = dropWhile;
                                    lodash.fill = fill;
                                    lodash.filter = filter;
                                    lodash.flatten = flatten;
                                    lodash.flattenDeep = flattenDeep;
                                    lodash.flow = flow;
                                    lodash.flowRight = flowRight;
                                    lodash.forEach = forEach;
                                    lodash.forEachRight = forEachRight;
                                    lodash.forIn = forIn;
                                    lodash.forInRight = forInRight;
                                    lodash.forOwn = forOwn;
                                    lodash.forOwnRight = forOwnRight;
                                    lodash.functions = functions;
                                    lodash.groupBy = groupBy;
                                    lodash.indexBy = indexBy;
                                    lodash.initial = initial;
                                    lodash.intersection = intersection;
                                    lodash.invert = invert;
                                    lodash.invoke = invoke;
                                    lodash.keys = keys;
                                    lodash.keysIn = keysIn;
                                    lodash.map = map;
                                    lodash.mapKeys = mapKeys;
                                    lodash.mapValues = mapValues;
                                    lodash.matches = matches;
                                    lodash.matchesProperty = matchesProperty;
                                    lodash.memoize = memoize;
                                    lodash.merge = merge;
                                    lodash.method = method;
                                    lodash.methodOf = methodOf;
                                    lodash.mixin = mixin;
                                    lodash.modArgs = modArgs;
                                    lodash.negate = negate;
                                    lodash.omit = omit;
                                    lodash.once = once;
                                    lodash.pairs = pairs;
                                    lodash.partial = partial;
                                    lodash.partialRight = partialRight;
                                    lodash.partition = partition;
                                    lodash.pick = pick;
                                    lodash.pluck = pluck;
                                    lodash.property = property;
                                    lodash.propertyOf = propertyOf;
                                    lodash.pull = pull;
                                    lodash.pullAt = pullAt;
                                    lodash.range = range;
                                    lodash.rearg = rearg;
                                    lodash.reject = reject;
                                    lodash.remove = remove;
                                    lodash.rest = rest;
                                    lodash.restParam = restParam;
                                    lodash.set = set;
                                    lodash.shuffle = shuffle;
                                    lodash.slice = slice;
                                    lodash.sortBy = sortBy;
                                    lodash.sortByAll = sortByAll;
                                    lodash.sortByOrder = sortByOrder;
                                    lodash.spread = spread;
                                    lodash.take = take;
                                    lodash.takeRight = takeRight;
                                    lodash.takeRightWhile = takeRightWhile;
                                    lodash.takeWhile = takeWhile;
                                    lodash.tap = tap;
                                    lodash.throttle = throttle;
                                    lodash.thru = thru;
                                    lodash.times = times;
                                    lodash.toArray = toArray;
                                    lodash.toPlainObject = toPlainObject;
                                    lodash.transform = transform;
                                    lodash.union = union;
                                    lodash.uniq = uniq;
                                    lodash.unzip = unzip;
                                    lodash.unzipWith = unzipWith;
                                    lodash.values = values;
                                    lodash.valuesIn = valuesIn;
                                    lodash.where = where;
                                    lodash.without = without;
                                    lodash.wrap = wrap;
                                    lodash.xor = xor;
                                    lodash.zip = zip;
                                    lodash.zipObject = zipObject;
                                    lodash.zipWith = zipWith;

                                    // Add aliases.
                                    lodash.backflow = flowRight;
                                    lodash.collect = map;
                                    lodash.compose = flowRight;
                                    lodash.each = forEach;
                                    lodash.eachRight = forEachRight;
                                    lodash.extend = assign;
                                    lodash.iteratee = callback;
                                    lodash.methods = functions;
                                    lodash.object = zipObject;
                                    lodash.select = filter;
                                    lodash.tail = rest;
                                    lodash.unique = uniq;

                                    // Add functions to `lodash.prototype`.
                                    mixin(lodash, lodash);

                                    /*------------------------------------------------------------------------*/

                                    // Add functions that return unwrapped values when chaining.
                                    lodash.add = add;
                                    lodash.attempt = attempt;
                                    lodash.camelCase = camelCase;
                                    lodash.capitalize = capitalize;
                                    lodash.ceil = ceil;
                                    lodash.clone = clone;
                                    lodash.cloneDeep = cloneDeep;
                                    lodash.deburr = deburr;
                                    lodash.endsWith = endsWith;
                                    lodash.escape = escape;
                                    lodash.escapeRegExp = escapeRegExp;
                                    lodash.every = every;
                                    lodash.find = find;
                                    lodash.findIndex = findIndex;
                                    lodash.findKey = findKey;
                                    lodash.findLast = findLast;
                                    lodash.findLastIndex = findLastIndex;
                                    lodash.findLastKey = findLastKey;
                                    lodash.findWhere = findWhere;
                                    lodash.first = first;
                                    lodash.floor = floor;
                                    lodash.get = get;
                                    lodash.gt = gt;
                                    lodash.gte = gte;
                                    lodash.has = has;
                                    lodash.identity = identity;
                                    lodash.includes = includes;
                                    lodash.indexOf = indexOf;
                                    lodash.inRange = inRange;
                                    lodash.isArguments = isArguments;
                                    lodash.isArray = isArray;
                                    lodash.isBoolean = isBoolean;
                                    lodash.isDate = isDate;
                                    lodash.isElement = isElement;
                                    lodash.isEmpty = isEmpty;
                                    lodash.isEqual = isEqual;
                                    lodash.isError = isError;
                                    lodash.isFinite = isFinite;
                                    lodash.isFunction = isFunction;
                                    lodash.isMatch = isMatch;
                                    lodash.isNaN = isNaN;
                                    lodash.isNative = isNative;
                                    lodash.isNull = isNull;
                                    lodash.isNumber = isNumber;
                                    lodash.isObject = isObject;
                                    lodash.isPlainObject = isPlainObject;
                                    lodash.isRegExp = isRegExp;
                                    lodash.isString = isString;
                                    lodash.isTypedArray = isTypedArray;
                                    lodash.isUndefined = isUndefined;
                                    lodash.kebabCase = kebabCase;
                                    lodash.last = last;
                                    lodash.lastIndexOf = lastIndexOf;
                                    lodash.lt = lt;
                                    lodash.lte = lte;
                                    lodash.max = max;
                                    lodash.min = min;
                                    lodash.noConflict = noConflict;
                                    lodash.noop = noop;
                                    lodash.now = now;
                                    lodash.pad = pad;
                                    lodash.padLeft = padLeft;
                                    lodash.padRight = padRight;
                                    lodash.parseInt = parseInt;
                                    lodash.random = random;
                                    lodash.reduce = reduce;
                                    lodash.reduceRight = reduceRight;
                                    lodash.repeat = repeat;
                                    lodash.result = result;
                                    lodash.round = round;
                                    lodash.runInContext = runInContext;
                                    lodash.size = size;
                                    lodash.snakeCase = snakeCase;
                                    lodash.some = some;
                                    lodash.sortedIndex = sortedIndex;
                                    lodash.sortedLastIndex = sortedLastIndex;
                                    lodash.startCase = startCase;
                                    lodash.startsWith = startsWith;
                                    lodash.sum = sum;
                                    lodash.template = template;
                                    lodash.trim = trim;
                                    lodash.trimLeft = trimLeft;
                                    lodash.trimRight = trimRight;
                                    lodash.trunc = trunc;
                                    lodash.unescape = unescape;
                                    lodash.uniqueId = uniqueId;
                                    lodash.words = words;

                                    // Add aliases.
                                    lodash.all = every;
                                    lodash.any = some;
                                    lodash.contains = includes;
                                    lodash.eq = isEqual;
                                    lodash.detect = find;
                                    lodash.foldl = reduce;
                                    lodash.foldr = reduceRight;
                                    lodash.head = first;
                                    lodash.include = includes;
                                    lodash.inject = reduce;

                                    mixin(lodash, (function () {
                                        var source = {};
                                        baseForOwn(lodash, function (func, methodName) {
                                            if (!lodash.prototype[methodName]) {
                                                source[methodName] = func;
                                            }
                                        });
                                        return source;
                                    }()), false);

                                    /*------------------------------------------------------------------------*/

                                    // Add functions capable of returning wrapped and unwrapped values when chaining.
                                    lodash.sample = sample;

                                    lodash.prototype.sample = function (n) {
                                        if (!this.__chain__ && n == null) {
                                            return sample(this.value());
                                        }
                                        return this.thru(function (value) {
                                            return sample(value, n);
                                        });
                                    };

                                    /*------------------------------------------------------------------------*/

                                    /**
                                     * The semantic version number.
                                     *
                                     * @static
                                     * @memberOf _
                                     * @type string
                                     */
                                    lodash.VERSION = VERSION;

                                    // Assign default placeholders.
                                    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function (methodName) {
                                        lodash[methodName].placeholder = lodash;
                                    });

                                    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
                                    arrayEach(['drop', 'take'], function (methodName, index) {
                                        LazyWrapper.prototype[methodName] = function (n) {
                                            var filtered = this.__filtered__;
                                            if (filtered && !index) {
                                                return new LazyWrapper(this);
                                            }
                                            n = n == null ? 1 : nativeMax(nativeFloor(n) || 0, 0);

                                            var result = this.clone();
                                            if (filtered) {
                                                result.__takeCount__ = nativeMin(result.__takeCount__, n);
                                            } else {
                                                result.__views__.push({
                                                    'size': n,
                                                    'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
                                                });
                                            }
                                            return result;
                                        };

                                        LazyWrapper.prototype[methodName + 'Right'] = function (n) {
                                            return this.reverse()[methodName](n).reverse();
                                        };
                                    });

                                    // Add `LazyWrapper` methods that accept an `iteratee` value.
                                    arrayEach(['filter', 'map', 'takeWhile'], function (methodName, index) {
                                        var type = index + 1,
                                            isFilter = type != LAZY_MAP_FLAG;

                                        LazyWrapper.prototype[methodName] = function (iteratee, thisArg) {
                                            var result = this.clone();
                                            result.__iteratees__.push({
                                                'iteratee': getCallback(iteratee, thisArg, 1),
                                                'type': type
                                            });
                                            result.__filtered__ = result.__filtered__ || isFilter;
                                            return result;
                                        };
                                    });

                                    // Add `LazyWrapper` methods for `_.first` and `_.last`.
                                    arrayEach(['first', 'last'], function (methodName, index) {
                                        var takeName = 'take' + (index ? 'Right' : '');

                                        LazyWrapper.prototype[methodName] = function () {
                                            return this[takeName](1).value()[0];
                                        };
                                    });

                                    // Add `LazyWrapper` methods for `_.initial` and `_.rest`.
                                    arrayEach(['initial', 'rest'], function (methodName, index) {
                                        var dropName = 'drop' + (index ? '' : 'Right');

                                        LazyWrapper.prototype[methodName] = function () {
                                            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
                                        };
                                    });

                                    // Add `LazyWrapper` methods for `_.pluck` and `_.where`.
                                    arrayEach(['pluck', 'where'], function (methodName, index) {
                                        var operationName = index ? 'filter' : 'map',
                                            createCallback = index ? baseMatches : property;

                                        LazyWrapper.prototype[methodName] = function (value) {
                                            return this[operationName](createCallback(value));
                                        };
                                    });

                                    LazyWrapper.prototype.compact = function () {
                                        return this.filter(identity);
                                    };

                                    LazyWrapper.prototype.reject = function (predicate, thisArg) {
                                        predicate = getCallback(predicate, thisArg, 1);
                                        return this.filter(function (value) {
                                            return !predicate(value);
                                        });
                                    };

                                    LazyWrapper.prototype.slice = function (start, end) {
                                        start = start == null ? 0 : (+start || 0);

                                        var result = this;
                                        if (result.__filtered__ && (start > 0 || end < 0)) {
                                            return new LazyWrapper(result);
                                        }
                                        if (start < 0) {
                                            result = result.takeRight(-start);
                                        } else if (start) {
                                            result = result.drop(start);
                                        }
                                        if (end !== undefined) {
                                            end = (+end || 0);
                                            result = end < 0 ? result.dropRight(-end) : result.take(end - start);
                                        }
                                        return result;
                                    };

                                    LazyWrapper.prototype.takeRightWhile = function (predicate, thisArg) {
                                        return this.reverse().takeWhile(predicate, thisArg).reverse();
                                    };

                                    LazyWrapper.prototype.toArray = function () {
                                        return this.take(POSITIVE_INFINITY);
                                    };

                                    // Add `LazyWrapper` methods to `lodash.prototype`.
                                    baseForOwn(LazyWrapper.prototype, function (func, methodName) {
                                        var checkIteratee = /^(?:filter|map|reject)|While$/.test(methodName),
                                            retUnwrapped = /^(?:first|last)$/.test(methodName),
                                            lodashFunc = lodash[retUnwrapped ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName];

                                        if (!lodashFunc) {
                                            return;
                                        }
                                        lodash.prototype[methodName] = function () {
                                            var args = retUnwrapped ? [1] : arguments,
                                                chainAll = this.__chain__,
                                                value = this.__wrapped__,
                                                isHybrid = !!this.__actions__.length,
                                                isLazy = value instanceof LazyWrapper,
                                                iteratee = args[0],
                                                useLazy = isLazy || isArray(value);

                                            if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
                                                // Avoid lazy use if the iteratee has a "length" value other than `1`.
                                                isLazy = useLazy = false;
                                            }
                                            var interceptor = function (value) {
                                                return (retUnwrapped && chainAll)
                                                    ? lodashFunc(value, 1)[0]
                                                    : lodashFunc.apply(undefined, arrayPush([value], args));
                                            };

                                            var action = {'func': thru, 'args': [interceptor], 'thisArg': undefined},
                                                onlyLazy = isLazy && !isHybrid;

                                            if (retUnwrapped && !chainAll) {
                                                if (onlyLazy) {
                                                    value = value.clone();
                                                    value.__actions__.push(action);
                                                    return func.call(value);
                                                }
                                                return lodashFunc.call(undefined, this.value())[0];
                                            }
                                            if (!retUnwrapped && useLazy) {
                                                value = onlyLazy ? value : new LazyWrapper(this);
                                                var result = func.apply(value, args);
                                                result.__actions__.push(action);
                                                return new LodashWrapper(result, chainAll);
                                            }
                                            return this.thru(interceptor);
                                        };
                                    });

                                    // Add `Array` and `String` methods to `lodash.prototype`.
                                    arrayEach(['join', 'pop', 'push', 'replace', 'shift', 'sort', 'splice', 'split', 'unshift'], function (methodName) {
                                        var func = (/^(?:replace|split)$/.test(methodName) ? stringProto : arrayProto)[methodName],
                                            chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
                                            retUnwrapped = /^(?:join|pop|replace|shift)$/.test(methodName);

                                        lodash.prototype[methodName] = function () {
                                            var args = arguments;
                                            if (retUnwrapped && !this.__chain__) {
                                                return func.apply(this.value(), args);
                                            }
                                            return this[chainName](function (value) {
                                                return func.apply(value, args);
                                            });
                                        };
                                    });

                                    // Map minified function names to their real names.
                                    baseForOwn(LazyWrapper.prototype, function (func, methodName) {
                                        var lodashFunc = lodash[methodName];
                                        if (lodashFunc) {
                                            var key = lodashFunc.name,
                                                names = realNames[key] || (realNames[key] = []);

                                            names.push({'name': methodName, 'func': lodashFunc});
                                        }
                                    });

                                    realNames[createHybridWrapper(undefined, BIND_KEY_FLAG).name] = [{
                                        'name': 'wrapper',
                                        'func': undefined
                                    }];

                                    // Add functions to the lazy wrapper.
                                    LazyWrapper.prototype.clone = lazyClone;
                                    LazyWrapper.prototype.reverse = lazyReverse;
                                    LazyWrapper.prototype.value = lazyValue;

                                    // Add chaining functions to the `lodash` wrapper.
                                    lodash.prototype.chain = wrapperChain;
                                    lodash.prototype.commit = wrapperCommit;
                                    lodash.prototype.concat = wrapperConcat;
                                    lodash.prototype.plant = wrapperPlant;
                                    lodash.prototype.reverse = wrapperReverse;
                                    lodash.prototype.toString = wrapperToString;
                                    lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

                                    // Add function aliases to the `lodash` wrapper.
                                    lodash.prototype.collect = lodash.prototype.map;
                                    lodash.prototype.head = lodash.prototype.first;
                                    lodash.prototype.select = lodash.prototype.filter;
                                    lodash.prototype.tail = lodash.prototype.rest;

                                    return lodash;
                                }

                                /*--------------------------------------------------------------------------*/

                                // Export lodash.
                                var _ = runInContext();

                                // Some AMD build optimizers like r.js check for condition patterns like the following:
                                if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
                                    // Expose lodash to the global object when an AMD loader is present to avoid
                                    // errors in cases where lodash is loaded by a script tag and not intended
                                    // as an AMD module. See http://requirejs.org/docs/errors.html#mismatch for
                                    // more details.
                                    root._ = _;

                                    // Define as an anonymous module so, through path mapping, it can be
                                    // referenced as the "underscore" module.
                                    define(function () {
                                        return _;
                                    });
                                }
                                // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
                                else if (freeExports && freeModule) {
                                    // Export for Node.js or RingoJS.
                                    if (moduleExports) {
                                        (freeModule.exports = _)._ = _;
                                    }
                                    // Export for Rhino with CommonJS support.
                                    else {
                                        freeExports._ = _;
                                    }
                                }
                                else {
                                    // Export for a browser or Rhino.
                                    root._ = _;
                                }
                            }.call(this));

                        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
                    }, {}],
                    7: [function (_dereq_, module, exports) {
                        var Vue // late bind
                        var map = Object.create(null)
                        var shimmed = false
                        var isBrowserify = false

                        /**
                         * Determine compatibility and apply patch.
                         *
                         * @param {Function} vue
                         * @param {Boolean} browserify
                         */

                        exports.install = function (vue, browserify) {
                            if (shimmed) return
                            shimmed = true

                            Vue = vue
                            isBrowserify = browserify

                            exports.compatible = !!Vue.internalDirectives
                            if (!exports.compatible) {
                                console.warn(
                                    '[HMR] vue-loader hot reload is only compatible with ' +
                                    'Vue.js 1.0.0+.'
                                )
                                return
                            }

                            // patch view directive
                            patchView(Vue.internalDirectives.component)
                            console.log('[HMR] Vue component hot reload shim applied.')
                            // shim router-view if present
                            var routerView = Vue.elementDirective('router-view')
                            if (routerView) {
                                patchView(routerView)
                                console.log('[HMR] vue-router <router-view> hot reload shim applied.')
                            }
                        }

                        /**
                         * Shim the view directive (component or router-view).
                         *
                         * @param {Object} View
                         */

                        function patchView(View) {
                            var unbuild = View.unbuild
                            View.unbuild = function (defer) {
                                if (!this.hotUpdating) {
                                    var prevComponent = this.childVM && this.childVM.constructor
                                    removeView(prevComponent, this)
                                    // defer = true means we are transitioning to a new
                                    // Component. Register this new component to the list.
                                    if (defer) {
                                        addView(this.Component, this)
                                    }
                                }
                                // call original
                                return unbuild.call(this, defer)
                            }
                        }

                        /**
                         * Add a component view to a Component's hot list
                         *
                         * @param {Function} Component
                         * @param {Directive} view - view directive instance
                         */

                        function addView(Component, view) {
                            var id = Component && Component.options.hotID
                            if (id) {
                                if (!map[id]) {
                                    map[id] = {
                                        Component: Component,
                                        views: [],
                                        instances: []
                                    }
                                }
                                map[id].views.push(view)
                            }
                        }

                        /**
                         * Remove a component view from a Component's hot list
                         *
                         * @param {Function} Component
                         * @param {Directive} view - view directive instance
                         */

                        function removeView(Component, view) {
                            var id = Component && Component.options.hotID
                            if (id) {
                                map[id].views.$remove(view)
                            }
                        }

                        /**
                         * Create a record for a hot module, which keeps track of its construcotr,
                         * instnaces and views (component directives or router-views).
                         *
                         * @param {String} id
                         * @param {Object} options
                         */

                        exports.createRecord = function (id, options) {
                            if (typeof options === 'function') {
                                options = options.options
                            }
                            if (typeof options.el !== 'string' && typeof options.data !== 'object') {
                                makeOptionsHot(id, options)
                                map[id] = {
                                    Component: null,
                                    views: [],
                                    instances: []
                                }
                            }
                        }

                        /**
                         * Make a Component options object hot.
                         *
                         * @param {String} id
                         * @param {Object} options
                         */

                        function makeOptionsHot(id, options) {
                            options.hotID = id
                            injectHook(options, 'created', function () {
                                var record = map[id]
                                if (!record.Component) {
                                    record.Component = this.constructor
                                }
                                record.instances.push(this)
                            })
                            injectHook(options, 'beforeDestroy', function () {
                                map[id].instances.$remove(this)
                            })
                        }

                        /**
                         * Inject a hook to a hot reloadable component so that
                         * we can keep track of it.
                         *
                         * @param {Object} options
                         * @param {String} name
                         * @param {Function} hook
                         */

                        function injectHook(options, name, hook) {
                            var existing = options[name]
                            options[name] = existing
                                ? Array.isArray(existing)
                                    ? existing.concat(hook)
                                    : [existing, hook]
                                : [hook]
                        }

                        /**
                         * Update a hot component.
                         *
                         * @param {String} id
                         * @param {Object|null} newOptions
                         * @param {String|null} newTemplate
                         */

                        exports.update = function (id, newOptions, newTemplate) {
                            var record = map[id]
                            // force full-reload if an instance of the component is active but is not
                            // managed by a view
                            if (!record || (record.instances.length && !record.views.length)) {
                                console.log('[HMR] Root or manually-mounted instance modified. Full reload may be required.')
                                if (!isBrowserify) {
                                    window.location.reload()
                                } else {
                                    // browserify-hmr somehow sends incomplete bundle if we reload here
                                    return
                                }
                            }
                            if (!isBrowserify) {
                                // browserify-hmr already logs this
                                console.log('[HMR] Updating component: ' + format(id))
                            }
                            var Component = record.Component
                            // update constructor
                            if (newOptions) {
                                // in case the user exports a constructor
                                Component = record.Component = typeof newOptions === 'function'
                                    ? newOptions
                                    : Vue.extend(newOptions)
                                makeOptionsHot(id, Component.options)
                            }
                            if (newTemplate) {
                                Component.options.template = newTemplate
                            }
                            // handle recursive lookup
                            if (Component.options.name) {
                                Component.options.components[Component.options.name] = Component
                            }
                            // reset constructor cached linker
                            Component.linker = null
                            // reload all views
                            record.views.forEach(function (view) {
                                updateView(view, Component)
                            })
                            // flush devtools
                            if (window.__VUE_DEVTOOLS_GLOBAL_HOOK__) {
                                window.__VUE_DEVTOOLS_GLOBAL_HOOK__.emit('flush')
                            }
                        }

                        /**
                         * Update a component view instance
                         *
                         * @param {Directive} view
                         * @param {Function} Component
                         */

                        function updateView(view, Component) {
                            if (!view._bound) {
                                return
                            }
                            view.Component = Component
                            view.hotUpdating = true
                            // disable transitions
                            view.vm._isCompiled = false
                            // save state
                            var state = extractState(view.childVM)
                            // remount, make sure to disable keep-alive
                            var keepAlive = view.keepAlive
                            view.keepAlive = false
                            view.mountComponent()
                            view.keepAlive = keepAlive
                            // restore state
                            restoreState(view.childVM, state, true)
                            // re-eanble transitions
                            view.vm._isCompiled = true
                            view.hotUpdating = false
                        }

                        /**
                         * Extract state from a Vue instance.
                         *
                         * @param {Vue} vm
                         * @return {Object}
                         */

                        function extractState(vm) {
                            return {
                                cid: vm.constructor.cid,
                                data: vm.$data,
                                children: vm.$children.map(extractState)
                            }
                        }

                        /**
                         * Restore state to a reloaded Vue instance.
                         *
                         * @param {Vue} vm
                         * @param {Object} state
                         */

                        function restoreState(vm, state, isRoot) {
                            var oldAsyncConfig
                            if (isRoot) {
                                // set Vue into sync mode during state rehydration
                                oldAsyncConfig = Vue.config.async
                                Vue.config.async = false
                            }
                            // actual restore
                            if (isRoot || !vm._props) {
                                vm.$data = state.data
                            } else {
                                Object.keys(state.data).forEach(function (key) {
                                    if (!vm._props[key]) {
                                        // for non-root, only restore non-props fields
                                        vm.$data[key] = state.data[key]
                                    }
                                })
                            }
                            // verify child consistency
                            var hasSameChildren = vm.$children.every(function (c, i) {
                                return state.children[i] && state.children[i].cid === c.constructor.cid
                            })
                            if (hasSameChildren) {
                                // rehydrate children
                                vm.$children.forEach(function (c, i) {
                                    restoreState(c, state.children[i])
                                })
                            }
                            if (isRoot) {
                                Vue.config.async = oldAsyncConfig
                            }
                        }

                        function format(id) {
                            return id.match(/[^\/]+\.vue$/)[0]
                        }

                    }, {}],
                    8: [function (_dereq_, module, exports) {
                        var inserted = exports.cache = {}

                        exports.insert = function (css) {
                            if (inserted[css]) return
                            inserted[css] = true

                            var elem = document.createElement('style')
                            elem.setAttribute('type', 'text/css')

                            if ('textContent' in elem) {
                                elem.textContent = css
                            } else {
                                elem.styleSheet.cssText = css
                            }

                            document.getElementsByTagName('head')[0].appendChild(elem)
                            return elem
                        }

                    }, {}],
                    9: [function (_dereq_, module, exports) {
                        'use strict';

                        Object.defineProperty(exports, "__esModule", {
                            value: true
                        });
                        exports.default = {
                            props: {
                                type: {
                                    type: String,
                                    required: true
                                },
                                dismissible: {
                                    type: Boolean,
                                    default: true
                                },
                                animation: {
                                    type: Boolean,
                                    default: true
                                },
                                timeout: {
                                    type: Number,
                                    default: -1
                                },
                                onClosed: {
                                    type: Function,
                                    default: function _default() {
                                    }
                                }
                            },
                            methods: {
                                dismiss: function dismiss() {
                                    $(this.$el).alert('close');
                                }
                            },
                            ready: function ready() {
                                var _this = this;

                                if (this.timeout >= 0) {
                                    setTimeout(function () {
                                        _this.dismiss();
                                    }, this.timeout);
                                } // end if

                                $(this.$el).on('closed.bs.alert', function () {
                                    _this.onClosed();
                                });
                            }
                        };
                        if (module.exports.__esModule) module.exports = module.exports.default
                        ;
                        (typeof module.exports === "function" ? module.exports.options : module.exports).template = "\n    <div class=\"alert\" :class=\"'alert-' + type\" role=\"alert\">\n        <button v-if=\"dismissible\" type=\"button\" class=\"close\" data-dismiss=\"alert\" aria-label=\"Close\">\n            <span aria-hidden=\"true\"></span>\n            <span class=\"sr-only\">Close</span>\n        </button>\n        <slot></slot>\n    </div>\n"
                        if (module.hot) {
                            (function () {
                                module.hot.accept()
                                var hotAPI = _dereq_("vue-hot-reload-api")
                                hotAPI.install(_dereq_("vue"), true)
                                if (!hotAPI.compatible) return
                                var id = "/Users/morgul/Development/vueboot/src/alert/alert.vue"
                                if (!module.hot.data) {
                                    hotAPI.createRecord(id, module.exports)
                                } else {
                                    hotAPI.update(id, module.exports, (typeof module.exports === "function" ? module.exports.options : module.exports).template)
                                }
                            })()
                        }
                    }, {"vue": "vue", "vue-hot-reload-api": 7}],
                    10: [function (_dereq_, module, exports) {
                        'use strict';

                        Object.defineProperty(exports, "__esModule", {
                            value: true
                        });
                        exports.default = {
                            inherit: true,
                            props: {
                                show: {
                                    type: Boolean,
                                    default: false,
                                    twoWay: true
                                },
                                animation: {
                                    type: Boolean,
                                    default: true
                                },
                                width: {
                                    type: String
                                },
                                backdrop: {
                                    default: true
                                },
                                keyboard: {
                                    type: Boolean,
                                    default: true
                                },
                                autoFocus: {
                                    type: String
                                },
                                modalClass: {
                                    type: String
                                },
                                onClosed: {
                                    type: Function,
                                    default: function _default() {
                                    }
                                }
                            },
                            methods: {
                                showModal: function showModal() {
                                    this.show = true;
                                    $(this.$el).modal('show');
                                },
                                hideModal: function hideModal() {
                                    this.show = false;
                                    $(this.$el).modal('hide');
                                },
                                refresh: function refresh() {
                                    $(this.$el).data('bs.modal').handleUpdate();
                                }
                            },
                            watch: {
                                show: function show() {
                                    if (this.show) {
                                        this.showModal();
                                    } else {
                                        this.hideModal();
                                    } // end if
                                }
                            },
                            ready: function ready() {
                                var _this = this;

                                $(this.$el).on('shown.bs.modal', function () {
                                    if (_this.autoFocus) {
                                        var autoElem = $(_this.autoFocus);
                                        if (autoElem[0]) {
                                            autoElem.focus();
                                        } else {
                                            console.warn('[VueBoot] Autofocus selector \'' + _this.autoFocus + '\' did not select an element.');
                                        } // end if
                                    } // end if
                                });

                                $(this.$el).on('hidden.bs.modal', function (event) {
                                    _this.show = false;
                                    _this.onClosed();
                                });
                            }
                        };
                        if (module.exports.__esModule) module.exports = module.exports.default
                        ;
                        (typeof module.exports === "function" ? module.exports.options : module.exports).template = "\n    <div class=\"modal\" :class=\"{ fade: animation }\" tabindex=\"-1\" role=\"dialog\" aria-hidden=\"true\" :data-backdrop=\"backdrop.toString()\" :data-keyboard=\"keyboard.toString()\">\n        <div class=\"modal-dialog\" :class=\"modalClass\" role=\"document\" :style=\"{ 'max-width': width, width: width }\">\n            <div class=\"modal-content\">\n                <slot name=\"header\"></slot>\n                <slot name=\"body\"></slot>\n                <slot name=\"footer\"></slot>\n            </div>\n        </div>\n    </div>\n"
                        if (module.hot) {
                            (function () {
                                module.hot.accept()
                                var hotAPI = _dereq_("vue-hot-reload-api")
                                hotAPI.install(_dereq_("vue"), true)
                                if (!hotAPI.compatible) return
                                var id = "/Users/morgul/Development/vueboot/src/modal/modal.vue"
                                if (!module.hot.data) {
                                    hotAPI.createRecord(id, module.exports)
                                } else {
                                    hotAPI.update(id, module.exports, (typeof module.exports === "function" ? module.exports.options : module.exports).template)
                                }
                            })()
                        }
                    }, {"vue": "vue", "vue-hot-reload-api": 7}],
                    11: [function (_dereq_, module, exports) {
                        'use strict';

                        Object.defineProperty(exports, "__esModule", {
                            value: true
                        });
                        exports.default = {
                            props: {
                                header: {
                                    type: String
                                },
                                disabled: {
                                    type: Boolean,
                                    default: false
                                },
                                onSelected: {
                                    type: Function,
                                    default: function _default() {
                                    }
                                }
                            },
                            data: function data() {
                                return {
                                    id: '',
                                    _active: false
                                };
                            },
                            computed: {
                                active: {
                                    get: function get() {
                                        return this.$data._active;
                                    },
                                    set: function set(val) {
                                        this.$data._active = val;

                                        if (val) {
                                            this.onSelected();
                                        } // end if
                                    }
                                }
                            },
                            compiled: function compiled() {
                                this.$parent.registerTab(this);
                            },
                            beforeDestroy: function beforeDestroy() {
                                this.$parent.removeTab(this);
                            },
                            ready: function ready() {
                                // Support Header element
                                var headerElem = $(this.$el).children('header:first-child');
                                if (headerElem.html()) {
                                    this.header = headerElem.html().trim();
                                    headerElem.remove();
                                } // end if
                            }
                        };
                        if (module.exports.__esModule) module.exports = module.exports.default
                        ;
                        (typeof module.exports === "function" ? module.exports.options : module.exports).template = "\n    <div role=\"tabpanel\" class=\"tab-pane\" :class=\"{ active: active }\" :id=\"id\">\n        <slot></slot>\n    </div>\n"
                        if (module.hot) {
                            (function () {
                                module.hot.accept()
                                var hotAPI = _dereq_("vue-hot-reload-api")
                                hotAPI.install(_dereq_("vue"), true)
                                if (!hotAPI.compatible) return
                                var id = "/Users/morgul/Development/vueboot/src/tabs/tab.vue"
                                if (!module.hot.data) {
                                    hotAPI.createRecord(id, module.exports)
                                } else {
                                    hotAPI.update(id, module.exports, (typeof module.exports === "function" ? module.exports.options : module.exports).template)
                                }
                            })()
                        }
                    }, {"vue": "vue", "vue-hot-reload-api": 7}],
                    12: [function (_dereq_, module, exports) {
                        var __vueify_style__ = _dereq_("vueify-insert-css").insert("/* line 6, stdin */\n.card .tabset .nav-tabs {\n  padding-top: 1.25rem;\n  padding-left: 1.25rem; }\n\n/* line 11, stdin */\n.card .tabset .tab-content {\n  padding: .5rem 1.25rem 1.25rem; }\n\n/* line 16, stdin */\n.card .tabset.tabs-left .nav-tabs {\n  padding-bottom: 1.25rem; }\n\n/* line 19, stdin */\n.card .tabset.tabs-left .tab-content {\n  padding: 1.25rem 1.25rem 1.25rem 0; }\n\n/* line 25, stdin */\n.card .tabset.tabs-right .nav-tabs {\n  padding-top: 1.25rem;\n  padding-left: 0;\n  padding-right: 1.25rem;\n  padding-bottom: 1.25rem; }\n\n/* line 31, stdin */\n.card .tabset.tabs-right .tab-content {\n  padding: 1.25rem 0 1.25rem 1.25rem; }\n\n/* line 37, stdin */\n.card .tabset.tabs-bottom .nav-tabs {\n  padding-top: 0;\n  padding-bottom: 1.25rem;\n  padding-left: 1.25rem; }\n\n/* line 42, stdin */\n.card .tabset.tabs-bottom .tab-content {\n  padding: 1.25rem 1.25rem .5rem 1.25rem; }\n\n/* line 54, stdin */\n.tabs-bottom .nav-tabs, .tabs-right .nav-tabs, .tabs-left .nav-tabs {\n  border-bottom: 0; }\n\n/* line 59, stdin */\n.tab-content > .tab-pane,\n.pill-content > .pill-pane {\n  display: none; }\n\n/* line 64, stdin */\n.tab-content > .active,\n.pill-content > .active {\n  display: block; }\n\n/* line 70, stdin */\n.tabs-bottom > .nav-tabs {\n  border-top: 1px solid #ddd; }\n  /* line 73, stdin */\n  .tabs-bottom > .nav-tabs > li {\n    margin-top: -1px;\n    margin-bottom: 0; }\n    /* line 77, stdin */\n    .tabs-bottom > .nav-tabs > li > a {\n      -webkit-border-radius: 0 0 4px 4px;\n      -moz-border-radius: 0 0 4px 4px;\n      border-radius: 0 0 4px 4px; }\n      /* line 82, stdin */\n      .tabs-bottom > .nav-tabs > li > a:hover, .tabs-bottom > .nav-tabs > li > a:focus {\n        border-bottom-color: #ddd;\n        border-top-color: transparent; }\n      /* line 88, stdin */\n      .tabs-bottom > .nav-tabs > li > a.active, .tabs-bottom > .nav-tabs > li > a.active:hover, .tabs-bottom > .nav-tabs > li > a.active:focus {\n        border-color: transparent #ddd #ddd #ddd;\n        *border-top-color: #fff; }\n\n/* line 98, stdin */\n.tabs-left, .tabs-right {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex; }\n  /* line 101, stdin */\n  .tabs-left > .nav-tabs, .tabs-right > .nav-tabs {\n    -webkit-box-flex: 1;\n    -webkit-flex: 1 1 auto;\n        -ms-flex: 1 1 auto;\n            flex: 1 1 auto;\n    white-space: nowrap;\n    float: none; }\n  /* line 107, stdin */\n  .tabs-left .tab-content, .tabs-right .tab-content {\n    -webkit-box-flex: 1;\n    -webkit-flex: 1 1 100%;\n        -ms-flex: 1 1 100%;\n            flex: 1 1 100%; }\n  /* line 111, stdin */\n  .tabs-left > .nav-tabs > li, .tabs-right > .nav-tabs > li {\n    float: none; }\n    /* line 114, stdin */\n    .tabs-left > .nav-tabs > li > a, .tabs-right > .nav-tabs > li > a {\n      min-width: 74px;\n      margin-right: 0;\n      margin-bottom: 3px; }\n  /* line 121, stdin */\n  .tabs-left .nav-tabs .nav-item + .nav-item, .tabs-right .nav-tabs .nav-item + .nav-item {\n    margin-left: 0; }\n\n/* line 126, stdin */\n.tabs-left > .nav-tabs {\n  float: left;\n  margin-right: 19px;\n  border-right: 1px solid #ddd; }\n  /* line 131, stdin */\n  .tabs-left > .nav-tabs > li > a {\n    margin-right: -1px;\n    -webkit-border-radius: 4px 0 0 4px;\n    -moz-border-radius: 4px 0 0 4px;\n    border-radius: 4px 0 0 4px; }\n    /* line 137, stdin */\n    .tabs-left > .nav-tabs > li > a:hover, .tabs-left > .nav-tabs > li > a:focus {\n      border-color: #eee #ddd #eee #eee; }\n    /* line 142, stdin */\n    .tabs-left > .nav-tabs > li > a.active, .tabs-left > .nav-tabs > li > a.active:hover, .tabs-left > .nav-tabs > li > a.active:focus {\n      border-color: #ddd transparent #ddd #ddd;\n      *border-right-color: #fff; }\n\n/* line 150, stdin */\n.tabs-right > .nav-tabs {\n  float: right;\n  margin-left: 19px;\n  border-left: 1px solid #ddd; }\n  /* line 155, stdin */\n  .tabs-right > .nav-tabs > li > a {\n    margin-left: -1px;\n    -webkit-border-radius: 0 4px 4px 0;\n    -moz-border-radius: 0 4px 4px 0;\n    border-radius: 0 4px 4px 0; }\n    /* line 161, stdin */\n    .tabs-right > .nav-tabs > li > a:hover, .tabs-right > .nav-tabs > li > a:focus {\n      border-color: #eee #eee #eee #ddd; }\n    /* line 166, stdin */\n    .tabs-right > .nav-tabs > li > a.active, .tabs-right > .nav-tabs > li > a.active:hover, .tabs-right > .nav-tabs > li > a.active:focus {\n      border-color: #ddd #ddd #ddd transparent;\n      *border-left-color: #fff; }\n\n/* line 174, stdin */\n.tabs-left .tab-pane,\n.tabs-right .tab-pane {\n  overflow-y: auto; }\n")
                        'use strict';

                        Object.defineProperty(exports, "__esModule", {
                            value: true
                        });
                        exports.default = {
                            props: {
                                orientation: {
                                    type: String,
                                    default: 'top'
                                }
                            },
                            data: function data() {
                                return {
                                    tabs: []
                                };
                            },
                            methods: {
                                orientationClass: function orientationClass() {
                                    return 'tabs-' + this.orientation;
                                },
                                activateTab: function activateTab(index) {
                                    var tab = this.tabs[index];

                                    if (tab && !tab.disabled) {
                                        if (index == 'first') {
                                            index = 0;
                                        } else if (index == 'last') {
                                            index = this.tabs.length - 1;
                                        } // end if

                                        this.tabs.forEach(function (tab, idx) {
                                            tab.active = idx === index;
                                        });
                                    } // end if
                                },
                                ensureActiveTab: function ensureActiveTab() {
                                    var activeTab = 0;
                                    this.tabs.forEach(function (tab, index) {
                                        if (tab.active) {
                                            activeTab = index;
                                        } // end if
                                    });

                                    this.activateTab(activeTab);
                                },
                                registerTab: function registerTab(tab) {
                                    tab.id = this.tabs.length;
                                    this.tabs.push(tab);
                                    this.ensureActiveTab();
                                },
                                removeTab: function removeTab(tab) {
                                    this.tabs.$remove(tab);
                                    this.ensureActiveTab();
                                }
                            }
                        };
                        if (module.exports.__esModule) module.exports = module.exports.default
                        ;
                        (typeof module.exports === "function" ? module.exports.options : module.exports).template = "\n    <div class=\"tabset clearfix\" :class=\"orientationClass()\">\n        <!-- Nav tabs -->\n        <ul v-if=\"orientation != 'bottom' &amp;&amp; orientation != 'right'\" class=\"nav nav-tabs\" role=\"tablist\">\n            <li class=\"nav-item\" v-for=\"tab in tabs\">\n                <a class=\"nav-link\" :class=\"{ active: tab.active, disabled: tab.disabled }\" href=\"#{{ $index }}\" role=\"tab\" data-toggle=\"tab\" @click.stop.prevent=\"activateTab($index)\">{{{ tab.header }}}</a>\n            </li>\n        </ul>\n\n        <!-- Tab panes -->\n        <div class=\"tab-content\">\n            <slot></slot>\n        </div>\n\n        <!-- Nav tabs -->\n        <ul v-if=\"orientation == 'bottom' || orientation == 'right'\" class=\"nav nav-tabs\" role=\"tablist\">\n            <li class=\"nav-item\" v-for=\"tab in tabs\">\n                <a class=\"nav-link\" :class=\"{ active: tab.active, disabled: tab.disabled }\" href=\"#{{ $index }}\" role=\"tab\" data-toggle=\"tab\" @click.stop.prevent=\"activateTab($index)\">{{{ tab.header }}}</a>\n            </li>\n        </ul>\n    </div>\n"
                        if (module.hot) {
                            (function () {
                                module.hot.accept()
                                var hotAPI = _dereq_("vue-hot-reload-api")
                                hotAPI.install(_dereq_("vue"), true)
                                if (!hotAPI.compatible) return
                                var id = "/Users/morgul/Development/vueboot/src/tabs/tabset.vue"
                                module.hot.dispose(function () {
                                    _dereq_("vueify-insert-css").cache["/* line 6, stdin */\n.card .tabset .nav-tabs {\n  padding-top: 1.25rem;\n  padding-left: 1.25rem; }\n\n/* line 11, stdin */\n.card .tabset .tab-content {\n  padding: .5rem 1.25rem 1.25rem; }\n\n/* line 16, stdin */\n.card .tabset.tabs-left .nav-tabs {\n  padding-bottom: 1.25rem; }\n\n/* line 19, stdin */\n.card .tabset.tabs-left .tab-content {\n  padding: 1.25rem 1.25rem 1.25rem 0; }\n\n/* line 25, stdin */\n.card .tabset.tabs-right .nav-tabs {\n  padding-top: 1.25rem;\n  padding-left: 0;\n  padding-right: 1.25rem;\n  padding-bottom: 1.25rem; }\n\n/* line 31, stdin */\n.card .tabset.tabs-right .tab-content {\n  padding: 1.25rem 0 1.25rem 1.25rem; }\n\n/* line 37, stdin */\n.card .tabset.tabs-bottom .nav-tabs {\n  padding-top: 0;\n  padding-bottom: 1.25rem;\n  padding-left: 1.25rem; }\n\n/* line 42, stdin */\n.card .tabset.tabs-bottom .tab-content {\n  padding: 1.25rem 1.25rem .5rem 1.25rem; }\n\n/* line 54, stdin */\n.tabs-bottom .nav-tabs, .tabs-right .nav-tabs, .tabs-left .nav-tabs {\n  border-bottom: 0; }\n\n/* line 59, stdin */\n.tab-content > .tab-pane,\n.pill-content > .pill-pane {\n  display: none; }\n\n/* line 64, stdin */\n.tab-content > .active,\n.pill-content > .active {\n  display: block; }\n\n/* line 70, stdin */\n.tabs-bottom > .nav-tabs {\n  border-top: 1px solid #ddd; }\n  /* line 73, stdin */\n  .tabs-bottom > .nav-tabs > li {\n    margin-top: -1px;\n    margin-bottom: 0; }\n    /* line 77, stdin */\n    .tabs-bottom > .nav-tabs > li > a {\n      -webkit-border-radius: 0 0 4px 4px;\n      -moz-border-radius: 0 0 4px 4px;\n      border-radius: 0 0 4px 4px; }\n      /* line 82, stdin */\n      .tabs-bottom > .nav-tabs > li > a:hover, .tabs-bottom > .nav-tabs > li > a:focus {\n        border-bottom-color: #ddd;\n        border-top-color: transparent; }\n      /* line 88, stdin */\n      .tabs-bottom > .nav-tabs > li > a.active, .tabs-bottom > .nav-tabs > li > a.active:hover, .tabs-bottom > .nav-tabs > li > a.active:focus {\n        border-color: transparent #ddd #ddd #ddd;\n        *border-top-color: #fff; }\n\n/* line 98, stdin */\n.tabs-left, .tabs-right {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex; }\n  /* line 101, stdin */\n  .tabs-left > .nav-tabs, .tabs-right > .nav-tabs {\n    -webkit-box-flex: 1;\n    -webkit-flex: 1 1 auto;\n        -ms-flex: 1 1 auto;\n            flex: 1 1 auto;\n    white-space: nowrap;\n    float: none; }\n  /* line 107, stdin */\n  .tabs-left .tab-content, .tabs-right .tab-content {\n    -webkit-box-flex: 1;\n    -webkit-flex: 1 1 100%;\n        -ms-flex: 1 1 100%;\n            flex: 1 1 100%; }\n  /* line 111, stdin */\n  .tabs-left > .nav-tabs > li, .tabs-right > .nav-tabs > li {\n    float: none; }\n    /* line 114, stdin */\n    .tabs-left > .nav-tabs > li > a, .tabs-right > .nav-tabs > li > a {\n      min-width: 74px;\n      margin-right: 0;\n      margin-bottom: 3px; }\n  /* line 121, stdin */\n  .tabs-left .nav-tabs .nav-item + .nav-item, .tabs-right .nav-tabs .nav-item + .nav-item {\n    margin-left: 0; }\n\n/* line 126, stdin */\n.tabs-left > .nav-tabs {\n  float: left;\n  margin-right: 19px;\n  border-right: 1px solid #ddd; }\n  /* line 131, stdin */\n  .tabs-left > .nav-tabs > li > a {\n    margin-right: -1px;\n    -webkit-border-radius: 4px 0 0 4px;\n    -moz-border-radius: 4px 0 0 4px;\n    border-radius: 4px 0 0 4px; }\n    /* line 137, stdin */\n    .tabs-left > .nav-tabs > li > a:hover, .tabs-left > .nav-tabs > li > a:focus {\n      border-color: #eee #ddd #eee #eee; }\n    /* line 142, stdin */\n    .tabs-left > .nav-tabs > li > a.active, .tabs-left > .nav-tabs > li > a.active:hover, .tabs-left > .nav-tabs > li > a.active:focus {\n      border-color: #ddd transparent #ddd #ddd;\n      *border-right-color: #fff; }\n\n/* line 150, stdin */\n.tabs-right > .nav-tabs {\n  float: right;\n  margin-left: 19px;\n  border-left: 1px solid #ddd; }\n  /* line 155, stdin */\n  .tabs-right > .nav-tabs > li > a {\n    margin-left: -1px;\n    -webkit-border-radius: 0 4px 4px 0;\n    -moz-border-radius: 0 4px 4px 0;\n    border-radius: 0 4px 4px 0; }\n    /* line 161, stdin */\n    .tabs-right > .nav-tabs > li > a:hover, .tabs-right > .nav-tabs > li > a:focus {\n      border-color: #eee #eee #eee #ddd; }\n    /* line 166, stdin */\n    .tabs-right > .nav-tabs > li > a.active, .tabs-right > .nav-tabs > li > a.active:hover, .tabs-right > .nav-tabs > li > a.active:focus {\n      border-color: #ddd #ddd #ddd transparent;\n      *border-left-color: #fff; }\n\n/* line 174, stdin */\n.tabs-left .tab-pane,\n.tabs-right .tab-pane {\n  overflow-y: auto; }\n"] = false
                                    document.head.removeChild(__vueify_style__)
                                })
                                if (!module.hot.data) {
                                    hotAPI.createRecord(id, module.exports)
                                } else {
                                    hotAPI.update(id, module.exports, (typeof module.exports === "function" ? module.exports.options : module.exports).template)
                                }
                            })()
                        }
                    }, {"vue": "vue", "vue-hot-reload-api": 7, "vueify-insert-css": 8}],
                    13: [function (_dereq_, module, exports) {
                        'use strict';

                        Object.defineProperty(exports, "__esModule", {
                            value: true
                        });

                        var _toastSvc = _dereq_('./toastSvc');

                        var _toastSvc2 = _interopRequireDefault(_toastSvc);

                        var _alert = _dereq_('../alert/alert.vue');

                        var _alert2 = _interopRequireDefault(_alert);

                        function _interopRequireDefault(obj) {
                            return obj && obj.__esModule ? obj : {default: obj};
                        }

                        exports.default = {
                            components: {
                                alert: _alert2.default
                            },
                            data: function data() {
                                return {
                                    state: _toastSvc2.default.state
                                };
                            },
                            computed: {
                                toasts: function toasts() {
                                    return this.state.toasts;
                                }
                            },
                            methods: {
                                removeToast: function removeToast(toast) {
                                    var _this = this;

                                    return function () {
                                        _this.state.toasts.$remove(toast);
                                    };
                                }
                            }
                        };
                        if (module.exports.__esModule) module.exports = module.exports.default
                        ;
                        (typeof module.exports === "function" ? module.exports.options : module.exports).template = "\n    <div class=\"toast-container\">\n        <alert :type=\"toast.type\" :dismissible=\"toast.dismissible\" :timeout=\"toast.timeout\" :onclose=\"removeToast(toast)\" v-for=\"toast in toasts\">{{{ toast.content }}}</alert>\n    </div>\n"
                        if (module.hot) {
                            (function () {
                                module.hot.accept()
                                var hotAPI = _dereq_("vue-hot-reload-api")
                                hotAPI.install(_dereq_("vue"), true)
                                if (!hotAPI.compatible) return
                                var id = "/Users/morgul/Development/vueboot/src/toast/toast.vue"
                                if (!module.hot.data) {
                                    hotAPI.createRecord(id, module.exports)
                                } else {
                                    hotAPI.update(id, module.exports, (typeof module.exports === "function" ? module.exports.options : module.exports).template)
                                }
                            })()
                        }
                    }, {"../alert/alert.vue": 9, "./toastSvc": 14, "vue": "vue", "vue-hot-reload-api": 7}],
                    14: [function (_dereq_, module, exports) {
                        'use strict';

                        Object.defineProperty(exports, "__esModule", {
                            value: true
                        });

                        var _classCallCheck2 = _dereq_('babel-runtime/helpers/classCallCheck');

                        var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

                        var _createClass2 = _dereq_('babel-runtime/helpers/createClass');

                        var _createClass3 = _interopRequireDefault(_createClass2);

                        var _lodash = _dereq_('lodash');

                        var _lodash2 = _interopRequireDefault(_lodash);

                        function _interopRequireDefault(obj) {
                            return obj && obj.__esModule ? obj : {default: obj};
                        }

//----------------------------------------------------------------------------------------------------------------------

                        var ToastService = function () {
                            function ToastService() {
                                (0, _classCallCheck3.default)(this, ToastService);

                                this.state = {
                                    toasts: []
                                };
                            } // end constructor

                            (0, _createClass3.default)(ToastService, [{
                                key: 'create',
                                value: function create(toast) {
                                    if (_lodash2.default.isString(toast)) {
                                        toast = {content: toast};
                                    } // end if

                                    toast = _lodash2.default.defaults({}, toast, {
                                        type: 'info',
                                        dismissible: false,
                                        timeout: 5000
                                    });

                                    // If timeout is any falsey value (including 0!), we count it as disabling the timeout.
                                    if (!toast.timeout) {
                                        toast.timeout = -1;
                                    } // end if

                                    this.state.toasts.push(toast);
                                } // end create

                            }]);
                            return ToastService;
                        }(); // end ToastService

//----------------------------------------------------------------------------------------------------------------------

//----------------------------------------------------------------------------------------------------------------------
/// ToastService
///
/// @module
//----------------------------------------------------------------------------------------------------------------------

                        exports.default = new ToastService();

//----------------------------------------------------------------------------------------------------------------------

                    }, {
                        "babel-runtime/helpers/classCallCheck": 2,
                        "babel-runtime/helpers/createClass": 3,
                        "lodash": 6
                    }],
                    15: [function (_dereq_, module, exports) {
                        "use strict";

                        var _alert = _dereq_("./alert/alert.vue");

                        var _alert2 = _interopRequireDefault(_alert);

                        var _toast = _dereq_("./toast/toast.vue");

                        var _toast2 = _interopRequireDefault(_toast);

                        var _toastSvc = _dereq_("./toast/toastSvc");

                        var _toastSvc2 = _interopRequireDefault(_toastSvc);

                        var _modal = _dereq_("./modal/modal.vue");

                        var _modal2 = _interopRequireDefault(_modal);

                        var _tabset = _dereq_("./tabs/tabset.vue");

                        var _tabset2 = _interopRequireDefault(_tabset);

                        var _tab = _dereq_("./tabs/tab.vue");

                        var _tab2 = _interopRequireDefault(_tab);

                        function _interopRequireDefault(obj) {
                            return obj && obj.__esModule ? obj : {default: obj};
                        }

//----------------------------------------------------------------------------------------------------------------------

// Use node-style export to allow global vueboot object to work correctly.
//----------------------------------------------------------------------------------------------------------------------
/// Main VueBoot module
///
/// @module
//----------------------------------------------------------------------------------------------------------------------

                        module.exports = {
                            alert: _alert2.default,
                            toast: _toast2.default,
                            toastService: _toastSvc2.default,
                            modal: _modal2.default,
                            tabset: _tabset2.default,
                            tab: _tab2.default
                        };

//----------------------------------------------------------------------------------------------------------------------

                    }, {
                        "./alert/alert.vue": 9,
                        "./modal/modal.vue": 10,
                        "./tabs/tab.vue": 11,
                        "./tabs/tabset.vue": 12,
                        "./toast/toast.vue": 13,
                        "./toast/toastSvc": 14
                    }]
                }, {}, [15])(15)
            });
            /* WEBPACK VAR INJECTION */
        }.call(exports, __webpack_require__(109)))

        /***/
    },
    /* 113 */
    /***/ function (module, exports, __webpack_require__) {

        var map = {
            "./af": 1,
            "./af.js": 1,
            "./ar": 7,
            "./ar-dz": 2,
            "./ar-dz.js": 2,
            "./ar-ly": 3,
            "./ar-ly.js": 3,
            "./ar-ma": 4,
            "./ar-ma.js": 4,
            "./ar-sa": 5,
            "./ar-sa.js": 5,
            "./ar-tn": 6,
            "./ar-tn.js": 6,
            "./ar.js": 7,
            "./az": 8,
            "./az.js": 8,
            "./be": 9,
            "./be.js": 9,
            "./bg": 10,
            "./bg.js": 10,
            "./bn": 11,
            "./bn.js": 11,
            "./bo": 12,
            "./bo.js": 12,
            "./br": 13,
            "./br.js": 13,
            "./bs": 14,
            "./bs.js": 14,
            "./ca": 15,
            "./ca.js": 15,
            "./cs": 16,
            "./cs.js": 16,
            "./cv": 17,
            "./cv.js": 17,
            "./cy": 18,
            "./cy.js": 18,
            "./da": 19,
            "./da.js": 19,
            "./de": 21,
            "./de-at": 20,
            "./de-at.js": 20,
            "./de.js": 21,
            "./dv": 22,
            "./dv.js": 22,
            "./el": 23,
            "./el.js": 23,
            "./en-au": 24,
            "./en-au.js": 24,
            "./en-ca": 25,
            "./en-ca.js": 25,
            "./en-gb": 26,
            "./en-gb.js": 26,
            "./en-ie": 27,
            "./en-ie.js": 27,
            "./en-nz": 28,
            "./en-nz.js": 28,
            "./eo": 29,
            "./eo.js": 29,
            "./es": 31,
            "./es-do": 30,
            "./es-do.js": 30,
            "./es.js": 31,
            "./et": 32,
            "./et.js": 32,
            "./eu": 33,
            "./eu.js": 33,
            "./fa": 34,
            "./fa.js": 34,
            "./fi": 35,
            "./fi.js": 35,
            "./fo": 36,
            "./fo.js": 36,
            "./fr": 39,
            "./fr-ca": 37,
            "./fr-ca.js": 37,
            "./fr-ch": 38,
            "./fr-ch.js": 38,
            "./fr.js": 39,
            "./fy": 40,
            "./fy.js": 40,
            "./gd": 41,
            "./gd.js": 41,
            "./gl": 42,
            "./gl.js": 42,
            "./he": 43,
            "./he.js": 43,
            "./hi": 44,
            "./hi.js": 44,
            "./hr": 45,
            "./hr.js": 45,
            "./hu": 46,
            "./hu.js": 46,
            "./hy-am": 47,
            "./hy-am.js": 47,
            "./id": 48,
            "./id.js": 48,
            "./is": 49,
            "./is.js": 49,
            "./it": 50,
            "./it.js": 50,
            "./ja": 51,
            "./ja.js": 51,
            "./jv": 52,
            "./jv.js": 52,
            "./ka": 53,
            "./ka.js": 53,
            "./kk": 54,
            "./kk.js": 54,
            "./km": 55,
            "./km.js": 55,
            "./ko": 56,
            "./ko.js": 56,
            "./ky": 57,
            "./ky.js": 57,
            "./lb": 58,
            "./lb.js": 58,
            "./lo": 59,
            "./lo.js": 59,
            "./lt": 60,
            "./lt.js": 60,
            "./lv": 61,
            "./lv.js": 61,
            "./me": 62,
            "./me.js": 62,
            "./mi": 63,
            "./mi.js": 63,
            "./mk": 64,
            "./mk.js": 64,
            "./ml": 65,
            "./ml.js": 65,
            "./mr": 66,
            "./mr.js": 66,
            "./ms": 68,
            "./ms-my": 67,
            "./ms-my.js": 67,
            "./ms.js": 68,
            "./my": 69,
            "./my.js": 69,
            "./nb": 70,
            "./nb.js": 70,
            "./ne": 71,
            "./ne.js": 71,
            "./nl": 73,
            "./nl-be": 72,
            "./nl-be.js": 72,
            "./nl.js": 73,
            "./nn": 74,
            "./nn.js": 74,
            "./pa-in": 75,
            "./pa-in.js": 75,
            "./pl": 76,
            "./pl.js": 76,
            "./pt": 78,
            "./pt-br": 77,
            "./pt-br.js": 77,
            "./pt.js": 78,
            "./ro": 79,
            "./ro.js": 79,
            "./ru": 80,
            "./ru.js": 80,
            "./se": 81,
            "./se.js": 81,
            "./si": 82,
            "./si.js": 82,
            "./sk": 83,
            "./sk.js": 83,
            "./sl": 84,
            "./sl.js": 84,
            "./sq": 85,
            "./sq.js": 85,
            "./sr": 87,
            "./sr-cyrl": 86,
            "./sr-cyrl.js": 86,
            "./sr.js": 87,
            "./ss": 88,
            "./ss.js": 88,
            "./sv": 89,
            "./sv.js": 89,
            "./sw": 90,
            "./sw.js": 90,
            "./ta": 91,
            "./ta.js": 91,
            "./te": 92,
            "./te.js": 92,
            "./tet": 93,
            "./tet.js": 93,
            "./th": 94,
            "./th.js": 94,
            "./tl-ph": 95,
            "./tl-ph.js": 95,
            "./tlh": 96,
            "./tlh.js": 96,
            "./tr": 97,
            "./tr.js": 97,
            "./tzl": 98,
            "./tzl.js": 98,
            "./tzm": 100,
            "./tzm-latn": 99,
            "./tzm-latn.js": 99,
            "./tzm.js": 100,
            "./uk": 101,
            "./uk.js": 101,
            "./uz": 102,
            "./uz.js": 102,
            "./vi": 103,
            "./vi.js": 103,
            "./x-pseudo": 104,
            "./x-pseudo.js": 104,
            "./yo": 105,
            "./yo.js": 105,
            "./zh-cn": 106,
            "./zh-cn.js": 106,
            "./zh-hk": 107,
            "./zh-hk.js": 107,
            "./zh-tw": 108,
            "./zh-tw.js": 108
        };

        function webpackContext(req) {
            return __webpack_require__(webpackContextResolve(req));
        };

        function webpackContextResolve(req) {
            var id = map[req];
            if (!(id + 1)) // check for number
                throw new Error("Cannot find module '" + req + "'.");
            return id;
        };
        webpackContext.keys = function webpackContextKeys() {
            return Object.keys(map);
        };
        webpackContext.resolve = webpackContextResolve;
        module.exports = webpackContext;
        webpackContext.id = 113;


        /***/
    },
    /* 114 */
    /***/ function (module, exports) {

// shim for using process in browser
        var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

        var cachedSetTimeout;
        var cachedClearTimeout;

        function defaultSetTimout() {
            throw new Error('setTimeout has not been defined');
        }

        function defaultClearTimeout() {
            throw new Error('clearTimeout has not been defined');
        }

        (function () {
            try {
                if (typeof setTimeout === 'function') {
                    cachedSetTimeout = setTimeout;
                } else {
                    cachedSetTimeout = defaultSetTimout;
                }
            } catch (e) {
                cachedSetTimeout = defaultSetTimout;
            }
            try {
                if (typeof clearTimeout === 'function') {
                    cachedClearTimeout = clearTimeout;
                } else {
                    cachedClearTimeout = defaultClearTimeout;
                }
            } catch (e) {
                cachedClearTimeout = defaultClearTimeout;
            }
        }())

        function runTimeout(fun) {
            if (cachedSetTimeout === setTimeout) {
                //normal enviroments in sane situations
                return setTimeout(fun, 0);
            }
            // if setTimeout wasn't available but was latter defined
            if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                cachedSetTimeout = setTimeout;
                return setTimeout(fun, 0);
            }
            try {
                // when when somebody has screwed with setTimeout but no I.E. maddness
                return cachedSetTimeout(fun, 0);
            } catch (e) {
                try {
                    // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                    return cachedSetTimeout.call(null, fun, 0);
                } catch (e) {
                    // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                    return cachedSetTimeout.call(this, fun, 0);
                }
            }


        }

        function runClearTimeout(marker) {
            if (cachedClearTimeout === clearTimeout) {
                //normal enviroments in sane situations
                return clearTimeout(marker);
            }
            // if clearTimeout wasn't available but was latter defined
            if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                cachedClearTimeout = clearTimeout;
                return clearTimeout(marker);
            }
            try {
                // when when somebody has screwed with setTimeout but no I.E. maddness
                return cachedClearTimeout(marker);
            } catch (e) {
                try {
                    // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                    return cachedClearTimeout.call(null, marker);
                } catch (e) {
                    // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                    // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                    return cachedClearTimeout.call(this, marker);
                }
            }


        }

        var queue = [];
        var draining = false;
        var currentQueue;
        var queueIndex = -1;

        function cleanUpNextTick() {
            if (!draining || !currentQueue) {
                return;
            }
            draining = false;
            if (currentQueue.length) {
                queue = currentQueue.concat(queue);
            } else {
                queueIndex = -1;
            }
            if (queue.length) {
                drainQueue();
            }
        }

        function drainQueue() {
            if (draining) {
                return;
            }
            var timeout = runTimeout(cleanUpNextTick);
            draining = true;

            var len = queue.length;
            while (len) {
                currentQueue = queue;
                queue = [];
                while (++queueIndex < len) {
                    if (currentQueue) {
                        currentQueue[queueIndex].run();
                    }
                }
                queueIndex = -1;
                len = queue.length;
            }
            currentQueue = null;
            draining = false;
            runClearTimeout(timeout);
        }

        process.nextTick = function (fun) {
            var args = new Array(arguments.length - 1);
            if (arguments.length > 1) {
                for (var i = 1; i < arguments.length; i++) {
                    args[i - 1] = arguments[i];
                }
            }
            queue.push(new Item(fun, args));
            if (queue.length === 1 && !draining) {
                runTimeout(drainQueue);
            }
        };

// v8 likes predictible objects
        function Item(fun, array) {
            this.fun = fun;
            this.array = array;
        }

        Item.prototype.run = function () {
            this.fun.apply(null, this.array);
        };
        process.title = 'browser';
        process.browser = true;
        process.env = {};
        process.argv = [];
        process.version = ''; // empty string to avoid regexp issues
        process.versions = {};

        function noop() {
        }

        process.on = noop;
        process.addListener = noop;
        process.once = noop;
        process.off = noop;
        process.removeListener = noop;
        process.removeAllListeners = noop;
        process.emit = noop;

        process.binding = function (name) {
            throw new Error('process.binding is not supported');
        };

        process.cwd = function () {
            return '/'
        };
        process.chdir = function (dir) {
            throw new Error('process.chdir is not supported');
        };
        process.umask = function () {
            return 0;
        };


        /***/
    },
    /* 115 */
    /***/ function (module, exports, __webpack_require__) {

        "use strict";
        /*!
 * vue-resource v1.2.0
 * https://github.com/pagekit/vue-resource
 * Released under the MIT License.
 */

        'use strict';

        /**
         * Promises/A+ polyfill v1.1.4 (https://github.com/bramstein/promis)
         */

        var RESOLVED = 0;
        var REJECTED = 1;
        var PENDING = 2;

        function Promise$1(executor) {

            this.state = PENDING;
            this.value = undefined;
            this.deferred = [];

            var promise = this;

            try {
                executor(function (x) {
                    promise.resolve(x);
                }, function (r) {
                    promise.reject(r);
                });
            } catch (e) {
                promise.reject(e);
            }
        }

        Promise$1.reject = function (r) {
            return new Promise$1(function (resolve, reject) {
                reject(r);
            });
        };

        Promise$1.resolve = function (x) {
            return new Promise$1(function (resolve, reject) {
                resolve(x);
            });
        };

        Promise$1.all = function all(iterable) {
            return new Promise$1(function (resolve, reject) {
                var count = 0, result = [];

                if (iterable.length === 0) {
                    resolve(result);
                }

                function resolver(i) {
                    return function (x) {
                        result[i] = x;
                        count += 1;

                        if (count === iterable.length) {
                            resolve(result);
                        }
                    };
                }

                for (var i = 0; i < iterable.length; i += 1) {
                    Promise$1.resolve(iterable[i]).then(resolver(i), reject);
                }
            });
        };

        Promise$1.race = function race(iterable) {
            return new Promise$1(function (resolve, reject) {
                for (var i = 0; i < iterable.length; i += 1) {
                    Promise$1.resolve(iterable[i]).then(resolve, reject);
                }
            });
        };

        var p$1 = Promise$1.prototype;

        p$1.resolve = function resolve(x) {
            var promise = this;

            if (promise.state === PENDING) {
                if (x === promise) {
                    throw new TypeError('Promise settled with itself.');
                }

                var called = false;

                try {
                    var then = x && x['then'];

                    if (x !== null && typeof x === 'object' && typeof then === 'function') {
                        then.call(x, function (x) {
                            if (!called) {
                                promise.resolve(x);
                            }
                            called = true;

                        }, function (r) {
                            if (!called) {
                                promise.reject(r);
                            }
                            called = true;
                        });
                        return;
                    }
                } catch (e) {
                    if (!called) {
                        promise.reject(e);
                    }
                    return;
                }

                promise.state = RESOLVED;
                promise.value = x;
                promise.notify();
            }
        };

        p$1.reject = function reject(reason) {
            var promise = this;

            if (promise.state === PENDING) {
                if (reason === promise) {
                    throw new TypeError('Promise settled with itself.');
                }

                promise.state = REJECTED;
                promise.value = reason;
                promise.notify();
            }
        };

        p$1.notify = function notify() {
            var promise = this;

            nextTick(function () {
                if (promise.state !== PENDING) {
                    while (promise.deferred.length) {
                        var deferred = promise.deferred.shift(),
                            onResolved = deferred[0],
                            onRejected = deferred[1],
                            resolve = deferred[2],
                            reject = deferred[3];

                        try {
                            if (promise.state === RESOLVED) {
                                if (typeof onResolved === 'function') {
                                    resolve(onResolved.call(undefined, promise.value));
                                } else {
                                    resolve(promise.value);
                                }
                            } else if (promise.state === REJECTED) {
                                if (typeof onRejected === 'function') {
                                    resolve(onRejected.call(undefined, promise.value));
                                } else {
                                    reject(promise.value);
                                }
                            }
                        } catch (e) {
                            reject(e);
                        }
                    }
                }
            });
        };

        p$1.then = function then(onResolved, onRejected) {
            var promise = this;

            return new Promise$1(function (resolve, reject) {
                promise.deferred.push([onResolved, onRejected, resolve, reject]);
                promise.notify();
            });
        };

        p$1.catch = function (onRejected) {
            return this.then(undefined, onRejected);
        };

        /**
         * Promise adapter.
         */

        if (typeof Promise === 'undefined') {
            window.Promise = Promise$1;
        }

        function PromiseObj(executor, context) {

            if (executor instanceof Promise) {
                this.promise = executor;
            } else {
                this.promise = new Promise(executor.bind(context));
            }

            this.context = context;
        }

        PromiseObj.all = function (iterable, context) {
            return new PromiseObj(Promise.all(iterable), context);
        };

        PromiseObj.resolve = function (value, context) {
            return new PromiseObj(Promise.resolve(value), context);
        };

        PromiseObj.reject = function (reason, context) {
            return new PromiseObj(Promise.reject(reason), context);
        };

        PromiseObj.race = function (iterable, context) {
            return new PromiseObj(Promise.race(iterable), context);
        };

        var p = PromiseObj.prototype;

        p.bind = function (context) {
            this.context = context;
            return this;
        };

        p.then = function (fulfilled, rejected) {

            if (fulfilled && fulfilled.bind && this.context) {
                fulfilled = fulfilled.bind(this.context);
            }

            if (rejected && rejected.bind && this.context) {
                rejected = rejected.bind(this.context);
            }

            return new PromiseObj(this.promise.then(fulfilled, rejected), this.context);
        };

        p.catch = function (rejected) {

            if (rejected && rejected.bind && this.context) {
                rejected = rejected.bind(this.context);
            }

            return new PromiseObj(this.promise.catch(rejected), this.context);
        };

        p.finally = function (callback) {

            return this.then(function (value) {
                    callback.call(this);
                    return value;
                }, function (reason) {
                    callback.call(this);
                    return Promise.reject(reason);
                }
            );
        };

        /**
         * Utility functions.
         */

        var debug = false;
        var util = {};
        var ref = {};
        var hasOwnProperty = ref.hasOwnProperty;

        var ref$1 = [];
        var slice = ref$1.slice;

        var inBrowser = typeof window !== 'undefined';

        var Util = function (Vue) {
            util = Vue.util;
            debug = Vue.config.debug || !Vue.config.silent;
        };

        function warn(msg) {
            if (typeof console !== 'undefined' && debug) {
                console.warn('[VueResource warn]: ' + msg);
            }
        }

        function error(msg) {
            if (typeof console !== 'undefined') {
                console.error(msg);
            }
        }

        function nextTick(cb, ctx) {
            return util.nextTick(cb, ctx);
        }

        function trim(str) {
            return str ? str.replace(/^\s*|\s*$/g, '') : '';
        }

        function toLower(str) {
            return str ? str.toLowerCase() : '';
        }

        function toUpper(str) {
            return str ? str.toUpperCase() : '';
        }

        var isArray = Array.isArray;

        function isString(val) {
            return typeof val === 'string';
        }


        function isFunction(val) {
            return typeof val === 'function';
        }

        function isObject(obj) {
            return obj !== null && typeof obj === 'object';
        }

        function isPlainObject(obj) {
            return isObject(obj) && Object.getPrototypeOf(obj) == Object.prototype;
        }

        function isBlob(obj) {
            return typeof Blob !== 'undefined' && obj instanceof Blob;
        }

        function isFormData(obj) {
            return typeof FormData !== 'undefined' && obj instanceof FormData;
        }

        function when(value, fulfilled, rejected) {

            var promise = PromiseObj.resolve(value);

            if (arguments.length < 2) {
                return promise;
            }

            return promise.then(fulfilled, rejected);
        }

        function options(fn, obj, opts) {

            opts = opts || {};

            if (isFunction(opts)) {
                opts = opts.call(obj);
            }

            return merge(fn.bind({$vm: obj, $options: opts}), fn, {$options: opts});
        }

        function each(obj, iterator) {

            var i, key;

            if (isArray(obj)) {
                for (i = 0; i < obj.length; i++) {
                    iterator.call(obj[i], obj[i], i);
                }
            } else if (isObject(obj)) {
                for (key in obj) {
                    if (hasOwnProperty.call(obj, key)) {
                        iterator.call(obj[key], obj[key], key);
                    }
                }
            }

            return obj;
        }

        var assign = Object.assign || _assign;

        function merge(target) {

            var args = slice.call(arguments, 1);

            args.forEach(function (source) {
                _merge(target, source, true);
            });

            return target;
        }

        function defaults(target) {

            var args = slice.call(arguments, 1);

            args.forEach(function (source) {

                for (var key in source) {
                    if (target[key] === undefined) {
                        target[key] = source[key];
                    }
                }

            });

            return target;
        }

        function _assign(target) {

            var args = slice.call(arguments, 1);

            args.forEach(function (source) {
                _merge(target, source);
            });

            return target;
        }

        function _merge(target, source, deep) {
            for (var key in source) {
                if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {
                    if (isPlainObject(source[key]) && !isPlainObject(target[key])) {
                        target[key] = {};
                    }
                    if (isArray(source[key]) && !isArray(target[key])) {
                        target[key] = [];
                    }
                    _merge(target[key], source[key], deep);
                } else if (source[key] !== undefined) {
                    target[key] = source[key];
                }
            }
        }

        /**
         * Root Prefix Transform.
         */

        var root = function (options$$1, next) {

            var url = next(options$$1);

            if (isString(options$$1.root) && !url.match(/^(https?:)?\//)) {
                url = options$$1.root + '/' + url;
            }

            return url;
        };

        /**
         * Query Parameter Transform.
         */

        var query = function (options$$1, next) {

            var urlParams = Object.keys(Url.options.params), query = {}, url = next(options$$1);

            each(options$$1.params, function (value, key) {
                if (urlParams.indexOf(key) === -1) {
                    query[key] = value;
                }
            });

            query = Url.params(query);

            if (query) {
                url += (url.indexOf('?') == -1 ? '?' : '&') + query;
            }

            return url;
        };

        /**
         * URL Template v2.0.6 (https://github.com/bramstein/url-template)
         */

        function expand(url, params, variables) {

            var tmpl = parse(url), expanded = tmpl.expand(params);

            if (variables) {
                variables.push.apply(variables, tmpl.vars);
            }

            return expanded;
        }

        function parse(template) {

            var operators = ['+', '#', '.', '/', ';', '?', '&'], variables = [];

            return {
                vars: variables,
                expand: function expand(context) {
                    return template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function (_, expression, literal) {
                        if (expression) {

                            var operator = null, values = [];

                            if (operators.indexOf(expression.charAt(0)) !== -1) {
                                operator = expression.charAt(0);
                                expression = expression.substr(1);
                            }

                            expression.split(/,/g).forEach(function (variable) {
                                var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
                                values.push.apply(values, getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
                                variables.push(tmp[1]);
                            });

                            if (operator && operator !== '+') {

                                var separator = ',';

                                if (operator === '?') {
                                    separator = '&';
                                } else if (operator !== '#') {
                                    separator = operator;
                                }

                                return (values.length !== 0 ? operator : '') + values.join(separator);
                            } else {
                                return values.join(',');
                            }

                        } else {
                            return encodeReserved(literal);
                        }
                    });
                }
            };
        }

        function getValues(context, operator, key, modifier) {

            var value = context[key], result = [];

            if (isDefined(value) && value !== '') {
                if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
                    value = value.toString();

                    if (modifier && modifier !== '*') {
                        value = value.substring(0, parseInt(modifier, 10));
                    }

                    result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null));
                } else {
                    if (modifier === '*') {
                        if (Array.isArray(value)) {
                            value.filter(isDefined).forEach(function (value) {
                                result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null));
                            });
                        } else {
                            Object.keys(value).forEach(function (k) {
                                if (isDefined(value[k])) {
                                    result.push(encodeValue(operator, value[k], k));
                                }
                            });
                        }
                    } else {
                        var tmp = [];

                        if (Array.isArray(value)) {
                            value.filter(isDefined).forEach(function (value) {
                                tmp.push(encodeValue(operator, value));
                            });
                        } else {
                            Object.keys(value).forEach(function (k) {
                                if (isDefined(value[k])) {
                                    tmp.push(encodeURIComponent(k));
                                    tmp.push(encodeValue(operator, value[k].toString()));
                                }
                            });
                        }

                        if (isKeyOperator(operator)) {
                            result.push(encodeURIComponent(key) + '=' + tmp.join(','));
                        } else if (tmp.length !== 0) {
                            result.push(tmp.join(','));
                        }
                    }
                }
            } else {
                if (operator === ';') {
                    result.push(encodeURIComponent(key));
                } else if (value === '' && (operator === '&' || operator === '?')) {
                    result.push(encodeURIComponent(key) + '=');
                } else if (value === '') {
                    result.push('');
                }
            }

            return result;
        }

        function isDefined(value) {
            return value !== undefined && value !== null;
        }

        function isKeyOperator(operator) {
            return operator === ';' || operator === '&' || operator === '?';
        }

        function encodeValue(operator, value, key) {

            value = (operator === '+' || operator === '#') ? encodeReserved(value) : encodeURIComponent(value);

            if (key) {
                return encodeURIComponent(key) + '=' + value;
            } else {
                return value;
            }
        }

        function encodeReserved(str) {
            return str.split(/(%[0-9A-Fa-f]{2})/g).map(function (part) {
                if (!/%[0-9A-Fa-f]/.test(part)) {
                    part = encodeURI(part);
                }
                return part;
            }).join('');
        }

        /**
         * URL Template (RFC 6570) Transform.
         */

        var template = function (options) {

            var variables = [], url = expand(options.url, options.params, variables);

            variables.forEach(function (key) {
                delete options.params[key];
            });

            return url;
        };

        /**
         * Service for URL templating.
         */

        function Url(url, params) {

            var self = this || {}, options$$1 = url, transform;

            if (isString(url)) {
                options$$1 = {url: url, params: params};
            }

            options$$1 = merge({}, Url.options, self.$options, options$$1);

            Url.transforms.forEach(function (handler) {
                transform = factory(handler, transform, self.$vm);
            });

            return transform(options$$1);
        }

        /**
         * Url options.
         */

        Url.options = {
            url: '',
            root: null,
            params: {}
        };

        /**
         * Url transforms.
         */

        Url.transforms = [template, query, root];

        /**
         * Encodes a Url parameter string.
         *
         * @param {Object} obj
         */

        Url.params = function (obj) {

            var params = [], escape = encodeURIComponent;

            params.add = function (key, value) {

                if (isFunction(value)) {
                    value = value();
                }

                if (value === null) {
                    value = '';
                }

                this.push(escape(key) + '=' + escape(value));
            };

            serialize(params, obj);

            return params.join('&').replace(/%20/g, '+');
        };

        /**
         * Parse a URL and return its components.
         *
         * @param {String} url
         */

        Url.parse = function (url) {

            var el = document.createElement('a');

            if (document.documentMode) {
                el.href = url;
                url = el.href;
            }

            el.href = url;

            return {
                href: el.href,
                protocol: el.protocol ? el.protocol.replace(/:$/, '') : '',
                port: el.port,
                host: el.host,
                hostname: el.hostname,
                pathname: el.pathname.charAt(0) === '/' ? el.pathname : '/' + el.pathname,
                search: el.search ? el.search.replace(/^\?/, '') : '',
                hash: el.hash ? el.hash.replace(/^#/, '') : ''
            };
        };

        function factory(handler, next, vm) {
            return function (options$$1) {
                return handler.call(vm, options$$1, next);
            };
        }

        function serialize(params, obj, scope) {

            var array = isArray(obj), plain = isPlainObject(obj), hash;

            each(obj, function (value, key) {

                hash = isObject(value) || isArray(value);

                if (scope) {
                    key = scope + '[' + (plain || hash ? key : '') + ']';
                }

                if (!scope && array) {
                    params.add(value.name, value.value);
                } else if (hash) {
                    serialize(params, value, key);
                } else {
                    params.add(key, value);
                }
            });
        }

        /**
         * XDomain client (Internet Explorer).
         */

        var xdrClient = function (request) {
            return new PromiseObj(function (resolve) {

                var xdr = new XDomainRequest(), handler = function (ref) {
                    var type = ref.type;


                    var status = 0;

                    if (type === 'load') {
                        status = 200;
                    } else if (type === 'error') {
                        status = 500;
                    }

                    resolve(request.respondWith(xdr.responseText, {status: status}));
                };

                request.abort = function () {
                    return xdr.abort();
                };

                xdr.open(request.method, request.getUrl());

                if (request.timeout) {
                    xdr.timeout = request.timeout;
                }

                xdr.onload = handler;
                xdr.onabort = handler;
                xdr.onerror = handler;
                xdr.ontimeout = handler;
                xdr.onprogress = function () {
                };
                xdr.send(request.getBody());
            });
        };

        /**
         * CORS Interceptor.
         */

        var SUPPORTS_CORS = inBrowser && 'withCredentials' in new XMLHttpRequest();

        var cors = function (request, next) {

            if (inBrowser) {

                var orgUrl = Url.parse(location.href);
                var reqUrl = Url.parse(request.getUrl());

                if (reqUrl.protocol !== orgUrl.protocol || reqUrl.host !== orgUrl.host) {

                    request.crossOrigin = true;
                    request.emulateHTTP = false;

                    if (!SUPPORTS_CORS) {
                        request.client = xdrClient;
                    }
                }
            }

            next();
        };

        /**
         * Body Interceptor.
         */

        var body = function (request, next) {

            if (isFormData(request.body)) {

                request.headers.delete('Content-Type');

            } else if (isObject(request.body) || isArray(request.body)) {

                if (request.emulateJSON) {
                    request.body = Url.params(request.body);
                    request.headers.set('Content-Type', 'application/x-www-form-urlencoded');
                } else {
                    request.body = JSON.stringify(request.body);
                }
            }

            next(function (response) {

                Object.defineProperty(response, 'data', {

                    get: function get() {
                        return this.body;
                    },

                    set: function set(body) {
                        this.body = body;
                    }

                });

                return response.bodyText ? when(response.text(), function (text) {

                    var type = response.headers.get('Content-Type') || '';

                    if (type.indexOf('application/json') === 0 || isJson(text)) {

                        try {
                            response.body = JSON.parse(text);
                        } catch (e) {
                            response.body = null;
                        }

                    } else {
                        response.body = text;
                    }

                    return response;

                }) : response;

            });
        };

        function isJson(str) {

            var start = str.match(/^\[|^\{(?!\{)/), end = {'[': /]$/, '{': /}$/};

            return start && end[start[0]].test(str);
        }

        /**
         * JSONP client (Browser).
         */

        var jsonpClient = function (request) {
            return new PromiseObj(function (resolve) {

                var name = request.jsonp || 'callback',
                    callback = request.jsonpCallback || '_jsonp' + Math.random().toString(36).substr(2), body = null,
                    handler, script;

                handler = function (ref) {
                    var type = ref.type;


                    var status = 0;

                    if (type === 'load' && body !== null) {
                        status = 200;
                    } else if (type === 'error') {
                        status = 500;
                    }

                    if (status && window[callback]) {
                        delete window[callback];
                        document.body.removeChild(script);
                    }

                    resolve(request.respondWith(body, {status: status}));
                };

                window[callback] = function (result) {
                    body = JSON.stringify(result);
                };

                request.abort = function () {
                    handler({type: 'abort'});
                };

                request.params[name] = callback;

                if (request.timeout) {
                    setTimeout(request.abort, request.timeout);
                }

                script = document.createElement('script');
                script.src = request.getUrl();
                script.type = 'text/javascript';
                script.async = true;
                script.onload = handler;
                script.onerror = handler;

                document.body.appendChild(script);
            });
        };

        /**
         * JSONP Interceptor.
         */

        var jsonp = function (request, next) {

            if (request.method == 'JSONP') {
                request.client = jsonpClient;
            }

            next();
        };

        /**
         * Before Interceptor.
         */

        var before = function (request, next) {

            if (isFunction(request.before)) {
                request.before.call(this, request);
            }

            next();
        };

        /**
         * HTTP method override Interceptor.
         */

        var method = function (request, next) {

            if (request.emulateHTTP && /^(PUT|PATCH|DELETE)$/i.test(request.method)) {
                request.headers.set('X-HTTP-Method-Override', request.method);
                request.method = 'POST';
            }

            next();
        };

        /**
         * Header Interceptor.
         */

        var header = function (request, next) {

            var headers = assign({}, Http.headers.common,
                !request.crossOrigin ? Http.headers.custom : {},
                Http.headers[toLower(request.method)]
            );

            each(headers, function (value, name) {
                if (!request.headers.has(name)) {
                    request.headers.set(name, value);
                }
            });

            next();
        };

        /**
         * XMLHttp client (Browser).
         */

        var SUPPORTS_BLOB = typeof Blob !== 'undefined' && typeof FileReader !== 'undefined';

        var xhrClient = function (request) {
            return new PromiseObj(function (resolve) {

                var xhr = new XMLHttpRequest(), handler = function (event) {

                    var response = request.respondWith(
                        'response' in xhr ? xhr.response : xhr.responseText, {
                            status: xhr.status === 1223 ? 204 : xhr.status, // IE9 status bug
                            statusText: xhr.status === 1223 ? 'No Content' : trim(xhr.statusText)
                        }
                    );

                    each(trim(xhr.getAllResponseHeaders()).split('\n'), function (row) {
                        response.headers.append(row.slice(0, row.indexOf(':')), row.slice(row.indexOf(':') + 1));
                    });

                    resolve(response);
                };

                request.abort = function () {
                    return xhr.abort();
                };

                if (request.progress) {
                    if (request.method === 'GET') {
                        xhr.addEventListener('progress', request.progress);
                    } else if (/^(POST|PUT)$/i.test(request.method)) {
                        xhr.upload.addEventListener('progress', request.progress);
                    }
                }

                xhr.open(request.method, request.getUrl(), true);

                if (request.timeout) {
                    xhr.timeout = request.timeout;
                }

                if (request.credentials === true) {
                    xhr.withCredentials = true;
                }

                if (!request.crossOrigin) {
                    request.headers.set('X-Requested-With', 'XMLHttpRequest');
                }

                if ('responseType' in xhr && SUPPORTS_BLOB) {
                    xhr.responseType = 'blob';
                }

                request.headers.forEach(function (value, name) {
                    xhr.setRequestHeader(name, value);
                });

                xhr.onload = handler;
                xhr.onabort = handler;
                xhr.onerror = handler;
                xhr.ontimeout = handler;
                xhr.send(request.getBody());
            });
        };

        /**
         * Http client (Node).
         */

        var nodeClient = function (request) {

            var client = __webpack_require__(118);

            return new PromiseObj(function (resolve) {

                var url = request.getUrl();
                var body = request.getBody();
                var method = request.method;
                var headers = {}, handler;

                request.headers.forEach(function (value, name) {
                    headers[name] = value;
                });

                client(url, {body: body, method: method, headers: headers}).then(handler = function (resp) {

                    var response = request.respondWith(resp.body, {
                            status: resp.statusCode,
                            statusText: trim(resp.statusMessage)
                        }
                    );

                    each(resp.headers, function (value, name) {
                        response.headers.set(name, value);
                    });

                    resolve(response);

                }, function (error$$1) {
                    return handler(error$$1.response);
                });
            });
        };

        /**
         * Base client.
         */

        var Client = function (context) {

            var reqHandlers = [sendRequest], resHandlers = [], handler;

            if (!isObject(context)) {
                context = null;
            }

            function Client(request) {
                return new PromiseObj(function (resolve) {

                    function exec() {

                        handler = reqHandlers.pop();

                        if (isFunction(handler)) {
                            handler.call(context, request, next);
                        } else {
                            warn(("Invalid interceptor of type " + (typeof handler) + ", must be a function"));
                            next();
                        }
                    }

                    function next(response) {

                        if (isFunction(response)) {

                            resHandlers.unshift(response);

                        } else if (isObject(response)) {

                            resHandlers.forEach(function (handler) {
                                response = when(response, function (response) {
                                    return handler.call(context, response) || response;
                                });
                            });

                            when(response, resolve);

                            return;
                        }

                        exec();
                    }

                    exec();

                }, context);
            }

            Client.use = function (handler) {
                reqHandlers.push(handler);
            };

            return Client;
        };

        function sendRequest(request, resolve) {

            var client = request.client || (inBrowser ? xhrClient : nodeClient);

            resolve(client(request));
        }

        /**
         * HTTP Headers.
         */

        var Headers = function Headers(headers) {
            var this$1 = this;


            this.map = {};

            each(headers, function (value, name) {
                return this$1.append(name, value);
            });
        };

        Headers.prototype.has = function has(name) {
            return getName(this.map, name) !== null;
        };

        Headers.prototype.get = function get(name) {

            var list = this.map[getName(this.map, name)];

            return list ? list[0] : null;
        };

        Headers.prototype.getAll = function getAll(name) {
            return this.map[getName(this.map, name)] || [];
        };

        Headers.prototype.set = function set(name, value) {
            this.map[normalizeName(getName(this.map, name) || name)] = [trim(value)];
        };

        Headers.prototype.append = function append(name, value) {

            var list = this.getAll(name);

            if (list.length) {
                list.push(trim(value));
            } else {
                this.set(name, value);
            }
        };

        Headers.prototype.delete = function delete$1(name) {
            delete this.map[getName(this.map, name)];
        };

        Headers.prototype.deleteAll = function deleteAll() {
            this.map = {};
        };

        Headers.prototype.forEach = function forEach(callback, thisArg) {
            var this$1 = this;

            each(this.map, function (list, name) {
                each(list, function (value) {
                    return callback.call(thisArg, value, name, this$1);
                });
            });
        };

        function getName(map, name) {
            return Object.keys(map).reduce(function (prev, curr) {
                return toLower(name) === toLower(curr) ? curr : prev;
            }, null);
        }

        function normalizeName(name) {

            if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
                throw new TypeError('Invalid character in header field name');
            }

            return trim(name);
        }

        /**
         * HTTP Response.
         */

        var Response = function Response(body, ref) {
            var url = ref.url;
            var headers = ref.headers;
            var status = ref.status;
            var statusText = ref.statusText;


            this.url = url;
            this.ok = status >= 200 && status < 300;
            this.status = status || 0;
            this.statusText = statusText || '';
            this.headers = new Headers(headers);
            this.body = body;

            if (isString(body)) {

                this.bodyText = body;

            } else if (isBlob(body)) {

                this.bodyBlob = body;

                if (isBlobText(body)) {
                    this.bodyText = blobText(body);
                }
            }
        };

        Response.prototype.blob = function blob() {
            return when(this.bodyBlob);
        };

        Response.prototype.text = function text() {
            return when(this.bodyText);
        };

        Response.prototype.json = function json() {
            return when(this.text(), function (text) {
                return JSON.parse(text);
            });
        };

        function blobText(body) {
            return new PromiseObj(function (resolve) {

                var reader = new FileReader();

                reader.readAsText(body);
                reader.onload = function () {
                    resolve(reader.result);
                };

            });
        }

        function isBlobText(body) {
            return body.type.indexOf('text') === 0 || body.type.indexOf('json') !== -1;
        }

        /**
         * HTTP Request.
         */

        var Request = function Request(options$$1) {

            this.body = null;
            this.params = {};

            assign(this, options$$1, {
                method: toUpper(options$$1.method || 'GET')
            });

            if (!(this.headers instanceof Headers)) {
                this.headers = new Headers(this.headers);
            }
        };

        Request.prototype.getUrl = function getUrl() {
            return Url(this);
        };

        Request.prototype.getBody = function getBody() {
            return this.body;
        };

        Request.prototype.respondWith = function respondWith(body, options$$1) {
            return new Response(body, assign(options$$1 || {}, {url: this.getUrl()}));
        };

        /**
         * Service for sending network requests.
         */

        var COMMON_HEADERS = {'Accept': 'application/json, text/plain, */*'};
        var JSON_CONTENT_TYPE = {'Content-Type': 'application/json;charset=utf-8'};

        function Http(options$$1) {

            var self = this || {}, client = Client(self.$vm);

            defaults(options$$1 || {}, self.$options, Http.options);

            Http.interceptors.forEach(function (handler) {
                client.use(handler);
            });

            return client(new Request(options$$1)).then(function (response) {

                return response.ok ? response : PromiseObj.reject(response);

            }, function (response) {

                if (response instanceof Error) {
                    error(response);
                }

                return PromiseObj.reject(response);
            });
        }

        Http.options = {};

        Http.headers = {
            put: JSON_CONTENT_TYPE,
            post: JSON_CONTENT_TYPE,
            patch: JSON_CONTENT_TYPE,
            delete: JSON_CONTENT_TYPE,
            common: COMMON_HEADERS,
            custom: {}
        };

        Http.interceptors = [before, method, body, jsonp, header, cors];

        ['get', 'delete', 'head', 'jsonp'].forEach(function (method$$1) {

            Http[method$$1] = function (url, options$$1) {
                return this(assign(options$$1 || {}, {url: url, method: method$$1}));
            };

        });

        ['post', 'put', 'patch'].forEach(function (method$$1) {

            Http[method$$1] = function (url, body$$1, options$$1) {
                return this(assign(options$$1 || {}, {url: url, method: method$$1, body: body$$1}));
            };

        });

        /**
         * Service for interacting with RESTful services.
         */

        function Resource(url, params, actions, options$$1) {

            var self = this || {}, resource = {};

            actions = assign({},
                Resource.actions,
                actions
            );

            each(actions, function (action, name) {

                action = merge({url: url, params: assign({}, params)}, options$$1, action);

                resource[name] = function () {
                    return (self.$http || Http)(opts(action, arguments));
                };
            });

            return resource;
        }

        function opts(action, args) {

            var options$$1 = assign({}, action), params = {}, body;

            switch (args.length) {

                case 2:

                    params = args[0];
                    body = args[1];

                    break;

                case 1:

                    if (/^(POST|PUT|PATCH)$/i.test(options$$1.method)) {
                        body = args[0];
                    } else {
                        params = args[0];
                    }

                    break;

                case 0:

                    break;

                default:

                    throw 'Expected up to 2 arguments [params, body], got ' + args.length + ' arguments';
            }

            options$$1.body = body;
            options$$1.params = assign({}, options$$1.params, params);

            return options$$1;
        }

        Resource.actions = {

            get: {method: 'GET'},
            save: {method: 'POST'},
            query: {method: 'GET'},
            update: {method: 'PUT'},
            remove: {method: 'DELETE'},
            delete: {method: 'DELETE'}

        };

        /**
         * Install plugin.
         */

        function plugin(Vue) {

            if (plugin.installed) {
                return;
            }

            Util(Vue);

            Vue.url = Url;
            Vue.http = Http;
            Vue.resource = Resource;
            Vue.Promise = PromiseObj;

            Object.defineProperties(Vue.prototype, {

                $url: {
                    get: function get() {
                        return options(Vue.url, this, this.$options.url);
                    }
                },

                $http: {
                    get: function get() {
                        return options(Vue.http, this, this.$options.http);
                    }
                },

                $resource: {
                    get: function get() {
                        return Vue.resource.bind(this);
                    }
                },

                $promise: {
                    get: function get() {
                        var this$1 = this;

                        return function (executor) {
                            return new Vue.Promise(executor, this$1);
                        };
                    }
                }

            });
        }

        if (typeof window !== 'undefined' && window.Vue) {
            window.Vue.use(plugin);
        }

        module.exports = plugin;


        /***/
    },
    /* 116 */
    /***/ function (module, exports, __webpack_require__) {

        "use strict";
        /* WEBPACK VAR INJECTION */
        (function (process, global) {/*!
 * Vue.js v2.1.10
 * (c) 2014-2017 Evan You
 * Released under the MIT License.
 */
            'use strict';

            /*  */

            /**
             * Convert a value to a string that is actually rendered.
             */
            function _toString(val) {
                return val == null
                    ? ''
                    : typeof val === 'object'
                        ? JSON.stringify(val, null, 2)
                        : String(val)
            }

            /**
             * Convert a input value to a number for persistence.
             * If the conversion fails, return original string.
             */
            function toNumber(val) {
                var n = parseFloat(val);
                return isNaN(n) ? val : n
            }

            /**
             * Make a map and return a function for checking if a key
             * is in that map.
             */
            function makeMap(str,
                             expectsLowerCase) {
                var map = Object.create(null);
                var list = str.split(',');
                for (var i = 0; i < list.length; i++) {
                    map[list[i]] = true;
                }
                return expectsLowerCase
                    ? function (val) {
                        return map[val.toLowerCase()];
                    }
                    : function (val) {
                        return map[val];
                    }
            }

            /**
             * Check if a tag is a built-in tag.
             */
            var isBuiltInTag = makeMap('slot,component', true);

            /**
             * Remove an item from an array
             */
            function remove$1(arr, item) {
                if (arr.length) {
                    var index = arr.indexOf(item);
                    if (index > -1) {
                        return arr.splice(index, 1)
                    }
                }
            }

            /**
             * Check whether the object has the property.
             */
            var hasOwnProperty = Object.prototype.hasOwnProperty;

            function hasOwn(obj, key) {
                return hasOwnProperty.call(obj, key)
            }

            /**
             * Check if value is primitive
             */
            function isPrimitive(value) {
                return typeof value === 'string' || typeof value === 'number'
            }

            /**
             * Create a cached version of a pure function.
             */
            function cached(fn) {
                var cache = Object.create(null);
                return (function cachedFn(str) {
                    var hit = cache[str];
                    return hit || (cache[str] = fn(str))
                })
            }

            /**
             * Camelize a hyphen-delimited string.
             */
            var camelizeRE = /-(\w)/g;
            var camelize = cached(function (str) {
                return str.replace(camelizeRE, function (_, c) {
                    return c ? c.toUpperCase() : '';
                })
            });

            /**
             * Capitalize a string.
             */
            var capitalize = cached(function (str) {
                return str.charAt(0).toUpperCase() + str.slice(1)
            });

            /**
             * Hyphenate a camelCase string.
             */
            var hyphenateRE = /([^-])([A-Z])/g;
            var hyphenate = cached(function (str) {
                return str
                    .replace(hyphenateRE, '$1-$2')
                    .replace(hyphenateRE, '$1-$2')
                    .toLowerCase()
            });

            /**
             * Simple bind, faster than native
             */
            function bind$1(fn, ctx) {
                function boundFn(a) {
                    var l = arguments.length;
                    return l
                        ? l > 1
                            ? fn.apply(ctx, arguments)
                            : fn.call(ctx, a)
                        : fn.call(ctx)
                }

                // record original fn length
                boundFn._length = fn.length;
                return boundFn
            }

            /**
             * Convert an Array-like object to a real Array.
             */
            function toArray(list, start) {
                start = start || 0;
                var i = list.length - start;
                var ret = new Array(i);
                while (i--) {
                    ret[i] = list[i + start];
                }
                return ret
            }

            /**
             * Mix properties into target object.
             */
            function extend(to, _from) {
                for (var key in _from) {
                    to[key] = _from[key];
                }
                return to
            }

            /**
             * Quick object check - this is primarily used to tell
             * Objects from primitive values when we know the value
             * is a JSON-compliant type.
             */
            function isObject(obj) {
                return obj !== null && typeof obj === 'object'
            }

            /**
             * Strict object type check. Only returns true
             * for plain JavaScript objects.
             */
            var toString = Object.prototype.toString;
            var OBJECT_STRING = '[object Object]';

            function isPlainObject(obj) {
                return toString.call(obj) === OBJECT_STRING
            }

            /**
             * Merge an Array of Objects into a single Object.
             */
            function toObject(arr) {
                var res = {};
                for (var i = 0; i < arr.length; i++) {
                    if (arr[i]) {
                        extend(res, arr[i]);
                    }
                }
                return res
            }

            /**
             * Perform no operation.
             */
            function noop() {
            }

            /**
             * Always return false.
             */
            var no = function () {
                return false;
            };

            /**
             * Return same value
             */
            var identity = function (_) {
                return _;
            };

            /**
             * Generate a static keys string from compiler modules.
             */
            function genStaticKeys(modules) {
                return modules.reduce(function (keys, m) {
                    return keys.concat(m.staticKeys || [])
                }, []).join(',')
            }

            /**
             * Check if two values are loosely equal - that is,
             * if they are plain objects, do they have the same shape?
             */
            function looseEqual(a, b) {
                var isObjectA = isObject(a);
                var isObjectB = isObject(b);
                if (isObjectA && isObjectB) {
                    return JSON.stringify(a) === JSON.stringify(b)
                } else if (!isObjectA && !isObjectB) {
                    return String(a) === String(b)
                } else {
                    return false
                }
            }

            function looseIndexOf(arr, val) {
                for (var i = 0; i < arr.length; i++) {
                    if (looseEqual(arr[i], val)) {
                        return i
                    }
                }
                return -1
            }

            /*  */

            var config = {
                /**
                 * Option merge strategies (used in core/util/options)
                 */
                optionMergeStrategies: Object.create(null),

                /**
                 * Whether to suppress warnings.
                 */
                silent: false,

                /**
                 * Whether to enable devtools
                 */
                devtools: process.env.NODE_ENV !== 'production',

                /**
                 * Error handler for watcher errors
                 */
                errorHandler: null,

                /**
                 * Ignore certain custom elements
                 */
                ignoredElements: [],

                /**
                 * Custom user key aliases for v-on
                 */
                keyCodes: Object.create(null),

                /**
                 * Check if a tag is reserved so that it cannot be registered as a
                 * component. This is platform-dependent and may be overwritten.
                 */
                isReservedTag: no,

                /**
                 * Check if a tag is an unknown element.
                 * Platform-dependent.
                 */
                isUnknownElement: no,

                /**
                 * Get the namespace of an element
                 */
                getTagNamespace: noop,

                /**
                 * Parse the real tag name for the specific platform.
                 */
                parsePlatformTagName: identity,

                /**
                 * Check if an attribute must be bound using property, e.g. value
                 * Platform-dependent.
                 */
                mustUseProp: no,

                /**
                 * List of asset types that a component can own.
                 */
                _assetTypes: [
                    'component',
                    'directive',
                    'filter'
                ],

                /**
                 * List of lifecycle hooks.
                 */
                _lifecycleHooks: [
                    'beforeCreate',
                    'created',
                    'beforeMount',
                    'mounted',
                    'beforeUpdate',
                    'updated',
                    'beforeDestroy',
                    'destroyed',
                    'activated',
                    'deactivated'
                ],

                /**
                 * Max circular updates allowed in a scheduler flush cycle.
                 */
                _maxUpdateCount: 100
            };

            /*  */

            /**
             * Check if a string starts with $ or _
             */
            function isReserved(str) {
                var c = (str + '').charCodeAt(0);
                return c === 0x24 || c === 0x5F
            }

            /**
             * Define a property.
             */
            function def(obj, key, val, enumerable) {
                Object.defineProperty(obj, key, {
                    value: val,
                    enumerable: !!enumerable,
                    writable: true,
                    configurable: true
                });
            }

            /**
             * Parse simple path.
             */
            var bailRE = /[^\w.$]/;

            function parsePath(path) {
                if (bailRE.test(path)) {
                    return
                } else {
                    var segments = path.split('.');
                    return function (obj) {
                        for (var i = 0; i < segments.length; i++) {
                            if (!obj) {
                                return
                            }
                            obj = obj[segments[i]];
                        }
                        return obj
                    }
                }
            }

            /*  */
            /* globals MutationObserver */

// can we use __proto__?
            var hasProto = '__proto__' in {};

// Browser environment sniffing
            var inBrowser = typeof window !== 'undefined';
            var UA = inBrowser && window.navigator.userAgent.toLowerCase();
            var isIE = UA && /msie|trident/.test(UA);
            var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
            var isEdge = UA && UA.indexOf('edge/') > 0;
            var isAndroid = UA && UA.indexOf('android') > 0;
            var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);

// this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV
            var _isServer;
            var isServerRendering = function () {
                if (_isServer === undefined) {
                    /* istanbul ignore if */
                    if (!inBrowser && typeof global !== 'undefined') {
                        // detect presence of vue-server-renderer and avoid
                        // Webpack shimming the process
                        _isServer = global['process'].env.VUE_ENV === 'server';
                    } else {
                        _isServer = false;
                    }
                }
                return _isServer
            };

// detect devtools
            var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

            /* istanbul ignore next */
            function isNative(Ctor) {
                return /native code/.test(Ctor.toString())
            }

            /**
             * Defer a task to execute it asynchronously.
             */
            var nextTick = (function () {
                var callbacks = [];
                var pending = false;
                var timerFunc;

                function nextTickHandler() {
                    pending = false;
                    var copies = callbacks.slice(0);
                    callbacks.length = 0;
                    for (var i = 0; i < copies.length; i++) {
                        copies[i]();
                    }
                }

                // the nextTick behavior leverages the microtask queue, which can be accessed
                // via either native Promise.then or MutationObserver.
                // MutationObserver has wider support, however it is seriously bugged in
                // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
                // completely stops working after triggering a few times... so, if native
                // Promise is available, we will use it:
                /* istanbul ignore if */
                if (typeof Promise !== 'undefined' && isNative(Promise)) {
                    var p = Promise.resolve();
                    var logError = function (err) {
                        console.error(err);
                    };
                    timerFunc = function () {
                        p.then(nextTickHandler).catch(logError);
                        // in problematic UIWebViews, Promise.then doesn't completely break, but
                        // it can get stuck in a weird state where callbacks are pushed into the
                        // microtask queue but the queue isn't being flushed, until the browser
                        // needs to do some other work, e.g. handle a timer. Therefore we can
                        // "force" the microtask queue to be flushed by adding an empty timer.
                        if (isIOS) {
                            setTimeout(noop);
                        }
                    };
                } else if (typeof MutationObserver !== 'undefined' && (
                        isNative(MutationObserver) ||
                        // PhantomJS and iOS 7.x
                        MutationObserver.toString() === '[object MutationObserverConstructor]'
                    )) {
                    // use MutationObserver where native Promise is not available,
                    // e.g. PhantomJS IE11, iOS7, Android 4.4
                    var counter = 1;
                    var observer = new MutationObserver(nextTickHandler);
                    var textNode = document.createTextNode(String(counter));
                    observer.observe(textNode, {
                        characterData: true
                    });
                    timerFunc = function () {
                        counter = (counter + 1) % 2;
                        textNode.data = String(counter);
                    };
                } else {
                    // fallback to setTimeout
                    /* istanbul ignore next */
                    timerFunc = function () {
                        setTimeout(nextTickHandler, 0);
                    };
                }

                return function queueNextTick(cb, ctx) {
                    var _resolve;
                    callbacks.push(function () {
                        if (cb) {
                            cb.call(ctx);
                        }
                        if (_resolve) {
                            _resolve(ctx);
                        }
                    });
                    if (!pending) {
                        pending = true;
                        timerFunc();
                    }
                    if (!cb && typeof Promise !== 'undefined') {
                        return new Promise(function (resolve) {
                            _resolve = resolve;
                        })
                    }
                }
            })();

            var _Set;
            /* istanbul ignore if */
            if (typeof Set !== 'undefined' && isNative(Set)) {
                // use native Set when available.
                _Set = Set;
            } else {
                // a non-standard Set polyfill that only works with primitive keys.
                _Set = (function () {
                    function Set() {
                        this.set = Object.create(null);
                    }

                    Set.prototype.has = function has(key) {
                        return this.set[key] === true
                    };
                    Set.prototype.add = function add(key) {
                        this.set[key] = true;
                    };
                    Set.prototype.clear = function clear() {
                        this.set = Object.create(null);
                    };

                    return Set;
                }());
            }

            var warn = noop;
            var formatComponentName;

            if (process.env.NODE_ENV !== 'production') {
                var hasConsole = typeof console !== 'undefined';

                warn = function (msg, vm) {
                    if (hasConsole && (!config.silent)) {
                        console.error("[Vue warn]: " + msg + " " + (
                            vm ? formatLocation(formatComponentName(vm)) : ''
                        ));
                    }
                };

                formatComponentName = function (vm) {
                    if (vm.$root === vm) {
                        return 'root instance'
                    }
                    var name = vm._isVue
                        ? vm.$options.name || vm.$options._componentTag
                        : vm.name;
                    return (
                        (name ? ("component <" + name + ">") : "anonymous component") +
                        (vm._isVue && vm.$options.__file ? (" at " + (vm.$options.__file)) : '')
                    )
                };

                var formatLocation = function (str) {
                    if (str === 'anonymous component') {
                        str += " - use the \"name\" option for better debugging messages.";
                    }
                    return ("\n(found in " + str + ")")
                };
            }

            /*  */


            var uid$1 = 0;

            /**
             * A dep is an observable that can have multiple
             * directives subscribing to it.
             */
            var Dep = function Dep() {
                this.id = uid$1++;
                this.subs = [];
            };

            Dep.prototype.addSub = function addSub(sub) {
                this.subs.push(sub);
            };

            Dep.prototype.removeSub = function removeSub(sub) {
                remove$1(this.subs, sub);
            };

            Dep.prototype.depend = function depend() {
                if (Dep.target) {
                    Dep.target.addDep(this);
                }
            };

            Dep.prototype.notify = function notify() {
                // stablize the subscriber list first
                var subs = this.subs.slice();
                for (var i = 0, l = subs.length; i < l; i++) {
                    subs[i].update();
                }
            };

// the current target watcher being evaluated.
// this is globally unique because there could be only one
// watcher being evaluated at any time.
            Dep.target = null;
            var targetStack = [];

            function pushTarget(_target) {
                if (Dep.target) {
                    targetStack.push(Dep.target);
                }
                Dep.target = _target;
            }

            function popTarget() {
                Dep.target = targetStack.pop();
            }

            /*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */

            var arrayProto = Array.prototype;
            var arrayMethods = Object.create(arrayProto);
            [
                'push',
                'pop',
                'shift',
                'unshift',
                'splice',
                'sort',
                'reverse'
            ]
                .forEach(function (method) {
                    // cache original method
                    var original = arrayProto[method];
                    def(arrayMethods, method, function mutator() {
                        var arguments$1 = arguments;

                        // avoid leaking arguments:
                        // http://jsperf.com/closure-with-arguments
                        var i = arguments.length;
                        var args = new Array(i);
                        while (i--) {
                            args[i] = arguments$1[i];
                        }
                        var result = original.apply(this, args);
                        var ob = this.__ob__;
                        var inserted;
                        switch (method) {
                            case 'push':
                                inserted = args;
                                break
                            case 'unshift':
                                inserted = args;
                                break
                            case 'splice':
                                inserted = args.slice(2);
                                break
                        }
                        if (inserted) {
                            ob.observeArray(inserted);
                        }
                        // notify change
                        ob.dep.notify();
                        return result
                    });
                });

            /*  */

            var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

            /**
             * By default, when a reactive property is set, the new value is
             * also converted to become reactive. However when passing down props,
             * we don't want to force conversion because the value may be a nested value
             * under a frozen data structure. Converting it would defeat the optimization.
             */
            var observerState = {
                shouldConvert: true,
                isSettingProps: false
            };

            /**
             * Observer class that are attached to each observed
             * object. Once attached, the observer converts target
             * object's property keys into getter/setters that
             * collect dependencies and dispatches updates.
             */
            var Observer = function Observer(value) {
                this.value = value;
                this.dep = new Dep();
                this.vmCount = 0;
                def(value, '__ob__', this);
                if (Array.isArray(value)) {
                    var augment = hasProto
                        ? protoAugment
                        : copyAugment;
                    augment(value, arrayMethods, arrayKeys);
                    this.observeArray(value);
                } else {
                    this.walk(value);
                }
            };

            /**
             * Walk through each property and convert them into
             * getter/setters. This method should only be called when
             * value type is Object.
             */
            Observer.prototype.walk = function walk(obj) {
                var keys = Object.keys(obj);
                for (var i = 0; i < keys.length; i++) {
                    defineReactive$$1(obj, keys[i], obj[keys[i]]);
                }
            };

            /**
             * Observe a list of Array items.
             */
            Observer.prototype.observeArray = function observeArray(items) {
                for (var i = 0, l = items.length; i < l; i++) {
                    observe(items[i]);
                }
            };

// helpers

            /**
             * Augment an target Object or Array by intercepting
             * the prototype chain using __proto__
             */
            function protoAugment(target, src) {
                /* eslint-disable no-proto */
                target.__proto__ = src;
                /* eslint-enable no-proto */
            }

            /**
             * Augment an target Object or Array by defining
             * hidden properties.
             */

            /* istanbul ignore next */
            function copyAugment(target, src, keys) {
                for (var i = 0, l = keys.length; i < l; i++) {
                    var key = keys[i];
                    def(target, key, src[key]);
                }
            }

            /**
             * Attempt to create an observer instance for a value,
             * returns the new observer if successfully observed,
             * or the existing observer if the value already has one.
             */
            function observe(value, asRootData) {
                if (!isObject(value)) {
                    return
                }
                var ob;
                if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
                    ob = value.__ob__;
                } else if (
                    observerState.shouldConvert &&
                    !isServerRendering() &&
                    (Array.isArray(value) || isPlainObject(value)) &&
                    Object.isExtensible(value) &&
                    !value._isVue
                ) {
                    ob = new Observer(value);
                }
                if (asRootData && ob) {
                    ob.vmCount++;
                }
                return ob
            }

            /**
             * Define a reactive property on an Object.
             */
            function defineReactive$$1(obj,
                                       key,
                                       val,
                                       customSetter) {
                var dep = new Dep();

                var property = Object.getOwnPropertyDescriptor(obj, key);
                if (property && property.configurable === false) {
                    return
                }

                // cater for pre-defined getter/setters
                var getter = property && property.get;
                var setter = property && property.set;

                var childOb = observe(val);
                Object.defineProperty(obj, key, {
                    enumerable: true,
                    configurable: true,
                    get: function reactiveGetter() {
                        var value = getter ? getter.call(obj) : val;
                        if (Dep.target) {
                            dep.depend();
                            if (childOb) {
                                childOb.dep.depend();
                            }
                            if (Array.isArray(value)) {
                                dependArray(value);
                            }
                        }
                        return value
                    },
                    set: function reactiveSetter(newVal) {
                        var value = getter ? getter.call(obj) : val;
                        /* eslint-disable no-self-compare */
                        if (newVal === value || (newVal !== newVal && value !== value)) {
                            return
                        }
                        /* eslint-enable no-self-compare */
                        if (process.env.NODE_ENV !== 'production' && customSetter) {
                            customSetter();
                        }
                        if (setter) {
                            setter.call(obj, newVal);
                        } else {
                            val = newVal;
                        }
                        childOb = observe(newVal);
                        dep.notify();
                    }
                });
            }

            /**
             * Set a property on an object. Adds the new property and
             * triggers change notification if the property doesn't
             * already exist.
             */
            function set$1(obj, key, val) {
                if (Array.isArray(obj)) {
                    obj.length = Math.max(obj.length, key);
                    obj.splice(key, 1, val);
                    return val
                }
                if (hasOwn(obj, key)) {
                    obj[key] = val;
                    return
                }
                var ob = obj.__ob__;
                if (obj._isVue || (ob && ob.vmCount)) {
                    process.env.NODE_ENV !== 'production' && warn(
                        'Avoid adding reactive properties to a Vue instance or its root $data ' +
                        'at runtime - declare it upfront in the data option.'
                    );
                    return
                }
                if (!ob) {
                    obj[key] = val;
                    return
                }
                defineReactive$$1(ob.value, key, val);
                ob.dep.notify();
                return val
            }

            /**
             * Delete a property and trigger change if necessary.
             */
            function del(obj, key) {
                var ob = obj.__ob__;
                if (obj._isVue || (ob && ob.vmCount)) {
                    process.env.NODE_ENV !== 'production' && warn(
                        'Avoid deleting properties on a Vue instance or its root $data ' +
                        '- just set it to null.'
                    );
                    return
                }
                if (!hasOwn(obj, key)) {
                    return
                }
                delete obj[key];
                if (!ob) {
                    return
                }
                ob.dep.notify();
            }

            /**
             * Collect dependencies on array elements when the array is touched, since
             * we cannot intercept array element access like property getters.
             */
            function dependArray(value) {
                for (var e = (void 0), i = 0, l = value.length; i < l; i++) {
                    e = value[i];
                    e && e.__ob__ && e.__ob__.dep.depend();
                    if (Array.isArray(e)) {
                        dependArray(e);
                    }
                }
            }

            /*  */

            /**
             * Option overwriting strategies are functions that handle
             * how to merge a parent option value and a child option
             * value into the final value.
             */
            var strats = config.optionMergeStrategies;

            /**
             * Options with restrictions
             */
            if (process.env.NODE_ENV !== 'production') {
                strats.el = strats.propsData = function (parent, child, vm, key) {
                    if (!vm) {
                        warn(
                            "option \"" + key + "\" can only be used during instance " +
                            'creation with the `new` keyword.'
                        );
                    }
                    return defaultStrat(parent, child)
                };
            }

            /**
             * Helper that recursively merges two data objects together.
             */
            function mergeData(to, from) {
                if (!from) {
                    return to
                }
                var key, toVal, fromVal;
                var keys = Object.keys(from);
                for (var i = 0; i < keys.length; i++) {
                    key = keys[i];
                    toVal = to[key];
                    fromVal = from[key];
                    if (!hasOwn(to, key)) {
                        set$1(to, key, fromVal);
                    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
                        mergeData(toVal, fromVal);
                    }
                }
                return to
            }

            /**
             * Data
             */
            strats.data = function (parentVal,
                                    childVal,
                                    vm) {
                if (!vm) {
                    // in a Vue.extend merge, both should be functions
                    if (!childVal) {
                        return parentVal
                    }
                    if (typeof childVal !== 'function') {
                        process.env.NODE_ENV !== 'production' && warn(
                            'The "data" option should be a function ' +
                            'that returns a per-instance value in component ' +
                            'definitions.',
                            vm
                        );
                        return parentVal
                    }
                    if (!parentVal) {
                        return childVal
                    }
                    // when parentVal & childVal are both present,
                    // we need to return a function that returns the
                    // merged result of both functions... no need to
                    // check if parentVal is a function here because
                    // it has to be a function to pass previous merges.
                    return function mergedDataFn() {
                        return mergeData(
                            childVal.call(this),
                            parentVal.call(this)
                        )
                    }
                } else if (parentVal || childVal) {
                    return function mergedInstanceDataFn() {
                        // instance merge
                        var instanceData = typeof childVal === 'function'
                            ? childVal.call(vm)
                            : childVal;
                        var defaultData = typeof parentVal === 'function'
                            ? parentVal.call(vm)
                            : undefined;
                        if (instanceData) {
                            return mergeData(instanceData, defaultData)
                        } else {
                            return defaultData
                        }
                    }
                }
            };

            /**
             * Hooks and param attributes are merged as arrays.
             */
            function mergeHook(parentVal,
                               childVal) {
                return childVal
                    ? parentVal
                        ? parentVal.concat(childVal)
                        : Array.isArray(childVal)
                            ? childVal
                            : [childVal]
                    : parentVal
            }

            config._lifecycleHooks.forEach(function (hook) {
                strats[hook] = mergeHook;
            });

            /**
             * Assets
             *
             * When a vm is present (instance creation), we need to do
             * a three-way merge between constructor options, instance
             * options and parent options.
             */
            function mergeAssets(parentVal, childVal) {
                var res = Object.create(parentVal || null);
                return childVal
                    ? extend(res, childVal)
                    : res
            }

            config._assetTypes.forEach(function (type) {
                strats[type + 's'] = mergeAssets;
            });

            /**
             * Watchers.
             *
             * Watchers hashes should not overwrite one
             * another, so we merge them as arrays.
             */
            strats.watch = function (parentVal, childVal) {
                /* istanbul ignore if */
                if (!childVal) {
                    return parentVal
                }
                if (!parentVal) {
                    return childVal
                }
                var ret = {};
                extend(ret, parentVal);
                for (var key in childVal) {
                    var parent = ret[key];
                    var child = childVal[key];
                    if (parent && !Array.isArray(parent)) {
                        parent = [parent];
                    }
                    ret[key] = parent
                        ? parent.concat(child)
                        : [child];
                }
                return ret
            };

            /**
             * Other object hashes.
             */
            strats.props =
                strats.methods =
                    strats.computed = function (parentVal, childVal) {
                        if (!childVal) {
                            return parentVal
                        }
                        if (!parentVal) {
                            return childVal
                        }
                        var ret = Object.create(null);
                        extend(ret, parentVal);
                        extend(ret, childVal);
                        return ret
                    };

            /**
             * Default strategy.
             */
            var defaultStrat = function (parentVal, childVal) {
                return childVal === undefined
                    ? parentVal
                    : childVal
            };

            /**
             * Validate component names
             */
            function checkComponents(options) {
                for (var key in options.components) {
                    var lower = key.toLowerCase();
                    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {
                        warn(
                            'Do not use built-in or reserved HTML elements as component ' +
                            'id: ' + key
                        );
                    }
                }
            }

            /**
             * Ensure all props option syntax are normalized into the
             * Object-based format.
             */
            function normalizeProps(options) {
                var props = options.props;
                if (!props) {
                    return
                }
                var res = {};
                var i, val, name;
                if (Array.isArray(props)) {
                    i = props.length;
                    while (i--) {
                        val = props[i];
                        if (typeof val === 'string') {
                            name = camelize(val);
                            res[name] = {type: null};
                        } else if (process.env.NODE_ENV !== 'production') {
                            warn('props must be strings when using array syntax.');
                        }
                    }
                } else if (isPlainObject(props)) {
                    for (var key in props) {
                        val = props[key];
                        name = camelize(key);
                        res[name] = isPlainObject(val)
                            ? val
                            : {type: val};
                    }
                }
                options.props = res;
            }

            /**
             * Normalize raw function directives into object format.
             */
            function normalizeDirectives(options) {
                var dirs = options.directives;
                if (dirs) {
                    for (var key in dirs) {
                        var def = dirs[key];
                        if (typeof def === 'function') {
                            dirs[key] = {bind: def, update: def};
                        }
                    }
                }
            }

            /**
             * Merge two option objects into a new one.
             * Core utility used in both instantiation and inheritance.
             */
            function mergeOptions(parent,
                                  child,
                                  vm) {
                if (process.env.NODE_ENV !== 'production') {
                    checkComponents(child);
                }
                normalizeProps(child);
                normalizeDirectives(child);
                var extendsFrom = child.extends;
                if (extendsFrom) {
                    parent = typeof extendsFrom === 'function'
                        ? mergeOptions(parent, extendsFrom.options, vm)
                        : mergeOptions(parent, extendsFrom, vm);
                }
                if (child.mixins) {
                    for (var i = 0, l = child.mixins.length; i < l; i++) {
                        var mixin = child.mixins[i];
                        if (mixin.prototype instanceof Vue$3) {
                            mixin = mixin.options;
                        }
                        parent = mergeOptions(parent, mixin, vm);
                    }
                }
                var options = {};
                var key;
                for (key in parent) {
                    mergeField(key);
                }
                for (key in child) {
                    if (!hasOwn(parent, key)) {
                        mergeField(key);
                    }
                }

                function mergeField(key) {
                    var strat = strats[key] || defaultStrat;
                    options[key] = strat(parent[key], child[key], vm, key);
                }

                return options
            }

            /**
             * Resolve an asset.
             * This function is used because child instances need access
             * to assets defined in its ancestor chain.
             */
            function resolveAsset(options,
                                  type,
                                  id,
                                  warnMissing) {
                /* istanbul ignore if */
                if (typeof id !== 'string') {
                    return
                }
                var assets = options[type];
                // check local registration variations first
                if (hasOwn(assets, id)) {
                    return assets[id]
                }
                var camelizedId = camelize(id);
                if (hasOwn(assets, camelizedId)) {
                    return assets[camelizedId]
                }
                var PascalCaseId = capitalize(camelizedId);
                if (hasOwn(assets, PascalCaseId)) {
                    return assets[PascalCaseId]
                }
                // fallback to prototype chain
                var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
                if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {
                    warn(
                        'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
                        options
                    );
                }
                return res
            }

            /*  */

            function validateProp(key,
                                  propOptions,
                                  propsData,
                                  vm) {
                var prop = propOptions[key];
                var absent = !hasOwn(propsData, key);
                var value = propsData[key];
                // handle boolean props
                if (isType(Boolean, prop.type)) {
                    if (absent && !hasOwn(prop, 'default')) {
                        value = false;
                    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {
                        value = true;
                    }
                }
                // check default value
                if (value === undefined) {
                    value = getPropDefaultValue(vm, prop, key);
                    // since the default value is a fresh copy,
                    // make sure to observe it.
                    var prevShouldConvert = observerState.shouldConvert;
                    observerState.shouldConvert = true;
                    observe(value);
                    observerState.shouldConvert = prevShouldConvert;
                }
                if (process.env.NODE_ENV !== 'production') {
                    assertProp(prop, key, value, vm, absent);
                }
                return value
            }

            /**
             * Get the default value of a prop.
             */
            function getPropDefaultValue(vm, prop, key) {
                // no default, return undefined
                if (!hasOwn(prop, 'default')) {
                    return undefined
                }
                var def = prop.default;
                // warn against non-factory defaults for Object & Array
                if (isObject(def)) {
                    process.env.NODE_ENV !== 'production' && warn(
                        'Invalid default value for prop "' + key + '": ' +
                        'Props with type Object/Array must use a factory function ' +
                        'to return the default value.',
                        vm
                    );
                }
                // the raw prop value was also undefined from previous render,
                // return previous default value to avoid unnecessary watcher trigger
                if (vm && vm.$options.propsData &&
                    vm.$options.propsData[key] === undefined &&
                    vm[key] !== undefined) {
                    return vm[key]
                }
                // call factory function for non-Function types
                return typeof def === 'function' && prop.type !== Function
                    ? def.call(vm)
                    : def
            }

            /**
             * Assert whether a prop is valid.
             */
            function assertProp(prop,
                                name,
                                value,
                                vm,
                                absent) {
                if (prop.required && absent) {
                    warn(
                        'Missing required prop: "' + name + '"',
                        vm
                    );
                    return
                }
                if (value == null && !prop.required) {
                    return
                }
                var type = prop.type;
                var valid = !type || type === true;
                var expectedTypes = [];
                if (type) {
                    if (!Array.isArray(type)) {
                        type = [type];
                    }
                    for (var i = 0; i < type.length && !valid; i++) {
                        var assertedType = assertType(value, type[i]);
                        expectedTypes.push(assertedType.expectedType || '');
                        valid = assertedType.valid;
                    }
                }
                if (!valid) {
                    warn(
                        'Invalid prop: type check failed for prop "' + name + '".' +
                        ' Expected ' + expectedTypes.map(capitalize).join(', ') +
                        ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',
                        vm
                    );
                    return
                }
                var validator = prop.validator;
                if (validator) {
                    if (!validator(value)) {
                        warn(
                            'Invalid prop: custom validator check failed for prop "' + name + '".',
                            vm
                        );
                    }
                }
            }

            /**
             * Assert the type of a value
             */
            function assertType(value, type) {
                var valid;
                var expectedType = getType(type);
                if (expectedType === 'String') {
                    valid = typeof value === (expectedType = 'string');
                } else if (expectedType === 'Number') {
                    valid = typeof value === (expectedType = 'number');
                } else if (expectedType === 'Boolean') {
                    valid = typeof value === (expectedType = 'boolean');
                } else if (expectedType === 'Function') {
                    valid = typeof value === (expectedType = 'function');
                } else if (expectedType === 'Object') {
                    valid = isPlainObject(value);
                } else if (expectedType === 'Array') {
                    valid = Array.isArray(value);
                } else {
                    valid = value instanceof type;
                }
                return {
                    valid: valid,
                    expectedType: expectedType
                }
            }

            /**
             * Use function string name to check built-in types,
             * because a simple equality check will fail when running
             * across different vms / iframes.
             */
            function getType(fn) {
                var match = fn && fn.toString().match(/^\s*function (\w+)/);
                return match && match[1]
            }

            function isType(type, fn) {
                if (!Array.isArray(fn)) {
                    return getType(fn) === getType(type)
                }
                for (var i = 0, len = fn.length; i < len; i++) {
                    if (getType(fn[i]) === getType(type)) {
                        return true
                    }
                }
                /* istanbul ignore next */
                return false
            }


            var util = Object.freeze({
                defineReactive: defineReactive$$1,
                _toString: _toString,
                toNumber: toNumber,
                makeMap: makeMap,
                isBuiltInTag: isBuiltInTag,
                remove: remove$1,
                hasOwn: hasOwn,
                isPrimitive: isPrimitive,
                cached: cached,
                camelize: camelize,
                capitalize: capitalize,
                hyphenate: hyphenate,
                bind: bind$1,
                toArray: toArray,
                extend: extend,
                isObject: isObject,
                isPlainObject: isPlainObject,
                toObject: toObject,
                noop: noop,
                no: no,
                identity: identity,
                genStaticKeys: genStaticKeys,
                looseEqual: looseEqual,
                looseIndexOf: looseIndexOf,
                isReserved: isReserved,
                def: def,
                parsePath: parsePath,
                hasProto: hasProto,
                inBrowser: inBrowser,
                UA: UA,
                isIE: isIE,
                isIE9: isIE9,
                isEdge: isEdge,
                isAndroid: isAndroid,
                isIOS: isIOS,
                isServerRendering: isServerRendering,
                devtools: devtools,
                nextTick: nextTick,
                get _Set() {
                    return _Set;
                },
                mergeOptions: mergeOptions,
                resolveAsset: resolveAsset,
                get warn() {
                    return warn;
                },
                get formatComponentName() {
                    return formatComponentName;
                },
                validateProp: validateProp
            });

            /* not type checking this file because flow doesn't play well with Proxy */

            var initProxy;

            if (process.env.NODE_ENV !== 'production') {
                var allowedGlobals = makeMap(
                    'Infinity,undefined,NaN,isFinite,isNaN,' +
                    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
                    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +
                    'require' // for Webpack/Browserify
                );

                var warnNonPresent = function (target, key) {
                    warn(
                        "Property or method \"" + key + "\" is not defined on the instance but " +
                        "referenced during render. Make sure to declare reactive data " +
                        "properties in the data option.",
                        target
                    );
                };

                var hasProxy =
                    typeof Proxy !== 'undefined' &&
                    Proxy.toString().match(/native code/);

                if (hasProxy) {
                    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');
                    config.keyCodes = new Proxy(config.keyCodes, {
                        set: function set(target, key, value) {
                            if (isBuiltInModifier(key)) {
                                warn(("Avoid overwriting built-in modifier in config.keyCodes: ." + key));
                                return false
                            } else {
                                target[key] = value;
                                return true
                            }
                        }
                    });
                }

                var hasHandler = {
                    has: function has(target, key) {
                        var has = key in target;
                        var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
                        if (!has && !isAllowed) {
                            warnNonPresent(target, key);
                        }
                        return has || !isAllowed
                    }
                };

                var getHandler = {
                    get: function get(target, key) {
                        if (typeof key === 'string' && !(key in target)) {
                            warnNonPresent(target, key);
                        }
                        return target[key]
                    }
                };

                initProxy = function initProxy(vm) {
                    if (hasProxy) {
                        // determine which proxy handler to use
                        var options = vm.$options;
                        var handlers = options.render && options.render._withStripped
                            ? getHandler
                            : hasHandler;
                        vm._renderProxy = new Proxy(vm, handlers);
                    } else {
                        vm._renderProxy = vm;
                    }
                };
            }

            /*  */

            var VNode = function VNode(tag,
                                       data,
                                       children,
                                       text,
                                       elm,
                                       context,
                                       componentOptions) {
                this.tag = tag;
                this.data = data;
                this.children = children;
                this.text = text;
                this.elm = elm;
                this.ns = undefined;
                this.context = context;
                this.functionalContext = undefined;
                this.key = data && data.key;
                this.componentOptions = componentOptions;
                this.componentInstance = undefined;
                this.parent = undefined;
                this.raw = false;
                this.isStatic = false;
                this.isRootInsert = true;
                this.isComment = false;
                this.isCloned = false;
                this.isOnce = false;
            };

            var prototypeAccessors = {child: {}};

// DEPRECATED: alias for componentInstance for backwards compat.
            /* istanbul ignore next */
            prototypeAccessors.child.get = function () {
                return this.componentInstance
            };

            Object.defineProperties(VNode.prototype, prototypeAccessors);

            var createEmptyVNode = function () {
                var node = new VNode();
                node.text = '';
                node.isComment = true;
                return node
            };

            function createTextVNode(val) {
                return new VNode(undefined, undefined, undefined, String(val))
            }

// optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.
            function cloneVNode(vnode) {
                var cloned = new VNode(
                    vnode.tag,
                    vnode.data,
                    vnode.children,
                    vnode.text,
                    vnode.elm,
                    vnode.context,
                    vnode.componentOptions
                );
                cloned.ns = vnode.ns;
                cloned.isStatic = vnode.isStatic;
                cloned.key = vnode.key;
                cloned.isCloned = true;
                return cloned
            }

            function cloneVNodes(vnodes) {
                var res = new Array(vnodes.length);
                for (var i = 0; i < vnodes.length; i++) {
                    res[i] = cloneVNode(vnodes[i]);
                }
                return res
            }

            /*  */

            var hooks = {init: init, prepatch: prepatch, insert: insert, destroy: destroy$1};
            var hooksToMerge = Object.keys(hooks);

            function createComponent(Ctor,
                                     data,
                                     context,
                                     children,
                                     tag) {
                if (!Ctor) {
                    return
                }

                var baseCtor = context.$options._base;
                if (isObject(Ctor)) {
                    Ctor = baseCtor.extend(Ctor);
                }

                if (typeof Ctor !== 'function') {
                    if (process.env.NODE_ENV !== 'production') {
                        warn(("Invalid Component definition: " + (String(Ctor))), context);
                    }
                    return
                }

                // async component
                if (!Ctor.cid) {
                    if (Ctor.resolved) {
                        Ctor = Ctor.resolved;
                    } else {
                        Ctor = resolveAsyncComponent(Ctor, baseCtor, function () {
                            // it's ok to queue this on every render because
                            // $forceUpdate is buffered by the scheduler.
                            context.$forceUpdate();
                        });
                        if (!Ctor) {
                            // return nothing if this is indeed an async component
                            // wait for the callback to trigger parent update.
                            return
                        }
                    }
                }

                // resolve constructor options in case global mixins are applied after
                // component constructor creation
                resolveConstructorOptions(Ctor);

                data = data || {};

                // extract props
                var propsData = extractProps(data, Ctor);

                // functional component
                if (Ctor.options.functional) {
                    return createFunctionalComponent(Ctor, propsData, data, context, children)
                }

                // extract listeners, since these needs to be treated as
                // child component listeners instead of DOM listeners
                var listeners = data.on;
                // replace with listeners with .native modifier
                data.on = data.nativeOn;

                if (Ctor.options.abstract) {
                    // abstract components do not keep anything
                    // other than props & listeners
                    data = {};
                }

                // merge component management hooks onto the placeholder node
                mergeHooks(data);

                // return a placeholder vnode
                var name = Ctor.options.name || tag;
                var vnode = new VNode(
                    ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
                    data, undefined, undefined, undefined, context,
                    {Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children}
                );
                return vnode
            }

            function createFunctionalComponent(Ctor,
                                               propsData,
                                               data,
                                               context,
                                               children) {
                var props = {};
                var propOptions = Ctor.options.props;
                if (propOptions) {
                    for (var key in propOptions) {
                        props[key] = validateProp(key, propOptions, propsData);
                    }
                }
                // ensure the createElement function in functional components
                // gets a unique context - this is necessary for correct named slot check
                var _context = Object.create(context);
                var h = function (a, b, c, d) {
                    return createElement(_context, a, b, c, d, true);
                };
                var vnode = Ctor.options.render.call(null, h, {
                    props: props,
                    data: data,
                    parent: context,
                    children: children,
                    slots: function () {
                        return resolveSlots(children, context);
                    }
                });
                if (vnode instanceof VNode) {
                    vnode.functionalContext = context;
                    if (data.slot) {
                        (vnode.data || (vnode.data = {})).slot = data.slot;
                    }
                }
                return vnode
            }

            function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't
                                                     parent, // activeInstance in lifecycle state
                                                     parentElm,
                                                     refElm) {
                var vnodeComponentOptions = vnode.componentOptions;
                var options = {
                    _isComponent: true,
                    parent: parent,
                    propsData: vnodeComponentOptions.propsData,
                    _componentTag: vnodeComponentOptions.tag,
                    _parentVnode: vnode,
                    _parentListeners: vnodeComponentOptions.listeners,
                    _renderChildren: vnodeComponentOptions.children,
                    _parentElm: parentElm || null,
                    _refElm: refElm || null
                };
                // check inline-template render functions
                var inlineTemplate = vnode.data.inlineTemplate;
                if (inlineTemplate) {
                    options.render = inlineTemplate.render;
                    options.staticRenderFns = inlineTemplate.staticRenderFns;
                }
                return new vnodeComponentOptions.Ctor(options)
            }

            function init(vnode,
                          hydrating,
                          parentElm,
                          refElm) {
                if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {
                    var child = vnode.componentInstance = createComponentInstanceForVnode(
                        vnode,
                        activeInstance,
                        parentElm,
                        refElm
                    );
                    child.$mount(hydrating ? vnode.elm : undefined, hydrating);
                } else if (vnode.data.keepAlive) {
                    // kept-alive components, treat as a patch
                    var mountedNode = vnode; // work around flow
                    prepatch(mountedNode, mountedNode);
                }
            }

            function prepatch(oldVnode,
                              vnode) {
                var options = vnode.componentOptions;
                var child = vnode.componentInstance = oldVnode.componentInstance;
                child._updateFromParent(
                    options.propsData, // updated props
                    options.listeners, // updated listeners
                    vnode, // new parent vnode
                    options.children // new children
                );
            }

            function insert(vnode) {
                if (!vnode.componentInstance._isMounted) {
                    vnode.componentInstance._isMounted = true;
                    callHook(vnode.componentInstance, 'mounted');
                }
                if (vnode.data.keepAlive) {
                    vnode.componentInstance._inactive = false;
                    callHook(vnode.componentInstance, 'activated');
                }
            }

            function destroy$1(vnode) {
                if (!vnode.componentInstance._isDestroyed) {
                    if (!vnode.data.keepAlive) {
                        vnode.componentInstance.$destroy();
                    } else {
                        vnode.componentInstance._inactive = true;
                        callHook(vnode.componentInstance, 'deactivated');
                    }
                }
            }

            function resolveAsyncComponent(factory,
                                           baseCtor,
                                           cb) {
                if (factory.requested) {
                    // pool callbacks
                    factory.pendingCallbacks.push(cb);
                } else {
                    factory.requested = true;
                    var cbs = factory.pendingCallbacks = [cb];
                    var sync = true;

                    var resolve = function (res) {
                        if (isObject(res)) {
                            res = baseCtor.extend(res);
                        }
                        // cache resolved
                        factory.resolved = res;
                        // invoke callbacks only if this is not a synchronous resolve
                        // (async resolves are shimmed as synchronous during SSR)
                        if (!sync) {
                            for (var i = 0, l = cbs.length; i < l; i++) {
                                cbs[i](res);
                            }
                        }
                    };

                    var reject = function (reason) {
                        process.env.NODE_ENV !== 'production' && warn(
                            "Failed to resolve async component: " + (String(factory)) +
                            (reason ? ("\nReason: " + reason) : '')
                        );
                    };

                    var res = factory(resolve, reject);

                    // handle promise
                    if (res && typeof res.then === 'function' && !factory.resolved) {
                        res.then(resolve, reject);
                    }

                    sync = false;
                    // return in case resolved synchronously
                    return factory.resolved
                }
            }

            function extractProps(data, Ctor) {
                // we are only extracting raw values here.
                // validation and default values are handled in the child
                // component itself.
                var propOptions = Ctor.options.props;
                if (!propOptions) {
                    return
                }
                var res = {};
                var attrs = data.attrs;
                var props = data.props;
                var domProps = data.domProps;
                if (attrs || props || domProps) {
                    for (var key in propOptions) {
                        var altKey = hyphenate(key);
                        checkProp(res, props, key, altKey, true) ||
                        checkProp(res, attrs, key, altKey) ||
                        checkProp(res, domProps, key, altKey);
                    }
                }
                return res
            }

            function checkProp(res,
                               hash,
                               key,
                               altKey,
                               preserve) {
                if (hash) {
                    if (hasOwn(hash, key)) {
                        res[key] = hash[key];
                        if (!preserve) {
                            delete hash[key];
                        }
                        return true
                    } else if (hasOwn(hash, altKey)) {
                        res[key] = hash[altKey];
                        if (!preserve) {
                            delete hash[altKey];
                        }
                        return true
                    }
                }
                return false
            }

            function mergeHooks(data) {
                if (!data.hook) {
                    data.hook = {};
                }
                for (var i = 0; i < hooksToMerge.length; i++) {
                    var key = hooksToMerge[i];
                    var fromParent = data.hook[key];
                    var ours = hooks[key];
                    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;
                }
            }

            function mergeHook$1(one, two) {
                return function (a, b, c, d) {
                    one(a, b, c, d);
                    two(a, b, c, d);
                }
            }

            /*  */

            function mergeVNodeHook(def, hookKey, hook, key) {
                key = key + hookKey;
                var injectedHash = def.__injected || (def.__injected = {});
                if (!injectedHash[key]) {
                    injectedHash[key] = true;
                    var oldHook = def[hookKey];
                    if (oldHook) {
                        def[hookKey] = function () {
                            oldHook.apply(this, arguments);
                            hook.apply(this, arguments);
                        };
                    } else {
                        def[hookKey] = hook;
                    }
                }
            }

            /*  */

            var normalizeEvent = cached(function (name) {
                var once = name.charAt(0) === '~'; // Prefixed last, checked first
                name = once ? name.slice(1) : name;
                var capture = name.charAt(0) === '!';
                name = capture ? name.slice(1) : name;
                return {
                    name: name,
                    once: once,
                    capture: capture
                }
            });

            function createEventHandle(fn) {
                var handle = {
                    fn: fn,
                    invoker: function () {
                        var arguments$1 = arguments;

                        var fn = handle.fn;
                        if (Array.isArray(fn)) {
                            for (var i = 0; i < fn.length; i++) {
                                fn[i].apply(null, arguments$1);
                            }
                        } else {
                            fn.apply(null, arguments);
                        }
                    }
                };
                return handle
            }

            function updateListeners(on,
                                     oldOn,
                                     add,
                                     remove$$1,
                                     vm) {
                var name, cur, old, event;
                for (name in on) {
                    cur = on[name];
                    old = oldOn[name];
                    event = normalizeEvent(name);
                    if (!cur) {
                        process.env.NODE_ENV !== 'production' && warn(
                            "Invalid handler for event \"" + (event.name) + "\": got " + String(cur),
                            vm
                        );
                    } else if (!old) {
                        if (!cur.invoker) {
                            cur = on[name] = createEventHandle(cur);
                        }
                        add(event.name, cur.invoker, event.once, event.capture);
                    } else if (cur !== old) {
                        old.fn = cur;
                        on[name] = old;
                    }
                }
                for (name in oldOn) {
                    if (!on[name]) {
                        event = normalizeEvent(name);
                        remove$$1(event.name, oldOn[name].invoker, event.capture);
                    }
                }
            }

            /*  */

// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:

// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// nomralization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
            function simpleNormalizeChildren(children) {
                for (var i = 0; i < children.length; i++) {
                    if (Array.isArray(children[i])) {
                        return Array.prototype.concat.apply([], children)
                    }
                }
                return children
            }

// 2. When the children contains constrcuts that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
            function normalizeChildren(children) {
                return isPrimitive(children)
                    ? [createTextVNode(children)]
                    : Array.isArray(children)
                        ? normalizeArrayChildren(children)
                        : undefined
            }

            function normalizeArrayChildren(children, nestedIndex) {
                var res = [];
                var i, c, last;
                for (i = 0; i < children.length; i++) {
                    c = children[i];
                    if (c == null || typeof c === 'boolean') {
                        continue
                    }
                    last = res[res.length - 1];
                    //  nested
                    if (Array.isArray(c)) {
                        res.push.apply(res, normalizeArrayChildren(c, ((nestedIndex || '') + "_" + i)));
                    } else if (isPrimitive(c)) {
                        if (last && last.text) {
                            last.text += String(c);
                        } else if (c !== '') {
                            // convert primitive to vnode
                            res.push(createTextVNode(c));
                        }
                    } else {
                        if (c.text && last && last.text) {
                            res[res.length - 1] = createTextVNode(last.text + c.text);
                        } else {
                            // default key for nested array children (likely generated by v-for)
                            if (c.tag && c.key == null && nestedIndex != null) {
                                c.key = "__vlist" + nestedIndex + "_" + i + "__";
                            }
                            res.push(c);
                        }
                    }
                }
                return res
            }

            /*  */

            function getFirstComponentChild(children) {
                return children && children.filter(function (c) {
                    return c && c.componentOptions;
                })[0]
            }

            /*  */

            var SIMPLE_NORMALIZE = 1;
            var ALWAYS_NORMALIZE = 2;

// wrapper function for providing a more flexible interface
// without getting yelled at by flow
            function createElement(context,
                                   tag,
                                   data,
                                   children,
                                   normalizationType,
                                   alwaysNormalize) {
                if (Array.isArray(data) || isPrimitive(data)) {
                    normalizationType = children;
                    children = data;
                    data = undefined;
                }
                if (alwaysNormalize) {
                    normalizationType = ALWAYS_NORMALIZE;
                }
                return _createElement(context, tag, data, children, normalizationType)
            }

            function _createElement(context,
                                    tag,
                                    data,
                                    children,
                                    normalizationType) {
                if (data && data.__ob__) {
                    process.env.NODE_ENV !== 'production' && warn(
                        "Avoid using observed data object as vnode data: " + (JSON.stringify(data)) + "\n" +
                        'Always create fresh vnode data objects in each render!',
                        context
                    );
                    return createEmptyVNode()
                }
                if (!tag) {
                    // in case of component :is set to falsy value
                    return createEmptyVNode()
                }
                // support single function children as default scoped slot
                if (Array.isArray(children) &&
                    typeof children[0] === 'function') {
                    data = data || {};
                    data.scopedSlots = {default: children[0]};
                    children.length = 0;
                }
                if (normalizationType === ALWAYS_NORMALIZE) {
                    children = normalizeChildren(children);
                } else if (normalizationType === SIMPLE_NORMALIZE) {
                    children = simpleNormalizeChildren(children);
                }
                var vnode, ns;
                if (typeof tag === 'string') {
                    var Ctor;
                    ns = config.getTagNamespace(tag);
                    if (config.isReservedTag(tag)) {
                        // platform built-in elements
                        vnode = new VNode(
                            config.parsePlatformTagName(tag), data, children,
                            undefined, undefined, context
                        );
                    } else if ((Ctor = resolveAsset(context.$options, 'components', tag))) {
                        // component
                        vnode = createComponent(Ctor, data, context, children, tag);
                    } else {
                        // unknown or unlisted namespaced elements
                        // check at runtime because it may get assigned a namespace when its
                        // parent normalizes children
                        vnode = new VNode(
                            tag, data, children,
                            undefined, undefined, context
                        );
                    }
                } else {
                    // direct component options / constructor
                    vnode = createComponent(tag, data, context, children);
                }
                if (vnode) {
                    if (ns) {
                        applyNS(vnode, ns);
                    }
                    return vnode
                } else {
                    return createEmptyVNode()
                }
            }

            function applyNS(vnode, ns) {
                vnode.ns = ns;
                if (vnode.tag === 'foreignObject') {
                    // use default namespace inside foreignObject
                    return
                }
                if (vnode.children) {
                    for (var i = 0, l = vnode.children.length; i < l; i++) {
                        var child = vnode.children[i];
                        if (child.tag && !child.ns) {
                            applyNS(child, ns);
                        }
                    }
                }
            }

            /*  */

            function initRender(vm) {
                vm.$vnode = null; // the placeholder node in parent tree
                vm._vnode = null; // the root of the child tree
                vm._staticTrees = null;
                var parentVnode = vm.$options._parentVnode;
                var renderContext = parentVnode && parentVnode.context;
                vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);
                vm.$scopedSlots = {};
                // bind the createElement fn to this instance
                // so that we get proper render context inside it.
                // args order: tag, data, children, normalizationType, alwaysNormalize
                // internal version is used by render functions compiled from templates
                vm._c = function (a, b, c, d) {
                    return createElement(vm, a, b, c, d, false);
                };
                // normalization is always applied for the public version, used in
                // user-written render functions.
                vm.$createElement = function (a, b, c, d) {
                    return createElement(vm, a, b, c, d, true);
                };
            }

            function renderMixin(Vue) {
                Vue.prototype.$nextTick = function (fn) {
                    return nextTick(fn, this)
                };

                Vue.prototype._render = function () {
                    var vm = this;
                    var ref = vm.$options;
                    var render = ref.render;
                    var staticRenderFns = ref.staticRenderFns;
                    var _parentVnode = ref._parentVnode;

                    if (vm._isMounted) {
                        // clone slot nodes on re-renders
                        for (var key in vm.$slots) {
                            vm.$slots[key] = cloneVNodes(vm.$slots[key]);
                        }
                    }

                    if (_parentVnode && _parentVnode.data.scopedSlots) {
                        vm.$scopedSlots = _parentVnode.data.scopedSlots;
                    }

                    if (staticRenderFns && !vm._staticTrees) {
                        vm._staticTrees = [];
                    }
                    // set parent vnode. this allows render functions to have access
                    // to the data on the placeholder node.
                    vm.$vnode = _parentVnode;
                    // render self
                    var vnode;
                    try {
                        vnode = render.call(vm._renderProxy, vm.$createElement);
                    } catch (e) {
                        /* istanbul ignore else */
                        if (config.errorHandler) {
                            config.errorHandler.call(null, e, vm);
                        } else {
                            if (process.env.NODE_ENV !== 'production') {
                                warn(("Error when rendering " + (formatComponentName(vm)) + ":"));
                            }
                            throw e
                        }
                        // return previous vnode to prevent render error causing blank component
                        vnode = vm._vnode;
                    }
                    // return empty vnode in case the render function errored out
                    if (!(vnode instanceof VNode)) {
                        if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {
                            warn(
                                'Multiple root nodes returned from render function. Render function ' +
                                'should return a single root node.',
                                vm
                            );
                        }
                        vnode = createEmptyVNode();
                    }
                    // set parent
                    vnode.parent = _parentVnode;
                    return vnode
                };

                // toString for mustaches
                Vue.prototype._s = _toString;
                // convert text to vnode
                Vue.prototype._v = createTextVNode;
                // number conversion
                Vue.prototype._n = toNumber;
                // empty vnode
                Vue.prototype._e = createEmptyVNode;
                // loose equal
                Vue.prototype._q = looseEqual;
                // loose indexOf
                Vue.prototype._i = looseIndexOf;

                // render static tree by index
                Vue.prototype._m = function renderStatic(index,
                                                         isInFor) {
                    var tree = this._staticTrees[index];
                    // if has already-rendered static tree and not inside v-for,
                    // we can reuse the same tree by doing a shallow clone.
                    if (tree && !isInFor) {
                        return Array.isArray(tree)
                            ? cloneVNodes(tree)
                            : cloneVNode(tree)
                    }
                    // otherwise, render a fresh tree.
                    tree = this._staticTrees[index] = this.$options.staticRenderFns[index].call(this._renderProxy);
                    markStatic(tree, ("__static__" + index), false);
                    return tree
                };

                // mark node as static (v-once)
                Vue.prototype._o = function markOnce(tree,
                                                     index,
                                                     key) {
                    markStatic(tree, ("__once__" + index + (key ? ("_" + key) : "")), true);
                    return tree
                };

                function markStatic(tree, key, isOnce) {
                    if (Array.isArray(tree)) {
                        for (var i = 0; i < tree.length; i++) {
                            if (tree[i] && typeof tree[i] !== 'string') {
                                markStaticNode(tree[i], (key + "_" + i), isOnce);
                            }
                        }
                    } else {
                        markStaticNode(tree, key, isOnce);
                    }
                }

                function markStaticNode(node, key, isOnce) {
                    node.isStatic = true;
                    node.key = key;
                    node.isOnce = isOnce;
                }

                // filter resolution helper
                Vue.prototype._f = function resolveFilter(id) {
                    return resolveAsset(this.$options, 'filters', id, true) || identity
                };

                // render v-for
                Vue.prototype._l = function renderList(val,
                                                       render) {
                    var ret, i, l, keys, key;
                    if (Array.isArray(val) || typeof val === 'string') {
                        ret = new Array(val.length);
                        for (i = 0, l = val.length; i < l; i++) {
                            ret[i] = render(val[i], i);
                        }
                    } else if (typeof val === 'number') {
                        ret = new Array(val);
                        for (i = 0; i < val; i++) {
                            ret[i] = render(i + 1, i);
                        }
                    } else if (isObject(val)) {
                        keys = Object.keys(val);
                        ret = new Array(keys.length);
                        for (i = 0, l = keys.length; i < l; i++) {
                            key = keys[i];
                            ret[i] = render(val[key], key, i);
                        }
                    }
                    return ret
                };

                // renderSlot
                Vue.prototype._t = function (name,
                                             fallback,
                                             props,
                                             bindObject) {
                    var scopedSlotFn = this.$scopedSlots[name];
                    if (scopedSlotFn) { // scoped slot
                        props = props || {};
                        if (bindObject) {
                            extend(props, bindObject);
                        }
                        return scopedSlotFn(props) || fallback
                    } else {
                        var slotNodes = this.$slots[name];
                        // warn duplicate slot usage
                        if (slotNodes && process.env.NODE_ENV !== 'production') {
                            slotNodes._rendered && warn(
                                "Duplicate presence of slot \"" + name + "\" found in the same render tree " +
                                "- this will likely cause render errors.",
                                this
                            );
                            slotNodes._rendered = true;
                        }
                        return slotNodes || fallback
                    }
                };

                // apply v-bind object
                Vue.prototype._b = function bindProps(data,
                                                      tag,
                                                      value,
                                                      asProp) {
                    if (value) {
                        if (!isObject(value)) {
                            process.env.NODE_ENV !== 'production' && warn(
                                'v-bind without argument expects an Object or Array value',
                                this
                            );
                        } else {
                            if (Array.isArray(value)) {
                                value = toObject(value);
                            }
                            for (var key in value) {
                                if (key === 'class' || key === 'style') {
                                    data[key] = value[key];
                                } else {
                                    var type = data.attrs && data.attrs.type;
                                    var hash = asProp || config.mustUseProp(tag, type, key)
                                        ? data.domProps || (data.domProps = {})
                                        : data.attrs || (data.attrs = {});
                                    hash[key] = value[key];
                                }
                            }
                        }
                    }
                    return data
                };

                // check v-on keyCodes
                Vue.prototype._k = function checkKeyCodes(eventKeyCode,
                                                          key,
                                                          builtInAlias) {
                    var keyCodes = config.keyCodes[key] || builtInAlias;
                    if (Array.isArray(keyCodes)) {
                        return keyCodes.indexOf(eventKeyCode) === -1
                    } else {
                        return keyCodes !== eventKeyCode
                    }
                };
            }

            function resolveSlots(children,
                                  context) {
                var slots = {};
                if (!children) {
                    return slots
                }
                var defaultSlot = [];
                var name, child;
                for (var i = 0, l = children.length; i < l; i++) {
                    child = children[i];
                    // named slots should only be respected if the vnode was rendered in the
                    // same context.
                    if ((child.context === context || child.functionalContext === context) &&
                        child.data && (name = child.data.slot)) {
                        var slot = (slots[name] || (slots[name] = []));
                        if (child.tag === 'template') {
                            slot.push.apply(slot, child.children);
                        } else {
                            slot.push(child);
                        }
                    } else {
                        defaultSlot.push(child);
                    }
                }
                // ignore single whitespace
                if (defaultSlot.length && !(
                        defaultSlot.length === 1 &&
                        (defaultSlot[0].text === ' ' || defaultSlot[0].isComment)
                    )) {
                    slots.default = defaultSlot;
                }
                return slots
            }

            /*  */

            function initEvents(vm) {
                vm._events = Object.create(null);
                vm._hasHookEvent = false;
                // init parent attached events
                var listeners = vm.$options._parentListeners;
                if (listeners) {
                    updateComponentListeners(vm, listeners);
                }
            }

            var target;

            function add$1(event, fn, once) {
                if (once) {
                    target.$once(event, fn);
                } else {
                    target.$on(event, fn);
                }
            }

            function remove$2(event, fn) {
                target.$off(event, fn);
            }

            function updateComponentListeners(vm,
                                              listeners,
                                              oldListeners) {
                target = vm;
                updateListeners(listeners, oldListeners || {}, add$1, remove$2, vm);
            }

            function eventsMixin(Vue) {
                var hookRE = /^hook:/;
                Vue.prototype.$on = function (event, fn) {
                    var vm = this;
                    (vm._events[event] || (vm._events[event] = [])).push(fn);
                    // optimize hook:event cost by using a boolean flag marked at registration
                    // instead of a hash lookup
                    if (hookRE.test(event)) {
                        vm._hasHookEvent = true;
                    }
                    return vm
                };

                Vue.prototype.$once = function (event, fn) {
                    var vm = this;

                    function on() {
                        vm.$off(event, on);
                        fn.apply(vm, arguments);
                    }

                    on.fn = fn;
                    vm.$on(event, on);
                    return vm
                };

                Vue.prototype.$off = function (event, fn) {
                    var vm = this;
                    // all
                    if (!arguments.length) {
                        vm._events = Object.create(null);
                        return vm
                    }
                    // specific event
                    var cbs = vm._events[event];
                    if (!cbs) {
                        return vm
                    }
                    if (arguments.length === 1) {
                        vm._events[event] = null;
                        return vm
                    }
                    // specific handler
                    var cb;
                    var i = cbs.length;
                    while (i--) {
                        cb = cbs[i];
                        if (cb === fn || cb.fn === fn) {
                            cbs.splice(i, 1);
                            break
                        }
                    }
                    return vm
                };

                Vue.prototype.$emit = function (event) {
                    var vm = this;
                    var cbs = vm._events[event];
                    if (cbs) {
                        cbs = cbs.length > 1 ? toArray(cbs) : cbs;
                        var args = toArray(arguments, 1);
                        for (var i = 0, l = cbs.length; i < l; i++) {
                            cbs[i].apply(vm, args);
                        }
                    }
                    return vm
                };
            }

            /*  */

            var activeInstance = null;

            function initLifecycle(vm) {
                var options = vm.$options;

                // locate first non-abstract parent
                var parent = options.parent;
                if (parent && !options.abstract) {
                    while (parent.$options.abstract && parent.$parent) {
                        parent = parent.$parent;
                    }
                    parent.$children.push(vm);
                }

                vm.$parent = parent;
                vm.$root = parent ? parent.$root : vm;

                vm.$children = [];
                vm.$refs = {};

                vm._watcher = null;
                vm._inactive = false;
                vm._isMounted = false;
                vm._isDestroyed = false;
                vm._isBeingDestroyed = false;
            }

            function lifecycleMixin(Vue) {
                Vue.prototype._mount = function (el,
                                                 hydrating) {
                    var vm = this;
                    vm.$el = el;
                    if (!vm.$options.render) {
                        vm.$options.render = createEmptyVNode;
                        if (process.env.NODE_ENV !== 'production') {
                            /* istanbul ignore if */
                            if (vm.$options.template && vm.$options.template.charAt(0) !== '#') {
                                warn(
                                    'You are using the runtime-only build of Vue where the template ' +
                                    'option is not available. Either pre-compile the templates into ' +
                                    'render functions, or use the compiler-included build.',
                                    vm
                                );
                            } else {
                                warn(
                                    'Failed to mount component: template or render function not defined.',
                                    vm
                                );
                            }
                        }
                    }
                    callHook(vm, 'beforeMount');
                    vm._watcher = new Watcher(vm, function updateComponent() {
                        vm._update(vm._render(), hydrating);
                    }, noop);
                    hydrating = false;
                    // manually mounted instance, call mounted on self
                    // mounted is called for render-created child components in its inserted hook
                    if (vm.$vnode == null) {
                        vm._isMounted = true;
                        callHook(vm, 'mounted');
                    }
                    return vm
                };

                Vue.prototype._update = function (vnode, hydrating) {
                    var vm = this;
                    if (vm._isMounted) {
                        callHook(vm, 'beforeUpdate');
                    }
                    var prevEl = vm.$el;
                    var prevVnode = vm._vnode;
                    var prevActiveInstance = activeInstance;
                    activeInstance = vm;
                    vm._vnode = vnode;
                    // Vue.prototype.__patch__ is injected in entry points
                    // based on the rendering backend used.
                    if (!prevVnode) {
                        // initial render
                        vm.$el = vm.__patch__(
                            vm.$el, vnode, hydrating, false /* removeOnly */,
                            vm.$options._parentElm,
                            vm.$options._refElm
                        );
                    } else {
                        // updates
                        vm.$el = vm.__patch__(prevVnode, vnode);
                    }
                    activeInstance = prevActiveInstance;
                    // update __vue__ reference
                    if (prevEl) {
                        prevEl.__vue__ = null;
                    }
                    if (vm.$el) {
                        vm.$el.__vue__ = vm;
                    }
                    // if parent is an HOC, update its $el as well
                    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
                        vm.$parent.$el = vm.$el;
                    }
                    // updated hook is called by the scheduler to ensure that children are
                    // updated in a parent's updated hook.
                };

                Vue.prototype._updateFromParent = function (propsData,
                                                            listeners,
                                                            parentVnode,
                                                            renderChildren) {
                    var vm = this;
                    var hasChildren = !!(vm.$options._renderChildren || renderChildren);
                    vm.$options._parentVnode = parentVnode;
                    vm.$vnode = parentVnode; // update vm's placeholder node without re-render
                    if (vm._vnode) { // update child tree's parent
                        vm._vnode.parent = parentVnode;
                    }
                    vm.$options._renderChildren = renderChildren;
                    // update props
                    if (propsData && vm.$options.props) {
                        observerState.shouldConvert = false;
                        if (process.env.NODE_ENV !== 'production') {
                            observerState.isSettingProps = true;
                        }
                        var propKeys = vm.$options._propKeys || [];
                        for (var i = 0; i < propKeys.length; i++) {
                            var key = propKeys[i];
                            vm[key] = validateProp(key, vm.$options.props, propsData, vm);
                        }
                        observerState.shouldConvert = true;
                        if (process.env.NODE_ENV !== 'production') {
                            observerState.isSettingProps = false;
                        }
                        vm.$options.propsData = propsData;
                    }
                    // update listeners
                    if (listeners) {
                        var oldListeners = vm.$options._parentListeners;
                        vm.$options._parentListeners = listeners;
                        updateComponentListeners(vm, listeners, oldListeners);
                    }
                    // resolve slots + force update if has children
                    if (hasChildren) {
                        vm.$slots = resolveSlots(renderChildren, parentVnode.context);
                        vm.$forceUpdate();
                    }
                };

                Vue.prototype.$forceUpdate = function () {
                    var vm = this;
                    if (vm._watcher) {
                        vm._watcher.update();
                    }
                };

                Vue.prototype.$destroy = function () {
                    var vm = this;
                    if (vm._isBeingDestroyed) {
                        return
                    }
                    callHook(vm, 'beforeDestroy');
                    vm._isBeingDestroyed = true;
                    // remove self from parent
                    var parent = vm.$parent;
                    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
                        remove$1(parent.$children, vm);
                    }
                    // teardown watchers
                    if (vm._watcher) {
                        vm._watcher.teardown();
                    }
                    var i = vm._watchers.length;
                    while (i--) {
                        vm._watchers[i].teardown();
                    }
                    // remove reference from data ob
                    // frozen object may not have observer.
                    if (vm._data.__ob__) {
                        vm._data.__ob__.vmCount--;
                    }
                    // call the last hook...
                    vm._isDestroyed = true;
                    callHook(vm, 'destroyed');
                    // turn off all instance listeners.
                    vm.$off();
                    // remove __vue__ reference
                    if (vm.$el) {
                        vm.$el.__vue__ = null;
                    }
                    // invoke destroy hooks on current rendered tree
                    vm.__patch__(vm._vnode, null);
                };
            }

            function callHook(vm, hook) {
                var handlers = vm.$options[hook];
                if (handlers) {
                    for (var i = 0, j = handlers.length; i < j; i++) {
                        handlers[i].call(vm);
                    }
                }
                if (vm._hasHookEvent) {
                    vm.$emit('hook:' + hook);
                }
            }

            /*  */


            var queue = [];
            var has$1 = {};
            var circular = {};
            var waiting = false;
            var flushing = false;
            var index = 0;

            /**
             * Reset the scheduler's state.
             */
            function resetSchedulerState() {
                queue.length = 0;
                has$1 = {};
                if (process.env.NODE_ENV !== 'production') {
                    circular = {};
                }
                waiting = flushing = false;
            }

            /**
             * Flush both queues and run the watchers.
             */
            function flushSchedulerQueue() {
                flushing = true;
                var watcher, id, vm;

                // Sort queue before flush.
                // This ensures that:
                // 1. Components are updated from parent to child. (because parent is always
                //    created before the child)
                // 2. A component's user watchers are run before its render watcher (because
                //    user watchers are created before the render watcher)
                // 3. If a component is destroyed during a parent component's watcher run,
                //    its watchers can be skipped.
                queue.sort(function (a, b) {
                    return a.id - b.id;
                });

                // do not cache length because more watchers might be pushed
                // as we run existing watchers
                for (index = 0; index < queue.length; index++) {
                    watcher = queue[index];
                    id = watcher.id;
                    has$1[id] = null;
                    watcher.run();
                    // in dev build, check and stop circular updates.
                    if (process.env.NODE_ENV !== 'production' && has$1[id] != null) {
                        circular[id] = (circular[id] || 0) + 1;
                        if (circular[id] > config._maxUpdateCount) {
                            warn(
                                'You may have an infinite update loop ' + (
                                    watcher.user
                                        ? ("in watcher with expression \"" + (watcher.expression) + "\"")
                                        : "in a component render function."
                                ),
                                watcher.vm
                            );
                            break
                        }
                    }
                }

                // call updated hooks
                index = queue.length;
                while (index--) {
                    watcher = queue[index];
                    vm = watcher.vm;
                    if (vm._watcher === watcher && vm._isMounted) {
                        callHook(vm, 'updated');
                    }
                }

                // devtool hook
                /* istanbul ignore if */
                if (devtools && config.devtools) {
                    devtools.emit('flush');
                }

                resetSchedulerState();
            }

            /**
             * Push a watcher into the watcher queue.
             * Jobs with duplicate IDs will be skipped unless it's
             * pushed when the queue is being flushed.
             */
            function queueWatcher(watcher) {
                var id = watcher.id;
                if (has$1[id] == null) {
                    has$1[id] = true;
                    if (!flushing) {
                        queue.push(watcher);
                    } else {
                        // if already flushing, splice the watcher based on its id
                        // if already past its id, it will be run next immediately.
                        var i = queue.length - 1;
                        while (i >= 0 && queue[i].id > watcher.id) {
                            i--;
                        }
                        queue.splice(Math.max(i, index) + 1, 0, watcher);
                    }
                    // queue the flush
                    if (!waiting) {
                        waiting = true;
                        nextTick(flushSchedulerQueue);
                    }
                }
            }

            /*  */

            var uid$2 = 0;

            /**
             * A watcher parses an expression, collects dependencies,
             * and fires callback when the expression value changes.
             * This is used for both the $watch() api and directives.
             */
            var Watcher = function Watcher(vm,
                                           expOrFn,
                                           cb,
                                           options) {
                this.vm = vm;
                vm._watchers.push(this);
                // options
                if (options) {
                    this.deep = !!options.deep;
                    this.user = !!options.user;
                    this.lazy = !!options.lazy;
                    this.sync = !!options.sync;
                } else {
                    this.deep = this.user = this.lazy = this.sync = false;
                }
                this.cb = cb;
                this.id = ++uid$2; // uid for batching
                this.active = true;
                this.dirty = this.lazy; // for lazy watchers
                this.deps = [];
                this.newDeps = [];
                this.depIds = new _Set();
                this.newDepIds = new _Set();
                this.expression = process.env.NODE_ENV !== 'production'
                    ? expOrFn.toString()
                    : '';
                // parse expression for getter
                if (typeof expOrFn === 'function') {
                    this.getter = expOrFn;
                } else {
                    this.getter = parsePath(expOrFn);
                    if (!this.getter) {
                        this.getter = function () {
                        };
                        process.env.NODE_ENV !== 'production' && warn(
                            "Failed watching path: \"" + expOrFn + "\" " +
                            'Watcher only accepts simple dot-delimited paths. ' +
                            'For full control, use a function instead.',
                            vm
                        );
                    }
                }
                this.value = this.lazy
                    ? undefined
                    : this.get();
            };

            /**
             * Evaluate the getter, and re-collect dependencies.
             */
            Watcher.prototype.get = function get() {
                pushTarget(this);
                var value = this.getter.call(this.vm, this.vm);
                // "touch" every property so they are all tracked as
                // dependencies for deep watching
                if (this.deep) {
                    traverse(value);
                }
                popTarget();
                this.cleanupDeps();
                return value
            };

            /**
             * Add a dependency to this directive.
             */
            Watcher.prototype.addDep = function addDep(dep) {
                var id = dep.id;
                if (!this.newDepIds.has(id)) {
                    this.newDepIds.add(id);
                    this.newDeps.push(dep);
                    if (!this.depIds.has(id)) {
                        dep.addSub(this);
                    }
                }
            };

            /**
             * Clean up for dependency collection.
             */
            Watcher.prototype.cleanupDeps = function cleanupDeps() {
                var this$1 = this;

                var i = this.deps.length;
                while (i--) {
                    var dep = this$1.deps[i];
                    if (!this$1.newDepIds.has(dep.id)) {
                        dep.removeSub(this$1);
                    }
                }
                var tmp = this.depIds;
                this.depIds = this.newDepIds;
                this.newDepIds = tmp;
                this.newDepIds.clear();
                tmp = this.deps;
                this.deps = this.newDeps;
                this.newDeps = tmp;
                this.newDeps.length = 0;
            };

            /**
             * Subscriber interface.
             * Will be called when a dependency changes.
             */
            Watcher.prototype.update = function update() {
                /* istanbul ignore else */
                if (this.lazy) {
                    this.dirty = true;
                } else if (this.sync) {
                    this.run();
                } else {
                    queueWatcher(this);
                }
            };

            /**
             * Scheduler job interface.
             * Will be called by the scheduler.
             */
            Watcher.prototype.run = function run() {
                if (this.active) {
                    var value = this.get();
                    if (
                        value !== this.value ||
                        // Deep watchers and watchers on Object/Arrays should fire even
                        // when the value is the same, because the value may
                        // have mutated.
                        isObject(value) ||
                        this.deep
                    ) {
                        // set new value
                        var oldValue = this.value;
                        this.value = value;
                        if (this.user) {
                            try {
                                this.cb.call(this.vm, value, oldValue);
                            } catch (e) {
                                /* istanbul ignore else */
                                if (config.errorHandler) {
                                    config.errorHandler.call(null, e, this.vm);
                                } else {
                                    process.env.NODE_ENV !== 'production' && warn(
                                        ("Error in watcher \"" + (this.expression) + "\""),
                                        this.vm
                                    );
                                    throw e
                                }
                            }
                        } else {
                            this.cb.call(this.vm, value, oldValue);
                        }
                    }
                }
            };

            /**
             * Evaluate the value of the watcher.
             * This only gets called for lazy watchers.
             */
            Watcher.prototype.evaluate = function evaluate() {
                this.value = this.get();
                this.dirty = false;
            };

            /**
             * Depend on all deps collected by this watcher.
             */
            Watcher.prototype.depend = function depend() {
                var this$1 = this;

                var i = this.deps.length;
                while (i--) {
                    this$1.deps[i].depend();
                }
            };

            /**
             * Remove self from all dependencies' subscriber list.
             */
            Watcher.prototype.teardown = function teardown() {
                var this$1 = this;

                if (this.active) {
                    // remove self from vm's watcher list
                    // this is a somewhat expensive operation so we skip it
                    // if the vm is being destroyed.
                    if (!this.vm._isBeingDestroyed) {
                        remove$1(this.vm._watchers, this);
                    }
                    var i = this.deps.length;
                    while (i--) {
                        this$1.deps[i].removeSub(this$1);
                    }
                    this.active = false;
                }
            };

            /**
             * Recursively traverse an object to evoke all converted
             * getters, so that every nested property inside the object
             * is collected as a "deep" dependency.
             */
            var seenObjects = new _Set();

            function traverse(val) {
                seenObjects.clear();
                _traverse(val, seenObjects);
            }

            function _traverse(val, seen) {
                var i, keys;
                var isA = Array.isArray(val);
                if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {
                    return
                }
                if (val.__ob__) {
                    var depId = val.__ob__.dep.id;
                    if (seen.has(depId)) {
                        return
                    }
                    seen.add(depId);
                }
                if (isA) {
                    i = val.length;
                    while (i--) {
                        _traverse(val[i], seen);
                    }
                } else {
                    keys = Object.keys(val);
                    i = keys.length;
                    while (i--) {
                        _traverse(val[keys[i]], seen);
                    }
                }
            }

            /*  */

            function initState(vm) {
                vm._watchers = [];
                var opts = vm.$options;
                if (opts.props) {
                    initProps(vm, opts.props);
                }
                if (opts.methods) {
                    initMethods(vm, opts.methods);
                }
                if (opts.data) {
                    initData(vm);
                } else {
                    observe(vm._data = {}, true /* asRootData */);
                }
                if (opts.computed) {
                    initComputed(vm, opts.computed);
                }
                if (opts.watch) {
                    initWatch(vm, opts.watch);
                }
            }

            var isReservedProp = {key: 1, ref: 1, slot: 1};

            function initProps(vm, props) {
                var propsData = vm.$options.propsData || {};
                var keys = vm.$options._propKeys = Object.keys(props);
                var isRoot = !vm.$parent;
                // root instance props should be converted
                observerState.shouldConvert = isRoot;
                var loop = function (i) {
                    var key = keys[i];
                    /* istanbul ignore else */
                    if (process.env.NODE_ENV !== 'production') {
                        if (isReservedProp[key]) {
                            warn(
                                ("\"" + key + "\" is a reserved attribute and cannot be used as component prop."),
                                vm
                            );
                        }
                        defineReactive$$1(vm, key, validateProp(key, props, propsData, vm), function () {
                            if (vm.$parent && !observerState.isSettingProps) {
                                warn(
                                    "Avoid mutating a prop directly since the value will be " +
                                    "overwritten whenever the parent component re-renders. " +
                                    "Instead, use a data or computed property based on the prop's " +
                                    "value. Prop being mutated: \"" + key + "\"",
                                    vm
                                );
                            }
                        });
                    } else {
                        defineReactive$$1(vm, key, validateProp(key, props, propsData, vm));
                    }
                };

                for (var i = 0; i < keys.length; i++) loop(i);
                observerState.shouldConvert = true;
            }

            function initData(vm) {
                var data = vm.$options.data;
                data = vm._data = typeof data === 'function'
                    ? data.call(vm)
                    : data || {};
                if (!isPlainObject(data)) {
                    data = {};
                    process.env.NODE_ENV !== 'production' && warn(
                        'data functions should return an object:\n' +
                        'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
                        vm
                    );
                }
                // proxy data on instance
                var keys = Object.keys(data);
                var props = vm.$options.props;
                var i = keys.length;
                while (i--) {
                    if (props && hasOwn(props, keys[i])) {
                        process.env.NODE_ENV !== 'production' && warn(
                            "The data property \"" + (keys[i]) + "\" is already declared as a prop. " +
                            "Use prop default value instead.",
                            vm
                        );
                    } else {
                        proxy(vm, keys[i]);
                    }
                }
                // observe data
                observe(data, true /* asRootData */);
            }

            var computedSharedDefinition = {
                enumerable: true,
                configurable: true,
                get: noop,
                set: noop
            };

            function initComputed(vm, computed) {
                for (var key in computed) {
                    /* istanbul ignore if */
                    if (process.env.NODE_ENV !== 'production' && key in vm) {
                        warn(
                            "existing instance property \"" + key + "\" will be " +
                            "overwritten by a computed property with the same name.",
                            vm
                        );
                    }
                    var userDef = computed[key];
                    if (typeof userDef === 'function') {
                        computedSharedDefinition.get = makeComputedGetter(userDef, vm);
                        computedSharedDefinition.set = noop;
                    } else {
                        computedSharedDefinition.get = userDef.get
                            ? userDef.cache !== false
                                ? makeComputedGetter(userDef.get, vm)
                                : bind$1(userDef.get, vm)
                            : noop;
                        computedSharedDefinition.set = userDef.set
                            ? bind$1(userDef.set, vm)
                            : noop;
                    }
                    Object.defineProperty(vm, key, computedSharedDefinition);
                }
            }

            function makeComputedGetter(getter, owner) {
                var watcher = new Watcher(owner, getter, noop, {
                    lazy: true
                });
                return function computedGetter() {
                    if (watcher.dirty) {
                        watcher.evaluate();
                    }
                    if (Dep.target) {
                        watcher.depend();
                    }
                    return watcher.value
                }
            }

            function initMethods(vm, methods) {
                for (var key in methods) {
                    vm[key] = methods[key] == null ? noop : bind$1(methods[key], vm);
                    if (process.env.NODE_ENV !== 'production' && methods[key] == null) {
                        warn(
                            "method \"" + key + "\" has an undefined value in the component definition. " +
                            "Did you reference the function correctly?",
                            vm
                        );
                    }
                }
            }

            function initWatch(vm, watch) {
                for (var key in watch) {
                    var handler = watch[key];
                    if (Array.isArray(handler)) {
                        for (var i = 0; i < handler.length; i++) {
                            createWatcher(vm, key, handler[i]);
                        }
                    } else {
                        createWatcher(vm, key, handler);
                    }
                }
            }

            function createWatcher(vm, key, handler) {
                var options;
                if (isPlainObject(handler)) {
                    options = handler;
                    handler = handler.handler;
                }
                if (typeof handler === 'string') {
                    handler = vm[handler];
                }
                vm.$watch(key, handler, options);
            }

            function stateMixin(Vue) {
                // flow somehow has problems with directly declared definition object
                // when using Object.defineProperty, so we have to procedurally build up
                // the object here.
                var dataDef = {};
                dataDef.get = function () {
                    return this._data
                };
                if (process.env.NODE_ENV !== 'production') {
                    dataDef.set = function (newData) {
                        warn(
                            'Avoid replacing instance root $data. ' +
                            'Use nested data properties instead.',
                            this
                        );
                    };
                }
                Object.defineProperty(Vue.prototype, '$data', dataDef);

                Vue.prototype.$set = set$1;
                Vue.prototype.$delete = del;

                Vue.prototype.$watch = function (expOrFn,
                                                 cb,
                                                 options) {
                    var vm = this;
                    options = options || {};
                    options.user = true;
                    var watcher = new Watcher(vm, expOrFn, cb, options);
                    if (options.immediate) {
                        cb.call(vm, watcher.value);
                    }
                    return function unwatchFn() {
                        watcher.teardown();
                    }
                };
            }

            function proxy(vm, key) {
                if (!isReserved(key)) {
                    Object.defineProperty(vm, key, {
                        configurable: true,
                        enumerable: true,
                        get: function proxyGetter() {
                            return vm._data[key]
                        },
                        set: function proxySetter(val) {
                            vm._data[key] = val;
                        }
                    });
                }
            }

            /*  */

            var uid = 0;

            function initMixin(Vue) {
                Vue.prototype._init = function (options) {
                    var vm = this;
                    // a uid
                    vm._uid = uid++;
                    // a flag to avoid this being observed
                    vm._isVue = true;
                    // merge options
                    if (options && options._isComponent) {
                        // optimize internal component instantiation
                        // since dynamic options merging is pretty slow, and none of the
                        // internal component options needs special treatment.
                        initInternalComponent(vm, options);
                    } else {
                        vm.$options = mergeOptions(
                            resolveConstructorOptions(vm.constructor),
                            options || {},
                            vm
                        );
                    }
                    /* istanbul ignore else */
                    if (process.env.NODE_ENV !== 'production') {
                        initProxy(vm);
                    } else {
                        vm._renderProxy = vm;
                    }
                    // expose real self
                    vm._self = vm;
                    initLifecycle(vm);
                    initEvents(vm);
                    initRender(vm);
                    callHook(vm, 'beforeCreate');
                    initState(vm);
                    callHook(vm, 'created');
                    if (vm.$options.el) {
                        vm.$mount(vm.$options.el);
                    }
                };
            }

            function initInternalComponent(vm, options) {
                var opts = vm.$options = Object.create(vm.constructor.options);
                // doing this because it's faster than dynamic enumeration.
                opts.parent = options.parent;
                opts.propsData = options.propsData;
                opts._parentVnode = options._parentVnode;
                opts._parentListeners = options._parentListeners;
                opts._renderChildren = options._renderChildren;
                opts._componentTag = options._componentTag;
                opts._parentElm = options._parentElm;
                opts._refElm = options._refElm;
                if (options.render) {
                    opts.render = options.render;
                    opts.staticRenderFns = options.staticRenderFns;
                }
            }

            function resolveConstructorOptions(Ctor) {
                var options = Ctor.options;
                if (Ctor.super) {
                    var superOptions = Ctor.super.options;
                    var cachedSuperOptions = Ctor.superOptions;
                    var extendOptions = Ctor.extendOptions;
                    if (superOptions !== cachedSuperOptions) {
                        // super option changed
                        Ctor.superOptions = superOptions;
                        extendOptions.render = options.render;
                        extendOptions.staticRenderFns = options.staticRenderFns;
                        extendOptions._scopeId = options._scopeId;
                        options = Ctor.options = mergeOptions(superOptions, extendOptions);
                        if (options.name) {
                            options.components[options.name] = Ctor;
                        }
                    }
                }
                return options
            }

            function Vue$3(options) {
                if (process.env.NODE_ENV !== 'production' &&
                    !(this instanceof Vue$3)) {
                    warn('Vue is a constructor and should be called with the `new` keyword');
                }
                this._init(options);
            }

            initMixin(Vue$3);
            stateMixin(Vue$3);
            eventsMixin(Vue$3);
            lifecycleMixin(Vue$3);
            renderMixin(Vue$3);

            /*  */

            function initUse(Vue) {
                Vue.use = function (plugin) {
                    /* istanbul ignore if */
                    if (plugin.installed) {
                        return
                    }
                    // additional parameters
                    var args = toArray(arguments, 1);
                    args.unshift(this);
                    if (typeof plugin.install === 'function') {
                        plugin.install.apply(plugin, args);
                    } else {
                        plugin.apply(null, args);
                    }
                    plugin.installed = true;
                    return this
                };
            }

            /*  */

            function initMixin$1(Vue) {
                Vue.mixin = function (mixin) {
                    this.options = mergeOptions(this.options, mixin);
                };
            }

            /*  */

            function initExtend(Vue) {
                /**
                 * Each instance constructor, including Vue, has a unique
                 * cid. This enables us to create wrapped "child
                 * constructors" for prototypal inheritance and cache them.
                 */
                Vue.cid = 0;
                var cid = 1;

                /**
                 * Class inheritance
                 */
                Vue.extend = function (extendOptions) {
                    extendOptions = extendOptions || {};
                    var Super = this;
                    var SuperId = Super.cid;
                    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
                    if (cachedCtors[SuperId]) {
                        return cachedCtors[SuperId]
                    }
                    var name = extendOptions.name || Super.options.name;
                    if (process.env.NODE_ENV !== 'production') {
                        if (!/^[a-zA-Z][\w-]*$/.test(name)) {
                            warn(
                                'Invalid component name: "' + name + '". Component names ' +
                                'can only contain alphanumeric characters and the hyphen, ' +
                                'and must start with a letter.'
                            );
                        }
                    }
                    var Sub = function VueComponent(options) {
                        this._init(options);
                    };
                    Sub.prototype = Object.create(Super.prototype);
                    Sub.prototype.constructor = Sub;
                    Sub.cid = cid++;
                    Sub.options = mergeOptions(
                        Super.options,
                        extendOptions
                    );
                    Sub['super'] = Super;
                    // allow further extension/mixin/plugin usage
                    Sub.extend = Super.extend;
                    Sub.mixin = Super.mixin;
                    Sub.use = Super.use;
                    // create asset registers, so extended classes
                    // can have their private assets too.
                    config._assetTypes.forEach(function (type) {
                        Sub[type] = Super[type];
                    });
                    // enable recursive self-lookup
                    if (name) {
                        Sub.options.components[name] = Sub;
                    }
                    // keep a reference to the super options at extension time.
                    // later at instantiation we can check if Super's options have
                    // been updated.
                    Sub.superOptions = Super.options;
                    Sub.extendOptions = extendOptions;
                    // cache constructor
                    cachedCtors[SuperId] = Sub;
                    return Sub
                };
            }

            /*  */

            function initAssetRegisters(Vue) {
                /**
                 * Create asset registration methods.
                 */
                config._assetTypes.forEach(function (type) {
                    Vue[type] = function (id,
                                          definition) {
                        if (!definition) {
                            return this.options[type + 's'][id]
                        } else {
                            /* istanbul ignore if */
                            if (process.env.NODE_ENV !== 'production') {
                                if (type === 'component' && config.isReservedTag(id)) {
                                    warn(
                                        'Do not use built-in or reserved HTML elements as component ' +
                                        'id: ' + id
                                    );
                                }
                            }
                            if (type === 'component' && isPlainObject(definition)) {
                                definition.name = definition.name || id;
                                definition = this.options._base.extend(definition);
                            }
                            if (type === 'directive' && typeof definition === 'function') {
                                definition = {bind: definition, update: definition};
                            }
                            this.options[type + 's'][id] = definition;
                            return definition
                        }
                    };
                });
            }

            /*  */

            var patternTypes = [String, RegExp];

            function getComponentName(opts) {
                return opts && (opts.Ctor.options.name || opts.tag)
            }

            function matches(pattern, name) {
                if (typeof pattern === 'string') {
                    return pattern.split(',').indexOf(name) > -1
                } else {
                    return pattern.test(name)
                }
            }

            function pruneCache(cache, filter) {
                for (var key in cache) {
                    var cachedNode = cache[key];
                    if (cachedNode) {
                        var name = getComponentName(cachedNode.componentOptions);
                        if (name && !filter(name)) {
                            pruneCacheEntry(cachedNode);
                            cache[key] = null;
                        }
                    }
                }
            }

            function pruneCacheEntry(vnode) {
                if (vnode) {
                    if (!vnode.componentInstance._inactive) {
                        callHook(vnode.componentInstance, 'deactivated');
                    }
                    vnode.componentInstance.$destroy();
                }
            }

            var KeepAlive = {
                name: 'keep-alive',
                abstract: true,

                props: {
                    include: patternTypes,
                    exclude: patternTypes
                },

                created: function created() {
                    this.cache = Object.create(null);
                },

                destroyed: function destroyed() {
                    var this$1 = this;

                    for (var key in this.cache) {
                        pruneCacheEntry(this$1.cache[key]);
                    }
                },

                watch: {
                    include: function include(val) {
                        pruneCache(this.cache, function (name) {
                            return matches(val, name);
                        });
                    },
                    exclude: function exclude(val) {
                        pruneCache(this.cache, function (name) {
                            return !matches(val, name);
                        });
                    }
                },

                render: function render() {
                    var vnode = getFirstComponentChild(this.$slots.default);
                    var componentOptions = vnode && vnode.componentOptions;
                    if (componentOptions) {
                        // check pattern
                        var name = getComponentName(componentOptions);
                        if (name && (
                                (this.include && !matches(this.include, name)) ||
                                (this.exclude && matches(this.exclude, name))
                            )) {
                            return vnode
                        }
                        var key = vnode.key == null
                            // same constructor may get registered as different local components
                            // so cid alone is not enough (#3269)
                            ? componentOptions.Ctor.cid + (componentOptions.tag ? ("::" + (componentOptions.tag)) : '')
                            : vnode.key;
                        if (this.cache[key]) {
                            vnode.componentInstance = this.cache[key].componentInstance;
                        } else {
                            this.cache[key] = vnode;
                        }
                        vnode.data.keepAlive = true;
                    }
                    return vnode
                }
            };

            var builtInComponents = {
                KeepAlive: KeepAlive
            };

            /*  */

            function initGlobalAPI(Vue) {
                // config
                var configDef = {};
                configDef.get = function () {
                    return config;
                };
                if (process.env.NODE_ENV !== 'production') {
                    configDef.set = function () {
                        warn(
                            'Do not replace the Vue.config object, set individual fields instead.'
                        );
                    };
                }
                Object.defineProperty(Vue, 'config', configDef);
                Vue.util = util;
                Vue.set = set$1;
                Vue.delete = del;
                Vue.nextTick = nextTick;

                Vue.options = Object.create(null);
                config._assetTypes.forEach(function (type) {
                    Vue.options[type + 's'] = Object.create(null);
                });

                // this is used to identify the "base" constructor to extend all plain-object
                // components with in Weex's multi-instance scenarios.
                Vue.options._base = Vue;

                extend(Vue.options.components, builtInComponents);

                initUse(Vue);
                initMixin$1(Vue);
                initExtend(Vue);
                initAssetRegisters(Vue);
            }

            initGlobalAPI(Vue$3);

            Object.defineProperty(Vue$3.prototype, '$isServer', {
                get: isServerRendering
            });

            Vue$3.version = '2.1.10';

            /*  */

// attributes that should be using props for binding
            var acceptValue = makeMap('input,textarea,option,select');
            var mustUseProp = function (tag, type, attr) {
                return (
                    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||
                    (attr === 'selected' && tag === 'option') ||
                    (attr === 'checked' && tag === 'input') ||
                    (attr === 'muted' && tag === 'video')
                )
            };

            var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

            var isBooleanAttr = makeMap(
                'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
                'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
                'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
                'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
                'required,reversed,scoped,seamless,selected,sortable,translate,' +
                'truespeed,typemustmatch,visible'
            );

            var xlinkNS = 'http://www.w3.org/1999/xlink';

            var isXlink = function (name) {
                return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'
            };

            var getXlinkProp = function (name) {
                return isXlink(name) ? name.slice(6, name.length) : ''
            };

            var isFalsyAttrValue = function (val) {
                return val == null || val === false
            };

            /*  */

            function genClassForVnode(vnode) {
                var data = vnode.data;
                var parentNode = vnode;
                var childNode = vnode;
                while (childNode.componentInstance) {
                    childNode = childNode.componentInstance._vnode;
                    if (childNode.data) {
                        data = mergeClassData(childNode.data, data);
                    }
                }
                while ((parentNode = parentNode.parent)) {
                    if (parentNode.data) {
                        data = mergeClassData(data, parentNode.data);
                    }
                }
                return genClassFromData(data)
            }

            function mergeClassData(child, parent) {
                return {
                    staticClass: concat(child.staticClass, parent.staticClass),
                    class: child.class
                        ? [child.class, parent.class]
                        : parent.class
                }
            }

            function genClassFromData(data) {
                var dynamicClass = data.class;
                var staticClass = data.staticClass;
                if (staticClass || dynamicClass) {
                    return concat(staticClass, stringifyClass(dynamicClass))
                }
                /* istanbul ignore next */
                return ''
            }

            function concat(a, b) {
                return a ? b ? (a + ' ' + b) : a : (b || '')
            }

            function stringifyClass(value) {
                var res = '';
                if (!value) {
                    return res
                }
                if (typeof value === 'string') {
                    return value
                }
                if (Array.isArray(value)) {
                    var stringified;
                    for (var i = 0, l = value.length; i < l; i++) {
                        if (value[i]) {
                            if ((stringified = stringifyClass(value[i]))) {
                                res += stringified + ' ';
                            }
                        }
                    }
                    return res.slice(0, -1)
                }
                if (isObject(value)) {
                    for (var key in value) {
                        if (value[key]) {
                            res += key + ' ';
                        }
                    }
                    return res.slice(0, -1)
                }
                /* istanbul ignore next */
                return res
            }

            /*  */

            var namespaceMap = {
                svg: 'http://www.w3.org/2000/svg',
                math: 'http://www.w3.org/1998/Math/MathML'
            };

            var isHTMLTag = makeMap(
                'html,body,base,head,link,meta,style,title,' +
                'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
                'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' +
                'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
                's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
                'embed,object,param,source,canvas,script,noscript,del,ins,' +
                'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
                'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
                'output,progress,select,textarea,' +
                'details,dialog,menu,menuitem,summary,' +
                'content,element,shadow,template'
            );

// this map is intentionally selective, only covering SVG elements that may
// contain child elements.
            var isSVG = makeMap(
                'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,' +
                'font-face,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
                'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',
                true
            );

            var isPreTag = function (tag) {
                return tag === 'pre';
            };

            var isReservedTag = function (tag) {
                return isHTMLTag(tag) || isSVG(tag)
            };

            function getTagNamespace(tag) {
                if (isSVG(tag)) {
                    return 'svg'
                }
                // basic support for MathML
                // note it doesn't support other MathML elements being component roots
                if (tag === 'math') {
                    return 'math'
                }
            }

            var unknownElementCache = Object.create(null);

            function isUnknownElement(tag) {
                /* istanbul ignore if */
                if (!inBrowser) {
                    return true
                }
                if (isReservedTag(tag)) {
                    return false
                }
                tag = tag.toLowerCase();
                /* istanbul ignore if */
                if (unknownElementCache[tag] != null) {
                    return unknownElementCache[tag]
                }
                var el = document.createElement(tag);
                if (tag.indexOf('-') > -1) {
                    // http://stackoverflow.com/a/28210364/1070244
                    return (unknownElementCache[tag] = (
                        el.constructor === window.HTMLUnknownElement ||
                        el.constructor === window.HTMLElement
                    ))
                } else {
                    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))
                }
            }

            /*  */

            /**
             * Query an element selector if it's not an element already.
             */
            function query(el) {
                if (typeof el === 'string') {
                    var selector = el;
                    el = document.querySelector(el);
                    if (!el) {
                        process.env.NODE_ENV !== 'production' && warn(
                            'Cannot find element: ' + selector
                        );
                        return document.createElement('div')
                    }
                }
                return el
            }

            /*  */

            function createElement$1(tagName, vnode) {
                var elm = document.createElement(tagName);
                if (tagName !== 'select') {
                    return elm
                }
                if (vnode.data && vnode.data.attrs && 'multiple' in vnode.data.attrs) {
                    elm.setAttribute('multiple', 'multiple');
                }
                return elm
            }

            function createElementNS(namespace, tagName) {
                return document.createElementNS(namespaceMap[namespace], tagName)
            }

            function createTextNode(text) {
                return document.createTextNode(text)
            }

            function createComment(text) {
                return document.createComment(text)
            }

            function insertBefore(parentNode, newNode, referenceNode) {
                parentNode.insertBefore(newNode, referenceNode);
            }

            function removeChild(node, child) {
                node.removeChild(child);
            }

            function appendChild(node, child) {
                node.appendChild(child);
            }

            function parentNode(node) {
                return node.parentNode
            }

            function nextSibling(node) {
                return node.nextSibling
            }

            function tagName(node) {
                return node.tagName
            }

            function setTextContent(node, text) {
                node.textContent = text;
            }

            function setAttribute(node, key, val) {
                node.setAttribute(key, val);
            }


            var nodeOps = Object.freeze({
                createElement: createElement$1,
                createElementNS: createElementNS,
                createTextNode: createTextNode,
                createComment: createComment,
                insertBefore: insertBefore,
                removeChild: removeChild,
                appendChild: appendChild,
                parentNode: parentNode,
                nextSibling: nextSibling,
                tagName: tagName,
                setTextContent: setTextContent,
                setAttribute: setAttribute
            });

            /*  */

            var ref = {
                create: function create(_, vnode) {
                    registerRef(vnode);
                },
                update: function update(oldVnode, vnode) {
                    if (oldVnode.data.ref !== vnode.data.ref) {
                        registerRef(oldVnode, true);
                        registerRef(vnode);
                    }
                },
                destroy: function destroy(vnode) {
                    registerRef(vnode, true);
                }
            };

            function registerRef(vnode, isRemoval) {
                var key = vnode.data.ref;
                if (!key) {
                    return
                }

                var vm = vnode.context;
                var ref = vnode.componentInstance || vnode.elm;
                var refs = vm.$refs;
                if (isRemoval) {
                    if (Array.isArray(refs[key])) {
                        remove$1(refs[key], ref);
                    } else if (refs[key] === ref) {
                        refs[key] = undefined;
                    }
                } else {
                    if (vnode.data.refInFor) {
                        if (Array.isArray(refs[key]) && refs[key].indexOf(ref) < 0) {
                            refs[key].push(ref);
                        } else {
                            refs[key] = [ref];
                        }
                    } else {
                        refs[key] = ref;
                    }
                }
            }

            /**
             * Virtual DOM patching algorithm based on Snabbdom by
             * Simon Friis Vindum (@paldepind)
             * Licensed under the MIT License
             * https://github.com/paldepind/snabbdom/blob/master/LICENSE
             *
             * modified by Evan You (@yyx990803)
             *

             /*
             * Not type-checking this because this file is perf-critical and the cost
             * of making flow understand it is not worth it.
             */

            var emptyNode = new VNode('', {}, []);

            var hooks$1 = ['create', 'activate', 'update', 'remove', 'destroy'];

            function isUndef(s) {
                return s == null
            }

            function isDef(s) {
                return s != null
            }

            function sameVnode(vnode1, vnode2) {
                return (
                    vnode1.key === vnode2.key &&
                    vnode1.tag === vnode2.tag &&
                    vnode1.isComment === vnode2.isComment &&
                    !vnode1.data === !vnode2.data
                )
            }

            function createKeyToOldIdx(children, beginIdx, endIdx) {
                var i, key;
                var map = {};
                for (i = beginIdx; i <= endIdx; ++i) {
                    key = children[i].key;
                    if (isDef(key)) {
                        map[key] = i;
                    }
                }
                return map
            }

            function createPatchFunction(backend) {
                var i, j;
                var cbs = {};

                var modules = backend.modules;
                var nodeOps = backend.nodeOps;

                for (i = 0; i < hooks$1.length; ++i) {
                    cbs[hooks$1[i]] = [];
                    for (j = 0; j < modules.length; ++j) {
                        if (modules[j][hooks$1[i]] !== undefined) {
                            cbs[hooks$1[i]].push(modules[j][hooks$1[i]]);
                        }
                    }
                }

                function emptyNodeAt(elm) {
                    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
                }

                function createRmCb(childElm, listeners) {
                    function remove$$1() {
                        if (--remove$$1.listeners === 0) {
                            removeNode(childElm);
                        }
                    }

                    remove$$1.listeners = listeners;
                    return remove$$1
                }

                function removeNode(el) {
                    var parent = nodeOps.parentNode(el);
                    // element may have already been removed due to v-html / v-text
                    if (parent) {
                        nodeOps.removeChild(parent, el);
                    }
                }

                var inPre = 0;

                function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested) {
                    vnode.isRootInsert = !nested; // for transition enter check
                    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
                        return
                    }

                    var data = vnode.data;
                    var children = vnode.children;
                    var tag = vnode.tag;
                    if (isDef(tag)) {
                        if (process.env.NODE_ENV !== 'production') {
                            if (data && data.pre) {
                                inPre++;
                            }
                            if (
                                !inPre &&
                                !vnode.ns &&
                                !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) &&
                                config.isUnknownElement(tag)
                            ) {
                                warn(
                                    'Unknown custom element: <' + tag + '> - did you ' +
                                    'register the component correctly? For recursive components, ' +
                                    'make sure to provide the "name" option.',
                                    vnode.context
                                );
                            }
                        }
                        vnode.elm = vnode.ns
                            ? nodeOps.createElementNS(vnode.ns, tag)
                            : nodeOps.createElement(tag, vnode);
                        setScope(vnode);

                        /* istanbul ignore if */
                        {
                            createChildren(vnode, children, insertedVnodeQueue);
                            if (isDef(data)) {
                                invokeCreateHooks(vnode, insertedVnodeQueue);
                            }
                            insert(parentElm, vnode.elm, refElm);
                        }

                        if (process.env.NODE_ENV !== 'production' && data && data.pre) {
                            inPre--;
                        }
                    } else if (vnode.isComment) {
                        vnode.elm = nodeOps.createComment(vnode.text);
                        insert(parentElm, vnode.elm, refElm);
                    } else {
                        vnode.elm = nodeOps.createTextNode(vnode.text);
                        insert(parentElm, vnode.elm, refElm);
                    }
                }

                function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
                    var i = vnode.data;
                    if (isDef(i)) {
                        var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
                        if (isDef(i = i.hook) && isDef(i = i.init)) {
                            i(vnode, false /* hydrating */, parentElm, refElm);
                        }
                        // after calling the init hook, if the vnode is a child component
                        // it should've created a child instance and mounted it. the child
                        // component also has set the placeholder vnode's elm.
                        // in that case we can just return the element and be done.
                        if (isDef(vnode.componentInstance)) {
                            initComponent(vnode, insertedVnodeQueue);
                            if (isReactivated) {
                                reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
                            }
                            return true
                        }
                    }
                }

                function initComponent(vnode, insertedVnodeQueue) {
                    if (vnode.data.pendingInsert) {
                        insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
                    }
                    vnode.elm = vnode.componentInstance.$el;
                    if (isPatchable(vnode)) {
                        invokeCreateHooks(vnode, insertedVnodeQueue);
                        setScope(vnode);
                    } else {
                        // empty component root.
                        // skip all element-related modules except for ref (#3455)
                        registerRef(vnode);
                        // make sure to invoke the insert hook
                        insertedVnodeQueue.push(vnode);
                    }
                }

                function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
                    var i;
                    // hack for #4339: a reactivated component with inner transition
                    // does not trigger because the inner node's created hooks are not called
                    // again. It's not ideal to involve module-specific logic in here but
                    // there doesn't seem to be a better way to do it.
                    var innerNode = vnode;
                    while (innerNode.componentInstance) {
                        innerNode = innerNode.componentInstance._vnode;
                        if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
                            for (i = 0; i < cbs.activate.length; ++i) {
                                cbs.activate[i](emptyNode, innerNode);
                            }
                            insertedVnodeQueue.push(innerNode);
                            break
                        }
                    }
                    // unlike a newly created component,
                    // a reactivated keep-alive component doesn't insert itself
                    insert(parentElm, vnode.elm, refElm);
                }

                function insert(parent, elm, ref) {
                    if (parent) {
                        if (ref) {
                            nodeOps.insertBefore(parent, elm, ref);
                        } else {
                            nodeOps.appendChild(parent, elm);
                        }
                    }
                }

                function createChildren(vnode, children, insertedVnodeQueue) {
                    if (Array.isArray(children)) {
                        for (var i = 0; i < children.length; ++i) {
                            createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);
                        }
                    } else if (isPrimitive(vnode.text)) {
                        nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));
                    }
                }

                function isPatchable(vnode) {
                    while (vnode.componentInstance) {
                        vnode = vnode.componentInstance._vnode;
                    }
                    return isDef(vnode.tag)
                }

                function invokeCreateHooks(vnode, insertedVnodeQueue) {
                    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                        cbs.create[i$1](emptyNode, vnode);
                    }
                    i = vnode.data.hook; // Reuse variable
                    if (isDef(i)) {
                        if (i.create) {
                            i.create(emptyNode, vnode);
                        }
                        if (i.insert) {
                            insertedVnodeQueue.push(vnode);
                        }
                    }
                }

                // set scope id attribute for scoped CSS.
                // this is implemented as a special case to avoid the overhead
                // of going through the normal attribute patching process.
                function setScope(vnode) {
                    var i;
                    if (isDef(i = vnode.context) && isDef(i = i.$options._scopeId)) {
                        nodeOps.setAttribute(vnode.elm, i, '');
                    }
                    if (isDef(i = activeInstance) &&
                        i !== vnode.context &&
                        isDef(i = i.$options._scopeId)) {
                        nodeOps.setAttribute(vnode.elm, i, '');
                    }
                }

                function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
                    for (; startIdx <= endIdx; ++startIdx) {
                        createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);
                    }
                }

                function invokeDestroyHook(vnode) {
                    var i, j;
                    var data = vnode.data;
                    if (isDef(data)) {
                        if (isDef(i = data.hook) && isDef(i = i.destroy)) {
                            i(vnode);
                        }
                        for (i = 0; i < cbs.destroy.length; ++i) {
                            cbs.destroy[i](vnode);
                        }
                    }
                    if (isDef(i = vnode.children)) {
                        for (j = 0; j < vnode.children.length; ++j) {
                            invokeDestroyHook(vnode.children[j]);
                        }
                    }
                }

                function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
                    for (; startIdx <= endIdx; ++startIdx) {
                        var ch = vnodes[startIdx];
                        if (isDef(ch)) {
                            if (isDef(ch.tag)) {
                                removeAndInvokeRemoveHook(ch);
                                invokeDestroyHook(ch);
                            } else { // Text node
                                removeNode(ch.elm);
                            }
                        }
                    }
                }

                function removeAndInvokeRemoveHook(vnode, rm) {
                    if (rm || isDef(vnode.data)) {
                        var listeners = cbs.remove.length + 1;
                        if (!rm) {
                            // directly removing
                            rm = createRmCb(vnode.elm, listeners);
                        } else {
                            // we have a recursively passed down rm callback
                            // increase the listeners count
                            rm.listeners += listeners;
                        }
                        // recursively invoke hooks on child component root node
                        if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
                            removeAndInvokeRemoveHook(i, rm);
                        }
                        for (i = 0; i < cbs.remove.length; ++i) {
                            cbs.remove[i](vnode, rm);
                        }
                        if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
                            i(vnode, rm);
                        } else {
                            rm();
                        }
                    } else {
                        removeNode(vnode.elm);
                    }
                }

                function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
                    var oldStartIdx = 0;
                    var newStartIdx = 0;
                    var oldEndIdx = oldCh.length - 1;
                    var oldStartVnode = oldCh[0];
                    var oldEndVnode = oldCh[oldEndIdx];
                    var newEndIdx = newCh.length - 1;
                    var newStartVnode = newCh[0];
                    var newEndVnode = newCh[newEndIdx];
                    var oldKeyToIdx, idxInOld, elmToMove, refElm;

                    // removeOnly is a special flag used only by <transition-group>
                    // to ensure removed elements stay in correct relative positions
                    // during leaving transitions
                    var canMove = !removeOnly;

                    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
                        if (isUndef(oldStartVnode)) {
                            oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
                        } else if (isUndef(oldEndVnode)) {
                            oldEndVnode = oldCh[--oldEndIdx];
                        } else if (sameVnode(oldStartVnode, newStartVnode)) {
                            patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
                            oldStartVnode = oldCh[++oldStartIdx];
                            newStartVnode = newCh[++newStartIdx];
                        } else if (sameVnode(oldEndVnode, newEndVnode)) {
                            patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
                            oldEndVnode = oldCh[--oldEndIdx];
                            newEndVnode = newCh[--newEndIdx];
                        } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
                            patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
                            canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
                            oldStartVnode = oldCh[++oldStartIdx];
                            newEndVnode = newCh[--newEndIdx];
                        } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
                            patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
                            canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
                            oldEndVnode = oldCh[--oldEndIdx];
                            newStartVnode = newCh[++newStartIdx];
                        } else {
                            if (isUndef(oldKeyToIdx)) {
                                oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
                            }
                            idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;
                            if (isUndef(idxInOld)) { // New element
                                createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
                                newStartVnode = newCh[++newStartIdx];
                            } else {
                                elmToMove = oldCh[idxInOld];
                                /* istanbul ignore if */
                                if (process.env.NODE_ENV !== 'production' && !elmToMove) {
                                    warn(
                                        'It seems there are duplicate keys that is causing an update error. ' +
                                        'Make sure each v-for item has a unique key.'
                                    );
                                }
                                if (sameVnode(elmToMove, newStartVnode)) {
                                    patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
                                    oldCh[idxInOld] = undefined;
                                    canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);
                                    newStartVnode = newCh[++newStartIdx];
                                } else {
                                    // same key but different element. treat as new element
                                    createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
                                    newStartVnode = newCh[++newStartIdx];
                                }
                            }
                        }
                    }
                    if (oldStartIdx > oldEndIdx) {
                        refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
                        addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
                    } else if (newStartIdx > newEndIdx) {
                        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
                    }
                }

                function patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {
                    if (oldVnode === vnode) {
                        return
                    }
                    // reuse element for static trees.
                    // note we only do this if the vnode is cloned -
                    // if the new node is not cloned it means the render functions have been
                    // reset by the hot-reload-api and we need to do a proper re-render.
                    if (vnode.isStatic &&
                        oldVnode.isStatic &&
                        vnode.key === oldVnode.key &&
                        (vnode.isCloned || vnode.isOnce)) {
                        vnode.elm = oldVnode.elm;
                        vnode.componentInstance = oldVnode.componentInstance;
                        return
                    }
                    var i;
                    var data = vnode.data;
                    var hasData = isDef(data);
                    if (hasData && isDef(i = data.hook) && isDef(i = i.prepatch)) {
                        i(oldVnode, vnode);
                    }
                    var elm = vnode.elm = oldVnode.elm;
                    var oldCh = oldVnode.children;
                    var ch = vnode.children;
                    if (hasData && isPatchable(vnode)) {
                        for (i = 0; i < cbs.update.length; ++i) {
                            cbs.update[i](oldVnode, vnode);
                        }
                        if (isDef(i = data.hook) && isDef(i = i.update)) {
                            i(oldVnode, vnode);
                        }
                    }
                    if (isUndef(vnode.text)) {
                        if (isDef(oldCh) && isDef(ch)) {
                            if (oldCh !== ch) {
                                updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
                            }
                        } else if (isDef(ch)) {
                            if (isDef(oldVnode.text)) {
                                nodeOps.setTextContent(elm, '');
                            }
                            addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
                        } else if (isDef(oldCh)) {
                            removeVnodes(elm, oldCh, 0, oldCh.length - 1);
                        } else if (isDef(oldVnode.text)) {
                            nodeOps.setTextContent(elm, '');
                        }
                    } else if (oldVnode.text !== vnode.text) {
                        nodeOps.setTextContent(elm, vnode.text);
                    }
                    if (hasData) {
                        if (isDef(i = data.hook) && isDef(i = i.postpatch)) {
                            i(oldVnode, vnode);
                        }
                    }
                }

                function invokeInsertHook(vnode, queue, initial) {
                    // delay insert hooks for component root nodes, invoke them after the
                    // element is really inserted
                    if (initial && vnode.parent) {
                        vnode.parent.data.pendingInsert = queue;
                    } else {
                        for (var i = 0; i < queue.length; ++i) {
                            queue[i].data.hook.insert(queue[i]);
                        }
                    }
                }

                var bailed = false;
                // list of modules that can skip create hook during hydration because they
                // are already rendered on the client or has no need for initialization
                var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');

                // Note: this is a browser-only function so we can assume elms are DOM nodes.
                function hydrate(elm, vnode, insertedVnodeQueue) {
                    if (process.env.NODE_ENV !== 'production') {
                        if (!assertNodeMatch(elm, vnode)) {
                            return false
                        }
                    }
                    vnode.elm = elm;
                    var tag = vnode.tag;
                    var data = vnode.data;
                    var children = vnode.children;
                    if (isDef(data)) {
                        if (isDef(i = data.hook) && isDef(i = i.init)) {
                            i(vnode, true /* hydrating */);
                        }
                        if (isDef(i = vnode.componentInstance)) {
                            // child component. it should have hydrated its own tree.
                            initComponent(vnode, insertedVnodeQueue);
                            return true
                        }
                    }
                    if (isDef(tag)) {
                        if (isDef(children)) {
                            // empty element, allow client to pick up and populate children
                            if (!elm.hasChildNodes()) {
                                createChildren(vnode, children, insertedVnodeQueue);
                            } else {
                                var childrenMatch = true;
                                var childNode = elm.firstChild;
                                for (var i$1 = 0; i$1 < children.length; i$1++) {
                                    if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {
                                        childrenMatch = false;
                                        break
                                    }
                                    childNode = childNode.nextSibling;
                                }
                                // if childNode is not null, it means the actual childNodes list is
                                // longer than the virtual children list.
                                if (!childrenMatch || childNode) {
                                    if (process.env.NODE_ENV !== 'production' &&
                                        typeof console !== 'undefined' &&
                                        !bailed) {
                                        bailed = true;
                                        console.warn('Parent: ', elm);
                                        console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
                                    }
                                    return false
                                }
                            }
                        }
                        if (isDef(data)) {
                            for (var key in data) {
                                if (!isRenderedModule(key)) {
                                    invokeCreateHooks(vnode, insertedVnodeQueue);
                                    break
                                }
                            }
                        }
                    } else if (elm.data !== vnode.text) {
                        elm.data = vnode.text;
                    }
                    return true
                }

                function assertNodeMatch(node, vnode) {
                    if (vnode.tag) {
                        return (
                            vnode.tag.indexOf('vue-component') === 0 ||
                            vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())
                        )
                    } else {
                        return node.nodeType === (vnode.isComment ? 8 : 3)
                    }
                }

                return function patch(oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
                    if (!vnode) {
                        if (oldVnode) {
                            invokeDestroyHook(oldVnode);
                        }
                        return
                    }

                    var isInitialPatch = false;
                    var insertedVnodeQueue = [];

                    if (!oldVnode) {
                        // empty mount (likely as component), create new root element
                        isInitialPatch = true;
                        createElm(vnode, insertedVnodeQueue, parentElm, refElm);
                    } else {
                        var isRealElement = isDef(oldVnode.nodeType);
                        if (!isRealElement && sameVnode(oldVnode, vnode)) {
                            // patch existing root node
                            patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
                        } else {
                            if (isRealElement) {
                                // mounting to a real element
                                // check if this is server-rendered content and if we can perform
                                // a successful hydration.
                                if (oldVnode.nodeType === 1 && oldVnode.hasAttribute('server-rendered')) {
                                    oldVnode.removeAttribute('server-rendered');
                                    hydrating = true;
                                }
                                if (hydrating) {
                                    if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
                                        invokeInsertHook(vnode, insertedVnodeQueue, true);
                                        return oldVnode
                                    } else if (process.env.NODE_ENV !== 'production') {
                                        warn(
                                            'The client-side rendered virtual DOM tree is not matching ' +
                                            'server-rendered content. This is likely caused by incorrect ' +
                                            'HTML markup, for example nesting block-level elements inside ' +
                                            '<p>, or missing <tbody>. Bailing hydration and performing ' +
                                            'full client-side render.'
                                        );
                                    }
                                }
                                // either not server-rendered, or hydration failed.
                                // create an empty node and replace it
                                oldVnode = emptyNodeAt(oldVnode);
                            }
                            // replacing existing element
                            var oldElm = oldVnode.elm;
                            var parentElm$1 = nodeOps.parentNode(oldElm);
                            createElm(
                                vnode,
                                insertedVnodeQueue,
                                // extremely rare edge case: do not insert if old element is in a
                                // leaving transition. Only happens when combining transition +
                                // keep-alive + HOCs. (#4590)
                                oldElm._leaveCb ? null : parentElm$1,
                                nodeOps.nextSibling(oldElm)
                            );

                            if (vnode.parent) {
                                // component root element replaced.
                                // update parent placeholder node element, recursively
                                var ancestor = vnode.parent;
                                while (ancestor) {
                                    ancestor.elm = vnode.elm;
                                    ancestor = ancestor.parent;
                                }
                                if (isPatchable(vnode)) {
                                    for (var i = 0; i < cbs.create.length; ++i) {
                                        cbs.create[i](emptyNode, vnode.parent);
                                    }
                                }
                            }

                            if (parentElm$1 !== null) {
                                removeVnodes(parentElm$1, [oldVnode], 0, 0);
                            } else if (isDef(oldVnode.tag)) {
                                invokeDestroyHook(oldVnode);
                            }
                        }
                    }

                    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
                    return vnode.elm
                }
            }

            /*  */

            var directives = {
                create: updateDirectives,
                update: updateDirectives,
                destroy: function unbindDirectives(vnode) {
                    updateDirectives(vnode, emptyNode);
                }
            };

            function updateDirectives(oldVnode, vnode) {
                if (oldVnode.data.directives || vnode.data.directives) {
                    _update(oldVnode, vnode);
                }
            }

            function _update(oldVnode, vnode) {
                var isCreate = oldVnode === emptyNode;
                var isDestroy = vnode === emptyNode;
                var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
                var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

                var dirsWithInsert = [];
                var dirsWithPostpatch = [];

                var key, oldDir, dir;
                for (key in newDirs) {
                    oldDir = oldDirs[key];
                    dir = newDirs[key];
                    if (!oldDir) {
                        // new directive, bind
                        callHook$1(dir, 'bind', vnode, oldVnode);
                        if (dir.def && dir.def.inserted) {
                            dirsWithInsert.push(dir);
                        }
                    } else {
                        // existing directive, update
                        dir.oldValue = oldDir.value;
                        callHook$1(dir, 'update', vnode, oldVnode);
                        if (dir.def && dir.def.componentUpdated) {
                            dirsWithPostpatch.push(dir);
                        }
                    }
                }

                if (dirsWithInsert.length) {
                    var callInsert = function () {
                        for (var i = 0; i < dirsWithInsert.length; i++) {
                            callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
                        }
                    };
                    if (isCreate) {
                        mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert, 'dir-insert');
                    } else {
                        callInsert();
                    }
                }

                if (dirsWithPostpatch.length) {
                    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {
                        for (var i = 0; i < dirsWithPostpatch.length; i++) {
                            callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
                        }
                    }, 'dir-postpatch');
                }

                if (!isCreate) {
                    for (key in oldDirs) {
                        if (!newDirs[key]) {
                            // no longer present, unbind
                            callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
                        }
                    }
                }
            }

            var emptyModifiers = Object.create(null);

            function normalizeDirectives$1(dirs,
                                           vm) {
                var res = Object.create(null);
                if (!dirs) {
                    return res
                }
                var i, dir;
                for (i = 0; i < dirs.length; i++) {
                    dir = dirs[i];
                    if (!dir.modifiers) {
                        dir.modifiers = emptyModifiers;
                    }
                    res[getRawDirName(dir)] = dir;
                    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
                }
                return res
            }

            function getRawDirName(dir) {
                return dir.rawName || ((dir.name) + "." + (Object.keys(dir.modifiers || {}).join('.')))
            }

            function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
                var fn = dir.def && dir.def[hook];
                if (fn) {
                    fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
                }
            }

            var baseModules = [
                ref,
                directives
            ];

            /*  */

            function updateAttrs(oldVnode, vnode) {
                if (!oldVnode.data.attrs && !vnode.data.attrs) {
                    return
                }
                var key, cur, old;
                var elm = vnode.elm;
                var oldAttrs = oldVnode.data.attrs || {};
                var attrs = vnode.data.attrs || {};
                // clone observed objects, as the user probably wants to mutate it
                if (attrs.__ob__) {
                    attrs = vnode.data.attrs = extend({}, attrs);
                }

                for (key in attrs) {
                    cur = attrs[key];
                    old = oldAttrs[key];
                    if (old !== cur) {
                        setAttr(elm, key, cur);
                    }
                }
                // #4391: in IE9, setting type can reset value for input[type=radio]
                /* istanbul ignore if */
                if (isIE9 && attrs.value !== oldAttrs.value) {
                    setAttr(elm, 'value', attrs.value);
                }
                for (key in oldAttrs) {
                    if (attrs[key] == null) {
                        if (isXlink(key)) {
                            elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
                        } else if (!isEnumeratedAttr(key)) {
                            elm.removeAttribute(key);
                        }
                    }
                }
            }

            function setAttr(el, key, value) {
                if (isBooleanAttr(key)) {
                    // set attribute for blank value
                    // e.g. <option disabled>Select one</option>
                    if (isFalsyAttrValue(value)) {
                        el.removeAttribute(key);
                    } else {
                        el.setAttribute(key, key);
                    }
                } else if (isEnumeratedAttr(key)) {
                    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
                } else if (isXlink(key)) {
                    if (isFalsyAttrValue(value)) {
                        el.removeAttributeNS(xlinkNS, getXlinkProp(key));
                    } else {
                        el.setAttributeNS(xlinkNS, key, value);
                    }
                } else {
                    if (isFalsyAttrValue(value)) {
                        el.removeAttribute(key);
                    } else {
                        el.setAttribute(key, value);
                    }
                }
            }

            var attrs = {
                create: updateAttrs,
                update: updateAttrs
            };

            /*  */

            function updateClass(oldVnode, vnode) {
                var el = vnode.elm;
                var data = vnode.data;
                var oldData = oldVnode.data;
                if (!data.staticClass && !data.class &&
                    (!oldData || (!oldData.staticClass && !oldData.class))) {
                    return
                }

                var cls = genClassForVnode(vnode);

                // handle transition classes
                var transitionClass = el._transitionClasses;
                if (transitionClass) {
                    cls = concat(cls, stringifyClass(transitionClass));
                }

                // set the class
                if (cls !== el._prevClass) {
                    el.setAttribute('class', cls);
                    el._prevClass = cls;
                }
            }

            var klass = {
                create: updateClass,
                update: updateClass
            };

            /*  */

            var target$1;

            function add$2(event,
                           handler,
                           once,
                           capture) {
                if (once) {
                    var oldHandler = handler;
                    var _target = target$1; // save current target element in closure
                    handler = function (ev) {
                        remove$3(event, handler, capture, _target);
                        arguments.length === 1
                            ? oldHandler(ev)
                            : oldHandler.apply(null, arguments);
                    };
                }
                target$1.addEventListener(event, handler, capture);
            }

            function remove$3(event,
                              handler,
                              capture,
                              _target) {
                (_target || target$1).removeEventListener(event, handler, capture);
            }

            function updateDOMListeners(oldVnode, vnode) {
                if (!oldVnode.data.on && !vnode.data.on) {
                    return
                }
                var on = vnode.data.on || {};
                var oldOn = oldVnode.data.on || {};
                target$1 = vnode.elm;
                updateListeners(on, oldOn, add$2, remove$3, vnode.context);
            }

            var events = {
                create: updateDOMListeners,
                update: updateDOMListeners
            };

            /*  */

            function updateDOMProps(oldVnode, vnode) {
                if (!oldVnode.data.domProps && !vnode.data.domProps) {
                    return
                }
                var key, cur;
                var elm = vnode.elm;
                var oldProps = oldVnode.data.domProps || {};
                var props = vnode.data.domProps || {};
                // clone observed objects, as the user probably wants to mutate it
                if (props.__ob__) {
                    props = vnode.data.domProps = extend({}, props);
                }

                for (key in oldProps) {
                    if (props[key] == null) {
                        elm[key] = '';
                    }
                }
                for (key in props) {
                    cur = props[key];
                    // ignore children if the node has textContent or innerHTML,
                    // as these will throw away existing DOM nodes and cause removal errors
                    // on subsequent patches (#3360)
                    if (key === 'textContent' || key === 'innerHTML') {
                        if (vnode.children) {
                            vnode.children.length = 0;
                        }
                        if (cur === oldProps[key]) {
                            continue
                        }
                    }

                    if (key === 'value') {
                        // store value as _value as well since
                        // non-string values will be stringified
                        elm._value = cur;
                        // avoid resetting cursor position when value is the same
                        var strCur = cur == null ? '' : String(cur);
                        if (shouldUpdateValue(elm, vnode, strCur)) {
                            elm.value = strCur;
                        }
                    } else {
                        elm[key] = cur;
                    }
                }
            }

// check platforms/web/util/attrs.js acceptValue


            function shouldUpdateValue(elm,
                                       vnode,
                                       checkVal) {
                return (!elm.composing && (
                    vnode.tag === 'option' ||
                    isDirty(elm, checkVal) ||
                    isInputChanged(vnode, checkVal)
                ))
            }

            function isDirty(elm, checkVal) {
                // return true when textbox (.number and .trim) loses focus and its value is not equal to the updated value
                return document.activeElement !== elm && elm.value !== checkVal
            }

            function isInputChanged(vnode, newVal) {
                var value = vnode.elm.value;
                var modifiers = vnode.elm._vModifiers; // injected by v-model runtime
                if ((modifiers && modifiers.number) || vnode.elm.type === 'number') {
                    return toNumber(value) !== toNumber(newVal)
                }
                if (modifiers && modifiers.trim) {
                    return value.trim() !== newVal.trim()
                }
                return value !== newVal
            }

            var domProps = {
                create: updateDOMProps,
                update: updateDOMProps
            };

            /*  */

            var parseStyleText = cached(function (cssText) {
                var res = {};
                var listDelimiter = /;(?![^(]*\))/g;
                var propertyDelimiter = /:(.+)/;
                cssText.split(listDelimiter).forEach(function (item) {
                    if (item) {
                        var tmp = item.split(propertyDelimiter);
                        tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
                    }
                });
                return res
            });

// merge static and dynamic style data on the same vnode
            function normalizeStyleData(data) {
                var style = normalizeStyleBinding(data.style);
                // static style is pre-processed into an object during compilation
                // and is always a fresh object, so it's safe to merge into it
                return data.staticStyle
                    ? extend(data.staticStyle, style)
                    : style
            }

// normalize possible array / string values into Object
            function normalizeStyleBinding(bindingStyle) {
                if (Array.isArray(bindingStyle)) {
                    return toObject(bindingStyle)
                }
                if (typeof bindingStyle === 'string') {
                    return parseStyleText(bindingStyle)
                }
                return bindingStyle
            }

            /**
             * parent component style should be after child's
             * so that parent component's style could override it
             */
            function getStyle(vnode, checkChild) {
                var res = {};
                var styleData;

                if (checkChild) {
                    var childNode = vnode;
                    while (childNode.componentInstance) {
                        childNode = childNode.componentInstance._vnode;
                        if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {
                            extend(res, styleData);
                        }
                    }
                }

                if ((styleData = normalizeStyleData(vnode.data))) {
                    extend(res, styleData);
                }

                var parentNode = vnode;
                while ((parentNode = parentNode.parent)) {
                    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
                        extend(res, styleData);
                    }
                }
                return res
            }

            /*  */

            var cssVarRE = /^--/;
            var importantRE = /\s*!important$/;
            var setProp = function (el, name, val) {
                /* istanbul ignore if */
                if (cssVarRE.test(name)) {
                    el.style.setProperty(name, val);
                } else if (importantRE.test(val)) {
                    el.style.setProperty(name, val.replace(importantRE, ''), 'important');
                } else {
                    el.style[normalize(name)] = val;
                }
            };

            var prefixes = ['Webkit', 'Moz', 'ms'];

            var testEl;
            var normalize = cached(function (prop) {
                testEl = testEl || document.createElement('div');
                prop = camelize(prop);
                if (prop !== 'filter' && (prop in testEl.style)) {
                    return prop
                }
                var upper = prop.charAt(0).toUpperCase() + prop.slice(1);
                for (var i = 0; i < prefixes.length; i++) {
                    var prefixed = prefixes[i] + upper;
                    if (prefixed in testEl.style) {
                        return prefixed
                    }
                }
            });

            function updateStyle(oldVnode, vnode) {
                var data = vnode.data;
                var oldData = oldVnode.data;

                if (!data.staticStyle && !data.style &&
                    !oldData.staticStyle && !oldData.style) {
                    return
                }

                var cur, name;
                var el = vnode.elm;
                var oldStaticStyle = oldVnode.data.staticStyle;
                var oldStyleBinding = oldVnode.data.style || {};

                // if static style exists, stylebinding already merged into it when doing normalizeStyleData
                var oldStyle = oldStaticStyle || oldStyleBinding;

                var style = normalizeStyleBinding(vnode.data.style) || {};

                vnode.data.style = style.__ob__ ? extend({}, style) : style;

                var newStyle = getStyle(vnode, true);

                for (name in oldStyle) {
                    if (newStyle[name] == null) {
                        setProp(el, name, '');
                    }
                }
                for (name in newStyle) {
                    cur = newStyle[name];
                    if (cur !== oldStyle[name]) {
                        // ie9 setting to null has no effect, must use empty string
                        setProp(el, name, cur == null ? '' : cur);
                    }
                }
            }

            var style = {
                create: updateStyle,
                update: updateStyle
            };

            /*  */

            /**
             * Add class with compatibility for SVG since classList is not supported on
             * SVG elements in IE
             */
            function addClass(el, cls) {
                /* istanbul ignore if */
                if (!cls || !cls.trim()) {
                    return
                }

                /* istanbul ignore else */
                if (el.classList) {
                    if (cls.indexOf(' ') > -1) {
                        cls.split(/\s+/).forEach(function (c) {
                            return el.classList.add(c);
                        });
                    } else {
                        el.classList.add(cls);
                    }
                } else {
                    var cur = ' ' + el.getAttribute('class') + ' ';
                    if (cur.indexOf(' ' + cls + ' ') < 0) {
                        el.setAttribute('class', (cur + cls).trim());
                    }
                }
            }

            /**
             * Remove class with compatibility for SVG since classList is not supported on
             * SVG elements in IE
             */
            function removeClass(el, cls) {
                /* istanbul ignore if */
                if (!cls || !cls.trim()) {
                    return
                }

                /* istanbul ignore else */
                if (el.classList) {
                    if (cls.indexOf(' ') > -1) {
                        cls.split(/\s+/).forEach(function (c) {
                            return el.classList.remove(c);
                        });
                    } else {
                        el.classList.remove(cls);
                    }
                } else {
                    var cur = ' ' + el.getAttribute('class') + ' ';
                    var tar = ' ' + cls + ' ';
                    while (cur.indexOf(tar) >= 0) {
                        cur = cur.replace(tar, ' ');
                    }
                    el.setAttribute('class', cur.trim());
                }
            }

            /*  */

            var hasTransition = inBrowser && !isIE9;
            var TRANSITION = 'transition';
            var ANIMATION = 'animation';

// Transition property/event sniffing
            var transitionProp = 'transition';
            var transitionEndEvent = 'transitionend';
            var animationProp = 'animation';
            var animationEndEvent = 'animationend';
            if (hasTransition) {
                /* istanbul ignore if */
                if (window.ontransitionend === undefined &&
                    window.onwebkittransitionend !== undefined) {
                    transitionProp = 'WebkitTransition';
                    transitionEndEvent = 'webkitTransitionEnd';
                }
                if (window.onanimationend === undefined &&
                    window.onwebkitanimationend !== undefined) {
                    animationProp = 'WebkitAnimation';
                    animationEndEvent = 'webkitAnimationEnd';
                }
            }

// binding to window is necessary to make hot reload work in IE in strict mode
            var raf = inBrowser && window.requestAnimationFrame
                ? window.requestAnimationFrame.bind(window)
                : setTimeout;

            function nextFrame(fn) {
                raf(function () {
                    raf(fn);
                });
            }

            function addTransitionClass(el, cls) {
                (el._transitionClasses || (el._transitionClasses = [])).push(cls);
                addClass(el, cls);
            }

            function removeTransitionClass(el, cls) {
                if (el._transitionClasses) {
                    remove$1(el._transitionClasses, cls);
                }
                removeClass(el, cls);
            }

            function whenTransitionEnds(el,
                                        expectedType,
                                        cb) {
                var ref = getTransitionInfo(el, expectedType);
                var type = ref.type;
                var timeout = ref.timeout;
                var propCount = ref.propCount;
                if (!type) {
                    return cb()
                }
                var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
                var ended = 0;
                var end = function () {
                    el.removeEventListener(event, onEnd);
                    cb();
                };
                var onEnd = function (e) {
                    if (e.target === el) {
                        if (++ended >= propCount) {
                            end();
                        }
                    }
                };
                setTimeout(function () {
                    if (ended < propCount) {
                        end();
                    }
                }, timeout + 1);
                el.addEventListener(event, onEnd);
            }

            var transformRE = /\b(transform|all)(,|$)/;

            function getTransitionInfo(el, expectedType) {
                var styles = window.getComputedStyle(el);
                var transitioneDelays = styles[transitionProp + 'Delay'].split(', ');
                var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
                var transitionTimeout = getTimeout(transitioneDelays, transitionDurations);
                var animationDelays = styles[animationProp + 'Delay'].split(', ');
                var animationDurations = styles[animationProp + 'Duration'].split(', ');
                var animationTimeout = getTimeout(animationDelays, animationDurations);

                var type;
                var timeout = 0;
                var propCount = 0;
                /* istanbul ignore if */
                if (expectedType === TRANSITION) {
                    if (transitionTimeout > 0) {
                        type = TRANSITION;
                        timeout = transitionTimeout;
                        propCount = transitionDurations.length;
                    }
                } else if (expectedType === ANIMATION) {
                    if (animationTimeout > 0) {
                        type = ANIMATION;
                        timeout = animationTimeout;
                        propCount = animationDurations.length;
                    }
                } else {
                    timeout = Math.max(transitionTimeout, animationTimeout);
                    type = timeout > 0
                        ? transitionTimeout > animationTimeout
                            ? TRANSITION
                            : ANIMATION
                        : null;
                    propCount = type
                        ? type === TRANSITION
                            ? transitionDurations.length
                            : animationDurations.length
                        : 0;
                }
                var hasTransform =
                    type === TRANSITION &&
                    transformRE.test(styles[transitionProp + 'Property']);
                return {
                    type: type,
                    timeout: timeout,
                    propCount: propCount,
                    hasTransform: hasTransform
                }
            }

            function getTimeout(delays, durations) {
                /* istanbul ignore next */
                while (delays.length < durations.length) {
                    delays = delays.concat(delays);
                }

                return Math.max.apply(null, durations.map(function (d, i) {
                    return toMs(d) + toMs(delays[i])
                }))
            }

            function toMs(s) {
                return Number(s.slice(0, -1)) * 1000
            }

            /*  */

            function enter(vnode, toggleDisplay) {
                var el = vnode.elm;

                // call leave callback now
                if (el._leaveCb) {
                    el._leaveCb.cancelled = true;
                    el._leaveCb();
                }

                var data = resolveTransition(vnode.data.transition);
                if (!data) {
                    return
                }

                /* istanbul ignore if */
                if (el._enterCb || el.nodeType !== 1) {
                    return
                }

                var css = data.css;
                var type = data.type;
                var enterClass = data.enterClass;
                var enterToClass = data.enterToClass;
                var enterActiveClass = data.enterActiveClass;
                var appearClass = data.appearClass;
                var appearToClass = data.appearToClass;
                var appearActiveClass = data.appearActiveClass;
                var beforeEnter = data.beforeEnter;
                var enter = data.enter;
                var afterEnter = data.afterEnter;
                var enterCancelled = data.enterCancelled;
                var beforeAppear = data.beforeAppear;
                var appear = data.appear;
                var afterAppear = data.afterAppear;
                var appearCancelled = data.appearCancelled;

                // activeInstance will always be the <transition> component managing this
                // transition. One edge case to check is when the <transition> is placed
                // as the root node of a child component. In that case we need to check
                // <transition>'s parent for appear check.
                var context = activeInstance;
                var transitionNode = activeInstance.$vnode;
                while (transitionNode && transitionNode.parent) {
                    transitionNode = transitionNode.parent;
                    context = transitionNode.context;
                }

                var isAppear = !context._isMounted || !vnode.isRootInsert;

                if (isAppear && !appear && appear !== '') {
                    return
                }

                var startClass = isAppear ? appearClass : enterClass;
                var activeClass = isAppear ? appearActiveClass : enterActiveClass;
                var toClass = isAppear ? appearToClass : enterToClass;
                var beforeEnterHook = isAppear ? (beforeAppear || beforeEnter) : beforeEnter;
                var enterHook = isAppear ? (typeof appear === 'function' ? appear : enter) : enter;
                var afterEnterHook = isAppear ? (afterAppear || afterEnter) : afterEnter;
                var enterCancelledHook = isAppear ? (appearCancelled || enterCancelled) : enterCancelled;

                var expectsCSS = css !== false && !isIE9;
                var userWantsControl =
                    enterHook &&
                    // enterHook may be a bound method which exposes
                    // the length of original fn as _length
                    (enterHook._length || enterHook.length) > 1;

                var cb = el._enterCb = once(function () {
                    if (expectsCSS) {
                        removeTransitionClass(el, toClass);
                        removeTransitionClass(el, activeClass);
                    }
                    if (cb.cancelled) {
                        if (expectsCSS) {
                            removeTransitionClass(el, startClass);
                        }
                        enterCancelledHook && enterCancelledHook(el);
                    } else {
                        afterEnterHook && afterEnterHook(el);
                    }
                    el._enterCb = null;
                });

                if (!vnode.data.show) {
                    // remove pending leave element on enter by injecting an insert hook
                    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {
                        var parent = el.parentNode;
                        var pendingNode = parent && parent._pending && parent._pending[vnode.key];
                        if (pendingNode &&
                            pendingNode.tag === vnode.tag &&
                            pendingNode.elm._leaveCb) {
                            pendingNode.elm._leaveCb();
                        }
                        enterHook && enterHook(el, cb);
                    }, 'transition-insert');
                }

                // start enter transition
                beforeEnterHook && beforeEnterHook(el);
                if (expectsCSS) {
                    addTransitionClass(el, startClass);
                    addTransitionClass(el, activeClass);
                    nextFrame(function () {
                        addTransitionClass(el, toClass);
                        removeTransitionClass(el, startClass);
                        if (!cb.cancelled && !userWantsControl) {
                            whenTransitionEnds(el, type, cb);
                        }
                    });
                }

                if (vnode.data.show) {
                    toggleDisplay && toggleDisplay();
                    enterHook && enterHook(el, cb);
                }

                if (!expectsCSS && !userWantsControl) {
                    cb();
                }
            }

            function leave(vnode, rm) {
                var el = vnode.elm;

                // call enter callback now
                if (el._enterCb) {
                    el._enterCb.cancelled = true;
                    el._enterCb();
                }

                var data = resolveTransition(vnode.data.transition);
                if (!data) {
                    return rm()
                }

                /* istanbul ignore if */
                if (el._leaveCb || el.nodeType !== 1) {
                    return
                }

                var css = data.css;
                var type = data.type;
                var leaveClass = data.leaveClass;
                var leaveToClass = data.leaveToClass;
                var leaveActiveClass = data.leaveActiveClass;
                var beforeLeave = data.beforeLeave;
                var leave = data.leave;
                var afterLeave = data.afterLeave;
                var leaveCancelled = data.leaveCancelled;
                var delayLeave = data.delayLeave;

                var expectsCSS = css !== false && !isIE9;
                var userWantsControl =
                    leave &&
                    // leave hook may be a bound method which exposes
                    // the length of original fn as _length
                    (leave._length || leave.length) > 1;

                var cb = el._leaveCb = once(function () {
                    if (el.parentNode && el.parentNode._pending) {
                        el.parentNode._pending[vnode.key] = null;
                    }
                    if (expectsCSS) {
                        removeTransitionClass(el, leaveToClass);
                        removeTransitionClass(el, leaveActiveClass);
                    }
                    if (cb.cancelled) {
                        if (expectsCSS) {
                            removeTransitionClass(el, leaveClass);
                        }
                        leaveCancelled && leaveCancelled(el);
                    } else {
                        rm();
                        afterLeave && afterLeave(el);
                    }
                    el._leaveCb = null;
                });

                if (delayLeave) {
                    delayLeave(performLeave);
                } else {
                    performLeave();
                }

                function performLeave() {
                    // the delayed leave may have already been cancelled
                    if (cb.cancelled) {
                        return
                    }
                    // record leaving element
                    if (!vnode.data.show) {
                        (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
                    }
                    beforeLeave && beforeLeave(el);
                    if (expectsCSS) {
                        addTransitionClass(el, leaveClass);
                        addTransitionClass(el, leaveActiveClass);
                        nextFrame(function () {
                            addTransitionClass(el, leaveToClass);
                            removeTransitionClass(el, leaveClass);
                            if (!cb.cancelled && !userWantsControl) {
                                whenTransitionEnds(el, type, cb);
                            }
                        });
                    }
                    leave && leave(el, cb);
                    if (!expectsCSS && !userWantsControl) {
                        cb();
                    }
                }
            }

            function resolveTransition(def$$1) {
                if (!def$$1) {
                    return
                }
                /* istanbul ignore else */
                if (typeof def$$1 === 'object') {
                    var res = {};
                    if (def$$1.css !== false) {
                        extend(res, autoCssTransition(def$$1.name || 'v'));
                    }
                    extend(res, def$$1);
                    return res
                } else if (typeof def$$1 === 'string') {
                    return autoCssTransition(def$$1)
                }
            }

            var autoCssTransition = cached(function (name) {
                return {
                    enterClass: (name + "-enter"),
                    leaveClass: (name + "-leave"),
                    appearClass: (name + "-enter"),
                    enterToClass: (name + "-enter-to"),
                    leaveToClass: (name + "-leave-to"),
                    appearToClass: (name + "-enter-to"),
                    enterActiveClass: (name + "-enter-active"),
                    leaveActiveClass: (name + "-leave-active"),
                    appearActiveClass: (name + "-enter-active")
                }
            });

            function once(fn) {
                var called = false;
                return function () {
                    if (!called) {
                        called = true;
                        fn();
                    }
                }
            }

            function _enter(_, vnode) {
                if (!vnode.data.show) {
                    enter(vnode);
                }
            }

            var transition = inBrowser ? {
                create: _enter,
                activate: _enter,
                remove: function remove(vnode, rm) {
                    /* istanbul ignore else */
                    if (!vnode.data.show) {
                        leave(vnode, rm);
                    } else {
                        rm();
                    }
                }
            } : {};

            var platformModules = [
                attrs,
                klass,
                events,
                domProps,
                style,
                transition
            ];

            /*  */

// the directive module should be applied last, after all
// built-in modules have been applied.
            var modules = platformModules.concat(baseModules);

            var patch$1 = createPatchFunction({nodeOps: nodeOps, modules: modules});

            /**
             * Not type checking this file because flow doesn't like attaching
             * properties to Elements.
             */

            var modelableTagRE = /^input|select|textarea|vue-component-[0-9]+(-[0-9a-zA-Z_-]*)?$/;

            /* istanbul ignore if */
            if (isIE9) {
                // http://www.matts411.com/post/internet-explorer-9-oninput/
                document.addEventListener('selectionchange', function () {
                    var el = document.activeElement;
                    if (el && el.vmodel) {
                        trigger(el, 'input');
                    }
                });
            }

            var model = {
                inserted: function inserted(el, binding, vnode) {
                    if (process.env.NODE_ENV !== 'production') {
                        if (!modelableTagRE.test(vnode.tag)) {
                            warn(
                                "v-model is not supported on element type: <" + (vnode.tag) + ">. " +
                                'If you are working with contenteditable, it\'s recommended to ' +
                                'wrap a library dedicated for that purpose inside a custom component.',
                                vnode.context
                            );
                        }
                    }
                    if (vnode.tag === 'select') {
                        var cb = function () {
                            setSelected(el, binding, vnode.context);
                        };
                        cb();
                        /* istanbul ignore if */
                        if (isIE || isEdge) {
                            setTimeout(cb, 0);
                        }
                    } else if (vnode.tag === 'textarea' || el.type === 'text') {
                        el._vModifiers = binding.modifiers;
                        if (!binding.modifiers.lazy) {
                            if (!isAndroid) {
                                el.addEventListener('compositionstart', onCompositionStart);
                                el.addEventListener('compositionend', onCompositionEnd);
                            }
                            /* istanbul ignore if */
                            if (isIE9) {
                                el.vmodel = true;
                            }
                        }
                    }
                },
                componentUpdated: function componentUpdated(el, binding, vnode) {
                    if (vnode.tag === 'select') {
                        setSelected(el, binding, vnode.context);
                        // in case the options rendered by v-for have changed,
                        // it's possible that the value is out-of-sync with the rendered options.
                        // detect such cases and filter out values that no longer has a matching
                        // option in the DOM.
                        var needReset = el.multiple
                            ? binding.value.some(function (v) {
                                return hasNoMatchingOption(v, el.options);
                            })
                            : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);
                        if (needReset) {
                            trigger(el, 'change');
                        }
                    }
                }
            };

            function setSelected(el, binding, vm) {
                var value = binding.value;
                var isMultiple = el.multiple;
                if (isMultiple && !Array.isArray(value)) {
                    process.env.NODE_ENV !== 'production' && warn(
                        "<select multiple v-model=\"" + (binding.expression) + "\"> " +
                        "expects an Array value for its binding, but got " + (Object.prototype.toString.call(value).slice(8, -1)),
                        vm
                    );
                    return
                }
                var selected, option;
                for (var i = 0, l = el.options.length; i < l; i++) {
                    option = el.options[i];
                    if (isMultiple) {
                        selected = looseIndexOf(value, getValue(option)) > -1;
                        if (option.selected !== selected) {
                            option.selected = selected;
                        }
                    } else {
                        if (looseEqual(getValue(option), value)) {
                            if (el.selectedIndex !== i) {
                                el.selectedIndex = i;
                            }
                            return
                        }
                    }
                }
                if (!isMultiple) {
                    el.selectedIndex = -1;
                }
            }

            function hasNoMatchingOption(value, options) {
                for (var i = 0, l = options.length; i < l; i++) {
                    if (looseEqual(getValue(options[i]), value)) {
                        return false
                    }
                }
                return true
            }

            function getValue(option) {
                return '_value' in option
                    ? option._value
                    : option.value
            }

            function onCompositionStart(e) {
                e.target.composing = true;
            }

            function onCompositionEnd(e) {
                e.target.composing = false;
                trigger(e.target, 'input');
            }

            function trigger(el, type) {
                var e = document.createEvent('HTMLEvents');
                e.initEvent(type, true, true);
                el.dispatchEvent(e);
            }

            /*  */

// recursively search for possible transition defined inside the component root
            function locateNode(vnode) {
                return vnode.componentInstance && (!vnode.data || !vnode.data.transition)
                    ? locateNode(vnode.componentInstance._vnode)
                    : vnode
            }

            var show = {
                bind: function bind(el, ref, vnode) {
                    var value = ref.value;

                    vnode = locateNode(vnode);
                    var transition = vnode.data && vnode.data.transition;
                    var originalDisplay = el.__vOriginalDisplay =
                        el.style.display === 'none' ? '' : el.style.display;
                    if (value && transition && !isIE9) {
                        vnode.data.show = true;
                        enter(vnode, function () {
                            el.style.display = originalDisplay;
                        });
                    } else {
                        el.style.display = value ? originalDisplay : 'none';
                    }
                },

                update: function update(el, ref, vnode) {
                    var value = ref.value;
                    var oldValue = ref.oldValue;

                    /* istanbul ignore if */
                    if (value === oldValue) {
                        return
                    }
                    vnode = locateNode(vnode);
                    var transition = vnode.data && vnode.data.transition;
                    if (transition && !isIE9) {
                        vnode.data.show = true;
                        if (value) {
                            enter(vnode, function () {
                                el.style.display = el.__vOriginalDisplay;
                            });
                        } else {
                            leave(vnode, function () {
                                el.style.display = 'none';
                            });
                        }
                    } else {
                        el.style.display = value ? el.__vOriginalDisplay : 'none';
                    }
                },

                unbind: function unbind(el,
                                        binding,
                                        vnode,
                                        oldVnode,
                                        isDestroy) {
                    if (!isDestroy) {
                        el.style.display = el.__vOriginalDisplay;
                    }
                }
            };

            var platformDirectives = {
                model: model,
                show: show
            };

            /*  */

// Provides transition support for a single element/component.
// supports transition mode (out-in / in-out)

            var transitionProps = {
                name: String,
                appear: Boolean,
                css: Boolean,
                mode: String,
                type: String,
                enterClass: String,
                leaveClass: String,
                enterToClass: String,
                leaveToClass: String,
                enterActiveClass: String,
                leaveActiveClass: String,
                appearClass: String,
                appearActiveClass: String,
                appearToClass: String
            };

// in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered
            function getRealChild(vnode) {
                var compOptions = vnode && vnode.componentOptions;
                if (compOptions && compOptions.Ctor.options.abstract) {
                    return getRealChild(getFirstComponentChild(compOptions.children))
                } else {
                    return vnode
                }
            }

            function extractTransitionData(comp) {
                var data = {};
                var options = comp.$options;
                // props
                for (var key in options.propsData) {
                    data[key] = comp[key];
                }
                // events.
                // extract listeners and pass them directly to the transition methods
                var listeners = options._parentListeners;
                for (var key$1 in listeners) {
                    data[camelize(key$1)] = listeners[key$1].fn;
                }
                return data
            }

            function placeholder(h, rawChild) {
                return /\d-keep-alive$/.test(rawChild.tag)
                    ? h('keep-alive')
                    : null
            }

            function hasParentTransition(vnode) {
                while ((vnode = vnode.parent)) {
                    if (vnode.data.transition) {
                        return true
                    }
                }
            }

            function isSameChild(child, oldChild) {
                return oldChild.key === child.key && oldChild.tag === child.tag
            }

            var Transition = {
                name: 'transition',
                props: transitionProps,
                abstract: true,

                render: function render(h) {
                    var this$1 = this;

                    var children = this.$slots.default;
                    if (!children) {
                        return
                    }

                    // filter out text nodes (possible whitespaces)
                    children = children.filter(function (c) {
                        return c.tag;
                    });
                    /* istanbul ignore if */
                    if (!children.length) {
                        return
                    }

                    // warn multiple elements
                    if (process.env.NODE_ENV !== 'production' && children.length > 1) {
                        warn(
                            '<transition> can only be used on a single element. Use ' +
                            '<transition-group> for lists.',
                            this.$parent
                        );
                    }

                    var mode = this.mode;

                    // warn invalid mode
                    if (process.env.NODE_ENV !== 'production' &&
                        mode && mode !== 'in-out' && mode !== 'out-in') {
                        warn(
                            'invalid <transition> mode: ' + mode,
                            this.$parent
                        );
                    }

                    var rawChild = children[0];

                    // if this is a component root node and the component's
                    // parent container node also has transition, skip.
                    if (hasParentTransition(this.$vnode)) {
                        return rawChild
                    }

                    // apply transition data to child
                    // use getRealChild() to ignore abstract components e.g. keep-alive
                    var child = getRealChild(rawChild);
                    /* istanbul ignore if */
                    if (!child) {
                        return rawChild
                    }

                    if (this._leaving) {
                        return placeholder(h, rawChild)
                    }

                    // ensure a key that is unique to the vnode type and to this transition
                    // component instance. This key will be used to remove pending leaving nodes
                    // during entering.
                    var id = "__transition-" + (this._uid) + "-";
                    var key = child.key = child.key == null
                        ? id + child.tag
                        : isPrimitive(child.key)
                            ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)
                            : child.key;
                    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
                    var oldRawChild = this._vnode;
                    var oldChild = getRealChild(oldRawChild);

                    // mark v-show
                    // so that the transition module can hand over the control to the directive
                    if (child.data.directives && child.data.directives.some(function (d) {
                            return d.name === 'show';
                        })) {
                        child.data.show = true;
                    }

                    if (oldChild && oldChild.data && !isSameChild(child, oldChild)) {
                        // replace old child transition data with fresh one
                        // important for dynamic transitions!
                        var oldData = oldChild && (oldChild.data.transition = extend({}, data));
                        // handle transition mode
                        if (mode === 'out-in') {
                            // return placeholder node and queue update when leave finishes
                            this._leaving = true;
                            mergeVNodeHook(oldData, 'afterLeave', function () {
                                this$1._leaving = false;
                                this$1.$forceUpdate();
                            }, key);
                            return placeholder(h, rawChild)
                        } else if (mode === 'in-out') {
                            var delayedLeave;
                            var performLeave = function () {
                                delayedLeave();
                            };
                            mergeVNodeHook(data, 'afterEnter', performLeave, key);
                            mergeVNodeHook(data, 'enterCancelled', performLeave, key);
                            mergeVNodeHook(oldData, 'delayLeave', function (leave) {
                                delayedLeave = leave;
                            }, key);
                        }
                    }

                    return rawChild
                }
            };

            /*  */

// Provides transition support for list items.
// supports move transitions using the FLIP technique.

// Because the vdom's children update algorithm is "unstable" - i.e.
// it doesn't guarantee the relative positioning of removed elements,
// we force transition-group to update its children into two passes:
// in the first pass, we remove all nodes that need to be removed,
// triggering their leaving transition; in the second pass, we insert/move
// into the final disired state. This way in the second pass removed
// nodes will remain where they should be.

            var props = extend({
                tag: String,
                moveClass: String
            }, transitionProps);

            delete props.mode;

            var TransitionGroup = {
                props: props,

                render: function render(h) {
                    var tag = this.tag || this.$vnode.data.tag || 'span';
                    var map = Object.create(null);
                    var prevChildren = this.prevChildren = this.children;
                    var rawChildren = this.$slots.default || [];
                    var children = this.children = [];
                    var transitionData = extractTransitionData(this);

                    for (var i = 0; i < rawChildren.length; i++) {
                        var c = rawChildren[i];
                        if (c.tag) {
                            if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
                                children.push(c);
                                map[c.key] = c
                                ;(c.data || (c.data = {})).transition = transitionData;
                            } else if (process.env.NODE_ENV !== 'production') {
                                var opts = c.componentOptions;
                                var name = opts
                                    ? (opts.Ctor.options.name || opts.tag)
                                    : c.tag;
                                warn(("<transition-group> children must be keyed: <" + name + ">"));
                            }
                        }
                    }

                    if (prevChildren) {
                        var kept = [];
                        var removed = [];
                        for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
                            var c$1 = prevChildren[i$1];
                            c$1.data.transition = transitionData;
                            c$1.data.pos = c$1.elm.getBoundingClientRect();
                            if (map[c$1.key]) {
                                kept.push(c$1);
                            } else {
                                removed.push(c$1);
                            }
                        }
                        this.kept = h(tag, null, kept);
                        this.removed = removed;
                    }

                    return h(tag, null, children)
                },

                beforeUpdate: function beforeUpdate() {
                    // force removing pass
                    this.__patch__(
                        this._vnode,
                        this.kept,
                        false, // hydrating
                        true // removeOnly (!important, avoids unnecessary moves)
                    );
                    this._vnode = this.kept;
                },

                updated: function updated() {
                    var children = this.prevChildren;
                    var moveClass = this.moveClass || ((this.name || 'v') + '-move');
                    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
                        return
                    }

                    // we divide the work into three loops to avoid mixing DOM reads and writes
                    // in each iteration - which helps prevent layout thrashing.
                    children.forEach(callPendingCbs);
                    children.forEach(recordPosition);
                    children.forEach(applyTranslation);

                    // force reflow to put everything in position
                    var f = document.body.offsetHeight; // eslint-disable-line

                    children.forEach(function (c) {
                        if (c.data.moved) {
                            var el = c.elm;
                            var s = el.style;
                            addTransitionClass(el, moveClass);
                            s.transform = s.WebkitTransform = s.transitionDuration = '';
                            el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
                                if (!e || /transform$/.test(e.propertyName)) {
                                    el.removeEventListener(transitionEndEvent, cb);
                                    el._moveCb = null;
                                    removeTransitionClass(el, moveClass);
                                }
                            });
                        }
                    });
                },

                methods: {
                    hasMove: function hasMove(el, moveClass) {
                        /* istanbul ignore if */
                        if (!hasTransition) {
                            return false
                        }
                        if (this._hasMove != null) {
                            return this._hasMove
                        }
                        addTransitionClass(el, moveClass);
                        var info = getTransitionInfo(el);
                        removeTransitionClass(el, moveClass);
                        return (this._hasMove = info.hasTransform)
                    }
                }
            };

            function callPendingCbs(c) {
                /* istanbul ignore if */
                if (c.elm._moveCb) {
                    c.elm._moveCb();
                }
                /* istanbul ignore if */
                if (c.elm._enterCb) {
                    c.elm._enterCb();
                }
            }

            function recordPosition(c) {
                c.data.newPos = c.elm.getBoundingClientRect();
            }

            function applyTranslation(c) {
                var oldPos = c.data.pos;
                var newPos = c.data.newPos;
                var dx = oldPos.left - newPos.left;
                var dy = oldPos.top - newPos.top;
                if (dx || dy) {
                    c.data.moved = true;
                    var s = c.elm.style;
                    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
                    s.transitionDuration = '0s';
                }
            }

            var platformComponents = {
                Transition: Transition,
                TransitionGroup: TransitionGroup
            };

            /*  */

// install platform specific utils
            Vue$3.config.isUnknownElement = isUnknownElement;
            Vue$3.config.isReservedTag = isReservedTag;
            Vue$3.config.getTagNamespace = getTagNamespace;
            Vue$3.config.mustUseProp = mustUseProp;

// install platform runtime directives & components
            extend(Vue$3.options.directives, platformDirectives);
            extend(Vue$3.options.components, platformComponents);

// install platform patch function
            Vue$3.prototype.__patch__ = inBrowser ? patch$1 : noop;

// wrap mount
            Vue$3.prototype.$mount = function (el,
                                               hydrating) {
                el = el && inBrowser ? query(el) : undefined;
                return this._mount(el, hydrating)
            };

            if (process.env.NODE_ENV !== 'production' &&
                inBrowser && typeof console !== 'undefined') {
                console[console.info ? 'info' : 'log'](
                    "You are running Vue in development mode.\n" +
                    "Make sure to turn on production mode when deploying for production.\n" +
                    "See more tips at https://vuejs.org/guide/deployment.html"
                );
            }

// devtools global hook
            /* istanbul ignore next */
            setTimeout(function () {
                if (config.devtools) {
                    if (devtools) {
                        devtools.emit('init', Vue$3);
                    } else if (
                        process.env.NODE_ENV !== 'production' &&
                        inBrowser && !isEdge && /Chrome\/\d+/.test(window.navigator.userAgent)
                    ) {
                        console[console.info ? 'info' : 'log'](
                            'Download the Vue Devtools extension for a better development experience:\n' +
                            'https://github.com/vuejs/vue-devtools'
                        );
                    }
                }
            }, 0);

            /*  */

// check whether current browser encodes a char inside attribute values
            function shouldDecode(content, encoded) {
                var div = document.createElement('div');
                div.innerHTML = "<div a=\"" + content + "\">";
                return div.innerHTML.indexOf(encoded) > 0
            }

// #3663
// IE encodes newlines inside attribute values while other browsers don't
            var shouldDecodeNewlines = inBrowser ? shouldDecode('\n', '&#10;') : false;

            /*  */

            var decoder;

            function decode(html) {
                decoder = decoder || document.createElement('div');
                decoder.innerHTML = html;
                return decoder.textContent
            }

            /*  */

            var isUnaryTag = makeMap(
                'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +
                'link,meta,param,source,track,wbr',
                true
            );

// Elements that you can, intentionally, leave open
// (and which close themselves)
            var canBeLeftOpenTag = makeMap(
                'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source',
                true
            );

// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
            var isNonPhrasingTag = makeMap(
                'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +
                'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +
                'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +
                'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +
                'title,tr,track',
                true
            );

            /**
             * Not type-checking this file because it's mostly vendor code.
             */

            /*!
 * HTML Parser By John Resig (ejohn.org)
 * Modified by Juriy "kangax" Zaytsev
 * Original code by Erik Arvidsson, Mozilla Public License
 * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
 */

// Regular Expressions for parsing tags and attributes
            var singleAttrIdentifier = /([^\s"'<>/=]+)/;
            var singleAttrAssign = /(?:=)/;
            var singleAttrValues = [
                // attr value double quotes
                /"([^"]*)"+/.source,
                // attr value, single quotes
                /'([^']*)'+/.source,
                // attr value, no quotes
                /([^\s"'=<>`]+)/.source
            ];
            var attribute = new RegExp(
                '^\\s*' + singleAttrIdentifier.source +
                '(?:\\s*(' + singleAttrAssign.source + ')' +
                '\\s*(?:' + singleAttrValues.join('|') + '))?'
            );

// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName
// but for Vue templates we can enforce a simple charset
            var ncname = '[a-zA-Z_][\\w\\-\\.]*';
            var qnameCapture = '((?:' + ncname + '\\:)?' + ncname + ')';
            var startTagOpen = new RegExp('^<' + qnameCapture);
            var startTagClose = /^\s*(\/?)>/;
            var endTag = new RegExp('^<\\/' + qnameCapture + '[^>]*>');
            var doctype = /^<!DOCTYPE [^>]+>/i;
            var comment = /^<!--/;
            var conditionalComment = /^<!\[/;

            var IS_REGEX_CAPTURING_BROKEN = false;
            'x'.replace(/x(.)?/g, function (m, g) {
                IS_REGEX_CAPTURING_BROKEN = g === '';
            });

// Special Elements (can contain anything)
            var isScriptOrStyle = makeMap('script,style', true);
            var reCache = {};

            var ltRE = /&lt;/g;
            var gtRE = /&gt;/g;
            var nlRE = /&#10;/g;
            var ampRE = /&amp;/g;
            var quoteRE = /&quot;/g;

            function decodeAttr(value, shouldDecodeNewlines) {
                if (shouldDecodeNewlines) {
                    value = value.replace(nlRE, '\n');
                }
                return value
                    .replace(ltRE, '<')
                    .replace(gtRE, '>')
                    .replace(ampRE, '&')
                    .replace(quoteRE, '"')
            }

            function parseHTML(html, options) {
                var stack = [];
                var expectHTML = options.expectHTML;
                var isUnaryTag$$1 = options.isUnaryTag || no;
                var index = 0;
                var last, lastTag;
                while (html) {
                    last = html;
                    // Make sure we're not in a script or style element
                    if (!lastTag || !isScriptOrStyle(lastTag)) {
                        var textEnd = html.indexOf('<');
                        if (textEnd === 0) {
                            // Comment:
                            if (comment.test(html)) {
                                var commentEnd = html.indexOf('-->');

                                if (commentEnd >= 0) {
                                    advance(commentEnd + 3);
                                    continue
                                }
                            }

                            // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
                            if (conditionalComment.test(html)) {
                                var conditionalEnd = html.indexOf(']>');

                                if (conditionalEnd >= 0) {
                                    advance(conditionalEnd + 2);
                                    continue
                                }
                            }

                            // Doctype:
                            var doctypeMatch = html.match(doctype);
                            if (doctypeMatch) {
                                advance(doctypeMatch[0].length);
                                continue
                            }

                            // End tag:
                            var endTagMatch = html.match(endTag);
                            if (endTagMatch) {
                                var curIndex = index;
                                advance(endTagMatch[0].length);
                                parseEndTag(endTagMatch[1], curIndex, index);
                                continue
                            }

                            // Start tag:
                            var startTagMatch = parseStartTag();
                            if (startTagMatch) {
                                handleStartTag(startTagMatch);
                                continue
                            }
                        }

                        var text = (void 0), rest$1 = (void 0), next = (void 0);
                        if (textEnd > 0) {
                            rest$1 = html.slice(textEnd);
                            while (
                                !endTag.test(rest$1) &&
                                !startTagOpen.test(rest$1) &&
                                !comment.test(rest$1) &&
                                !conditionalComment.test(rest$1)
                                ) {
                                // < in plain text, be forgiving and treat it as text
                                next = rest$1.indexOf('<', 1);
                                if (next < 0) {
                                    break
                                }
                                textEnd += next;
                                rest$1 = html.slice(textEnd);
                            }
                            text = html.substring(0, textEnd);
                            advance(textEnd);
                        }

                        if (textEnd < 0) {
                            text = html;
                            html = '';
                        }

                        if (options.chars && text) {
                            options.chars(text);
                        }
                    } else {
                        var stackedTag = lastTag.toLowerCase();
                        var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
                        var endTagLength = 0;
                        var rest = html.replace(reStackedTag, function (all, text, endTag) {
                            endTagLength = endTag.length;
                            if (stackedTag !== 'script' && stackedTag !== 'style' && stackedTag !== 'noscript') {
                                text = text
                                    .replace(/<!--([\s\S]*?)-->/g, '$1')
                                    .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
                            }
                            if (options.chars) {
                                options.chars(text);
                            }
                            return ''
                        });
                        index += html.length - rest.length;
                        html = rest;
                        parseEndTag(stackedTag, index - endTagLength, index);
                    }

                    if (html === last && options.chars) {
                        options.chars(html);
                        break
                    }
                }

                // Clean up any remaining tags
                parseEndTag();

                function advance(n) {
                    index += n;
                    html = html.substring(n);
                }

                function parseStartTag() {
                    var start = html.match(startTagOpen);
                    if (start) {
                        var match = {
                            tagName: start[1],
                            attrs: [],
                            start: index
                        };
                        advance(start[0].length);
                        var end, attr;
                        while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {
                            advance(attr[0].length);
                            match.attrs.push(attr);
                        }
                        if (end) {
                            match.unarySlash = end[1];
                            advance(end[0].length);
                            match.end = index;
                            return match
                        }
                    }
                }

                function handleStartTag(match) {
                    var tagName = match.tagName;
                    var unarySlash = match.unarySlash;

                    if (expectHTML) {
                        if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
                            parseEndTag(lastTag);
                        }
                        if (canBeLeftOpenTag(tagName) && lastTag === tagName) {
                            parseEndTag(tagName);
                        }
                    }

                    var unary = isUnaryTag$$1(tagName) || tagName === 'html' && lastTag === 'head' || !!unarySlash;

                    var l = match.attrs.length;
                    var attrs = new Array(l);
                    for (var i = 0; i < l; i++) {
                        var args = match.attrs[i];
                        // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778
                        if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('""') === -1) {
                            if (args[3] === '') {
                                delete args[3];
                            }
                            if (args[4] === '') {
                                delete args[4];
                            }
                            if (args[5] === '') {
                                delete args[5];
                            }
                        }
                        var value = args[3] || args[4] || args[5] || '';
                        attrs[i] = {
                            name: args[1],
                            value: decodeAttr(
                                value,
                                options.shouldDecodeNewlines
                            )
                        };
                    }

                    if (!unary) {
                        stack.push({tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs});
                        lastTag = tagName;
                        unarySlash = '';
                    }

                    if (options.start) {
                        options.start(tagName, attrs, unary, match.start, match.end);
                    }
                }

                function parseEndTag(tagName, start, end) {
                    var pos, lowerCasedTagName;
                    if (start == null) {
                        start = index;
                    }
                    if (end == null) {
                        end = index;
                    }

                    if (tagName) {
                        lowerCasedTagName = tagName.toLowerCase();
                    }

                    // Find the closest opened tag of the same type
                    if (tagName) {
                        for (pos = stack.length - 1; pos >= 0; pos--) {
                            if (stack[pos].lowerCasedTag === lowerCasedTagName) {
                                break
                            }
                        }
                    } else {
                        // If no tag name is provided, clean shop
                        pos = 0;
                    }

                    if (pos >= 0) {
                        // Close all the open elements, up the stack
                        for (var i = stack.length - 1; i >= pos; i--) {
                            if (options.end) {
                                options.end(stack[i].tag, start, end);
                            }
                        }

                        // Remove the open elements from the stack
                        stack.length = pos;
                        lastTag = pos && stack[pos - 1].tag;
                    } else if (lowerCasedTagName === 'br') {
                        if (options.start) {
                            options.start(tagName, [], true, start, end);
                        }
                    } else if (lowerCasedTagName === 'p') {
                        if (options.start) {
                            options.start(tagName, [], false, start, end);
                        }
                        if (options.end) {
                            options.end(tagName, start, end);
                        }
                    }
                }
            }

            /*  */

            function parseFilters(exp) {
                var inSingle = false;
                var inDouble = false;
                var inTemplateString = false;
                var inRegex = false;
                var curly = 0;
                var square = 0;
                var paren = 0;
                var lastFilterIndex = 0;
                var c, prev, i, expression, filters;

                for (i = 0; i < exp.length; i++) {
                    prev = c;
                    c = exp.charCodeAt(i);
                    if (inSingle) {
                        if (c === 0x27 && prev !== 0x5C) {
                            inSingle = false;
                        }
                    } else if (inDouble) {
                        if (c === 0x22 && prev !== 0x5C) {
                            inDouble = false;
                        }
                    } else if (inTemplateString) {
                        if (c === 0x60 && prev !== 0x5C) {
                            inTemplateString = false;
                        }
                    } else if (inRegex) {
                        if (c === 0x2f && prev !== 0x5C) {
                            inRegex = false;
                        }
                    } else if (
                        c === 0x7C && // pipe
                        exp.charCodeAt(i + 1) !== 0x7C &&
                        exp.charCodeAt(i - 1) !== 0x7C &&
                        !curly && !square && !paren
                    ) {
                        if (expression === undefined) {
                            // first filter, end of expression
                            lastFilterIndex = i + 1;
                            expression = exp.slice(0, i).trim();
                        } else {
                            pushFilter();
                        }
                    } else {
                        switch (c) {
                            case 0x22:
                                inDouble = true;
                                break         // "
                            case 0x27:
                                inSingle = true;
                                break         // '
                            case 0x60:
                                inTemplateString = true;
                                break // `
                            case 0x28:
                                paren++;
                                break                 // (
                            case 0x29:
                                paren--;
                                break                 // )
                            case 0x5B:
                                square++;
                                break                // [
                            case 0x5D:
                                square--;
                                break                // ]
                            case 0x7B:
                                curly++;
                                break                 // {
                            case 0x7D:
                                curly--;
                                break                 // }
                        }
                        if (c === 0x2f) { // /
                            var j = i - 1;
                            var p = (void 0);
                            // find first non-whitespace prev char
                            for (; j >= 0; j--) {
                                p = exp.charAt(j);
                                if (p !== ' ') {
                                    break
                                }
                            }
                            if (!p || !/[\w$]/.test(p)) {
                                inRegex = true;
                            }
                        }
                    }
                }

                if (expression === undefined) {
                    expression = exp.slice(0, i).trim();
                } else if (lastFilterIndex !== 0) {
                    pushFilter();
                }

                function pushFilter() {
                    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
                    lastFilterIndex = i + 1;
                }

                if (filters) {
                    for (i = 0; i < filters.length; i++) {
                        expression = wrapFilter(expression, filters[i]);
                    }
                }

                return expression
            }

            function wrapFilter(exp, filter) {
                var i = filter.indexOf('(');
                if (i < 0) {
                    // _f: resolveFilter
                    return ("_f(\"" + filter + "\")(" + exp + ")")
                } else {
                    var name = filter.slice(0, i);
                    var args = filter.slice(i + 1);
                    return ("_f(\"" + name + "\")(" + exp + "," + args)
                }
            }

            /*  */

            var defaultTagRE = /\{\{((?:.|\n)+?)\}\}/g;
            var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;

            var buildRegex = cached(function (delimiters) {
                var open = delimiters[0].replace(regexEscapeRE, '\\$&');
                var close = delimiters[1].replace(regexEscapeRE, '\\$&');
                return new RegExp(open + '((?:.|\\n)+?)' + close, 'g')
            });

            function parseText(text,
                               delimiters) {
                var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
                if (!tagRE.test(text)) {
                    return
                }
                var tokens = [];
                var lastIndex = tagRE.lastIndex = 0;
                var match, index;
                while ((match = tagRE.exec(text))) {
                    index = match.index;
                    // push text token
                    if (index > lastIndex) {
                        tokens.push(JSON.stringify(text.slice(lastIndex, index)));
                    }
                    // tag token
                    var exp = parseFilters(match[1].trim());
                    tokens.push(("_s(" + exp + ")"));
                    lastIndex = index + match[0].length;
                }
                if (lastIndex < text.length) {
                    tokens.push(JSON.stringify(text.slice(lastIndex)));
                }
                return tokens.join('+')
            }

            /*  */

            function baseWarn(msg) {
                console.error(("[Vue parser]: " + msg));
            }

            function pluckModuleFunction(modules,
                                         key) {
                return modules
                    ? modules.map(function (m) {
                        return m[key];
                    }).filter(function (_) {
                        return _;
                    })
                    : []
            }

            function addProp(el, name, value) {
                (el.props || (el.props = [])).push({name: name, value: value});
            }

            function addAttr(el, name, value) {
                (el.attrs || (el.attrs = [])).push({name: name, value: value});
            }

            function addDirective(el,
                                  name,
                                  rawName,
                                  value,
                                  arg,
                                  modifiers) {
                (el.directives || (el.directives = [])).push({
                    name: name,
                    rawName: rawName,
                    value: value,
                    arg: arg,
                    modifiers: modifiers
                });
            }

            function addHandler(el,
                                name,
                                value,
                                modifiers,
                                important) {
                // check capture modifier
                if (modifiers && modifiers.capture) {
                    delete modifiers.capture;
                    name = '!' + name; // mark the event as captured
                }
                if (modifiers && modifiers.once) {
                    delete modifiers.once;
                    name = '~' + name; // mark the event as once
                }
                var events;
                if (modifiers && modifiers.native) {
                    delete modifiers.native;
                    events = el.nativeEvents || (el.nativeEvents = {});
                } else {
                    events = el.events || (el.events = {});
                }
                var newHandler = {value: value, modifiers: modifiers};
                var handlers = events[name];
                /* istanbul ignore if */
                if (Array.isArray(handlers)) {
                    important ? handlers.unshift(newHandler) : handlers.push(newHandler);
                } else if (handlers) {
                    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
                } else {
                    events[name] = newHandler;
                }
            }

            function getBindingAttr(el,
                                    name,
                                    getStatic) {
                var dynamicValue =
                    getAndRemoveAttr(el, ':' + name) ||
                    getAndRemoveAttr(el, 'v-bind:' + name);
                if (dynamicValue != null) {
                    return parseFilters(dynamicValue)
                } else if (getStatic !== false) {
                    var staticValue = getAndRemoveAttr(el, name);
                    if (staticValue != null) {
                        return JSON.stringify(staticValue)
                    }
                }
            }

            function getAndRemoveAttr(el, name) {
                var val;
                if ((val = el.attrsMap[name]) != null) {
                    var list = el.attrsList;
                    for (var i = 0, l = list.length; i < l; i++) {
                        if (list[i].name === name) {
                            list.splice(i, 1);
                            break
                        }
                    }
                }
                return val
            }

            var len;
            var str;
            var chr;
            var index$1;
            var expressionPos;
            var expressionEndPos;

            /**
             * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)
             *
             * for loop possible cases:
             *
             * - test
             * - test[idx]
             * - test[test1[idx]]
             * - test["a"][idx]
             * - xxx.test[a[a].test1[idx]]
             * - test.xxx.a["asa"][test1[idx]]
             *
             */

            function parseModel(val) {
                str = val;
                len = str.length;
                index$1 = expressionPos = expressionEndPos = 0;

                if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
                    return {
                        exp: val,
                        idx: null
                    }
                }

                while (!eof()) {
                    chr = next();
                    /* istanbul ignore if */
                    if (isStringStart(chr)) {
                        parseString(chr);
                    } else if (chr === 0x5B) {
                        parseBracket(chr);
                    }
                }

                return {
                    exp: val.substring(0, expressionPos),
                    idx: val.substring(expressionPos + 1, expressionEndPos)
                }
            }

            function next() {
                return str.charCodeAt(++index$1)
            }

            function eof() {
                return index$1 >= len
            }

            function isStringStart(chr) {
                return chr === 0x22 || chr === 0x27
            }

            function parseBracket(chr) {
                var inBracket = 1;
                expressionPos = index$1;
                while (!eof()) {
                    chr = next();
                    if (isStringStart(chr)) {
                        parseString(chr);
                        continue
                    }
                    if (chr === 0x5B) {
                        inBracket++;
                    }
                    if (chr === 0x5D) {
                        inBracket--;
                    }
                    if (inBracket === 0) {
                        expressionEndPos = index$1;
                        break
                    }
                }
            }

            function parseString(chr) {
                var stringQuote = chr;
                while (!eof()) {
                    chr = next();
                    if (chr === stringQuote) {
                        break
                    }
                }
            }

            /*  */

            var dirRE = /^v-|^@|^:/;
            var forAliasRE = /(.*?)\s+(?:in|of)\s+(.*)/;
            var forIteratorRE = /\((\{[^}]*\}|[^,]*),([^,]*)(?:,([^,]*))?\)/;
            var bindRE = /^:|^v-bind:/;
            var onRE = /^@|^v-on:/;
            var argRE = /:(.*)$/;
            var modifierRE = /\.[^.]+/g;

            var decodeHTMLCached = cached(decode);

// configurable state
            var warn$1;
            var platformGetTagNamespace;
            var platformMustUseProp;
            var platformIsPreTag;
            var preTransforms;
            var transforms;
            var postTransforms;
            var delimiters;

            /**
             * Convert HTML string to AST.
             */
            function parse(template,
                           options) {
                warn$1 = options.warn || baseWarn;
                platformGetTagNamespace = options.getTagNamespace || no;
                platformMustUseProp = options.mustUseProp || no;
                platformIsPreTag = options.isPreTag || no;
                preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
                transforms = pluckModuleFunction(options.modules, 'transformNode');
                postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');
                delimiters = options.delimiters;
                var stack = [];
                var preserveWhitespace = options.preserveWhitespace !== false;
                var root;
                var currentParent;
                var inVPre = false;
                var inPre = false;
                var warned = false;
                parseHTML(template, {
                    expectHTML: options.expectHTML,
                    isUnaryTag: options.isUnaryTag,
                    shouldDecodeNewlines: options.shouldDecodeNewlines,
                    start: function start(tag, attrs, unary) {
                        // check namespace.
                        // inherit parent ns if there is one
                        var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);

                        // handle IE svg bug
                        /* istanbul ignore if */
                        if (isIE && ns === 'svg') {
                            attrs = guardIESVGBug(attrs);
                        }

                        var element = {
                            type: 1,
                            tag: tag,
                            attrsList: attrs,
                            attrsMap: makeAttrsMap(attrs),
                            parent: currentParent,
                            children: []
                        };
                        if (ns) {
                            element.ns = ns;
                        }

                        if (isForbiddenTag(element) && !isServerRendering()) {
                            element.forbidden = true;
                            process.env.NODE_ENV !== 'production' && warn$1(
                                'Templates should only be responsible for mapping the state to the ' +
                                'UI. Avoid placing tags with side-effects in your templates, such as ' +
                                "<" + tag + ">" + ', as they will not be parsed.'
                            );
                        }

                        // apply pre-transforms
                        for (var i = 0; i < preTransforms.length; i++) {
                            preTransforms[i](element, options);
                        }

                        if (!inVPre) {
                            processPre(element);
                            if (element.pre) {
                                inVPre = true;
                            }
                        }
                        if (platformIsPreTag(element.tag)) {
                            inPre = true;
                        }
                        if (inVPre) {
                            processRawAttrs(element);
                        } else {
                            processFor(element);
                            processIf(element);
                            processOnce(element);
                            processKey(element);

                            // determine whether this is a plain element after
                            // removing structural attributes
                            element.plain = !element.key && !attrs.length;

                            processRef(element);
                            processSlot(element);
                            processComponent(element);
                            for (var i$1 = 0; i$1 < transforms.length; i$1++) {
                                transforms[i$1](element, options);
                            }
                            processAttrs(element);
                        }

                        function checkRootConstraints(el) {
                            if (process.env.NODE_ENV !== 'production' && !warned) {
                                if (el.tag === 'slot' || el.tag === 'template') {
                                    warned = true;
                                    warn$1(
                                        "Cannot use <" + (el.tag) + "> as component root element because it may " +
                                        'contain multiple nodes:\n' + template
                                    );
                                }
                                if (el.attrsMap.hasOwnProperty('v-for')) {
                                    warned = true;
                                    warn$1(
                                        'Cannot use v-for on stateful component root element because ' +
                                        'it renders multiple elements:\n' + template
                                    );
                                }
                            }
                        }

                        // tree management
                        if (!root) {
                            root = element;
                            checkRootConstraints(root);
                        } else if (!stack.length) {
                            // allow root elements with v-if, v-else-if and v-else
                            if (root.if && (element.elseif || element.else)) {
                                checkRootConstraints(element);
                                addIfCondition(root, {
                                    exp: element.elseif,
                                    block: element
                                });
                            } else if (process.env.NODE_ENV !== 'production' && !warned) {
                                warned = true;
                                warn$1(
                                    "Component template should contain exactly one root element:" +
                                    "\n\n" + template + "\n\n" +
                                    "If you are using v-if on multiple elements, " +
                                    "use v-else-if to chain them instead."
                                );
                            }
                        }
                        if (currentParent && !element.forbidden) {
                            if (element.elseif || element.else) {
                                processIfConditions(element, currentParent);
                            } else if (element.slotScope) { // scoped slot
                                currentParent.plain = false;
                                var name = element.slotTarget || 'default';
                                (currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
                            } else {
                                currentParent.children.push(element);
                                element.parent = currentParent;
                            }
                        }
                        if (!unary) {
                            currentParent = element;
                            stack.push(element);
                        }
                        // apply post-transforms
                        for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {
                            postTransforms[i$2](element, options);
                        }
                    },

                    end: function end() {
                        // remove trailing whitespace
                        var element = stack[stack.length - 1];
                        var lastNode = element.children[element.children.length - 1];
                        if (lastNode && lastNode.type === 3 && lastNode.text === ' ') {
                            element.children.pop();
                        }
                        // pop stack
                        stack.length -= 1;
                        currentParent = stack[stack.length - 1];
                        // check pre state
                        if (element.pre) {
                            inVPre = false;
                        }
                        if (platformIsPreTag(element.tag)) {
                            inPre = false;
                        }
                    },

                    chars: function chars(text) {
                        if (!currentParent) {
                            if (process.env.NODE_ENV !== 'production' && !warned && text === template) {
                                warned = true;
                                warn$1(
                                    'Component template requires a root element, rather than just text:\n\n' + template
                                );
                            }
                            return
                        }
                        // IE textarea placeholder bug
                        /* istanbul ignore if */
                        if (isIE &&
                            currentParent.tag === 'textarea' &&
                            currentParent.attrsMap.placeholder === text) {
                            return
                        }
                        var children = currentParent.children;
                        text = inPre || text.trim()
                            ? decodeHTMLCached(text)
                            // only preserve whitespace if its not right after a starting tag
                            : preserveWhitespace && children.length ? ' ' : '';
                        if (text) {
                            var expression;
                            if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {
                                children.push({
                                    type: 2,
                                    expression: expression,
                                    text: text
                                });
                            } else if (text !== ' ' || children[children.length - 1].text !== ' ') {
                                currentParent.children.push({
                                    type: 3,
                                    text: text
                                });
                            }
                        }
                    }
                });
                return root
            }

            function processPre(el) {
                if (getAndRemoveAttr(el, 'v-pre') != null) {
                    el.pre = true;
                }
            }

            function processRawAttrs(el) {
                var l = el.attrsList.length;
                if (l) {
                    var attrs = el.attrs = new Array(l);
                    for (var i = 0; i < l; i++) {
                        attrs[i] = {
                            name: el.attrsList[i].name,
                            value: JSON.stringify(el.attrsList[i].value)
                        };
                    }
                } else if (!el.pre) {
                    // non root node in pre blocks with no attributes
                    el.plain = true;
                }
            }

            function processKey(el) {
                var exp = getBindingAttr(el, 'key');
                if (exp) {
                    if (process.env.NODE_ENV !== 'production' && el.tag === 'template') {
                        warn$1("<template> cannot be keyed. Place the key on real elements instead.");
                    }
                    el.key = exp;
                }
            }

            function processRef(el) {
                var ref = getBindingAttr(el, 'ref');
                if (ref) {
                    el.ref = ref;
                    el.refInFor = checkInFor(el);
                }
            }

            function processFor(el) {
                var exp;
                if ((exp = getAndRemoveAttr(el, 'v-for'))) {
                    var inMatch = exp.match(forAliasRE);
                    if (!inMatch) {
                        process.env.NODE_ENV !== 'production' && warn$1(
                            ("Invalid v-for expression: " + exp)
                        );
                        return
                    }
                    el.for = inMatch[2].trim();
                    var alias = inMatch[1].trim();
                    var iteratorMatch = alias.match(forIteratorRE);
                    if (iteratorMatch) {
                        el.alias = iteratorMatch[1].trim();
                        el.iterator1 = iteratorMatch[2].trim();
                        if (iteratorMatch[3]) {
                            el.iterator2 = iteratorMatch[3].trim();
                        }
                    } else {
                        el.alias = alias;
                    }
                }
            }

            function processIf(el) {
                var exp = getAndRemoveAttr(el, 'v-if');
                if (exp) {
                    el.if = exp;
                    addIfCondition(el, {
                        exp: exp,
                        block: el
                    });
                } else {
                    if (getAndRemoveAttr(el, 'v-else') != null) {
                        el.else = true;
                    }
                    var elseif = getAndRemoveAttr(el, 'v-else-if');
                    if (elseif) {
                        el.elseif = elseif;
                    }
                }
            }

            function processIfConditions(el, parent) {
                var prev = findPrevElement(parent.children);
                if (prev && prev.if) {
                    addIfCondition(prev, {
                        exp: el.elseif,
                        block: el
                    });
                } else if (process.env.NODE_ENV !== 'production') {
                    warn$1(
                        "v-" + (el.elseif ? ('else-if="' + el.elseif + '"') : 'else') + " " +
                        "used on element <" + (el.tag) + "> without corresponding v-if."
                    );
                }
            }

            function findPrevElement(children) {
                var i = children.length;
                while (i--) {
                    if (children[i].type === 1) {
                        return children[i]
                    } else {
                        if (process.env.NODE_ENV !== 'production' && children[i].text !== ' ') {
                            warn$1(
                                "text \"" + (children[i].text.trim()) + "\" between v-if and v-else(-if) " +
                                "will be ignored."
                            );
                        }
                        children.pop();
                    }
                }
            }

            function addIfCondition(el, condition) {
                if (!el.ifConditions) {
                    el.ifConditions = [];
                }
                el.ifConditions.push(condition);
            }

            function processOnce(el) {
                var once = getAndRemoveAttr(el, 'v-once');
                if (once != null) {
                    el.once = true;
                }
            }

            function processSlot(el) {
                if (el.tag === 'slot') {
                    el.slotName = getBindingAttr(el, 'name');
                    if (process.env.NODE_ENV !== 'production' && el.key) {
                        warn$1(
                            "`key` does not work on <slot> because slots are abstract outlets " +
                            "and can possibly expand into multiple elements. " +
                            "Use the key on a wrapping element instead."
                        );
                    }
                } else {
                    var slotTarget = getBindingAttr(el, 'slot');
                    if (slotTarget) {
                        el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
                    }
                    if (el.tag === 'template') {
                        el.slotScope = getAndRemoveAttr(el, 'scope');
                    }
                }
            }

            function processComponent(el) {
                var binding;
                if ((binding = getBindingAttr(el, 'is'))) {
                    el.component = binding;
                }
                if (getAndRemoveAttr(el, 'inline-template') != null) {
                    el.inlineTemplate = true;
                }
            }

            function processAttrs(el) {
                var list = el.attrsList;
                var i, l, name, rawName, value, arg, modifiers, isProp;
                for (i = 0, l = list.length; i < l; i++) {
                    name = rawName = list[i].name;
                    value = list[i].value;
                    if (dirRE.test(name)) {
                        // mark element as dynamic
                        el.hasBindings = true;
                        // modifiers
                        modifiers = parseModifiers(name);
                        if (modifiers) {
                            name = name.replace(modifierRE, '');
                        }
                        if (bindRE.test(name)) { // v-bind
                            name = name.replace(bindRE, '');
                            value = parseFilters(value);
                            isProp = false;
                            if (modifiers) {
                                if (modifiers.prop) {
                                    isProp = true;
                                    name = camelize(name);
                                    if (name === 'innerHtml') {
                                        name = 'innerHTML';
                                    }
                                }
                                if (modifiers.camel) {
                                    name = camelize(name);
                                }
                            }
                            if (isProp || platformMustUseProp(el.tag, el.attrsMap.type, name)) {
                                addProp(el, name, value);
                            } else {
                                addAttr(el, name, value);
                            }
                        } else if (onRE.test(name)) { // v-on
                            name = name.replace(onRE, '');
                            addHandler(el, name, value, modifiers);
                        } else { // normal directives
                            name = name.replace(dirRE, '');
                            // parse arg
                            var argMatch = name.match(argRE);
                            if (argMatch && (arg = argMatch[1])) {
                                name = name.slice(0, -(arg.length + 1));
                            }
                            addDirective(el, name, rawName, value, arg, modifiers);
                            if (process.env.NODE_ENV !== 'production' && name === 'model') {
                                checkForAliasModel(el, value);
                            }
                        }
                    } else {
                        // literal attribute
                        if (process.env.NODE_ENV !== 'production') {
                            var expression = parseText(value, delimiters);
                            if (expression) {
                                warn$1(
                                    name + "=\"" + value + "\": " +
                                    'Interpolation inside attributes has been removed. ' +
                                    'Use v-bind or the colon shorthand instead. For example, ' +
                                    'instead of <div id="{{ val }}">, use <div :id="val">.'
                                );
                            }
                        }
                        addAttr(el, name, JSON.stringify(value));
                    }
                }
            }

            function checkInFor(el) {
                var parent = el;
                while (parent) {
                    if (parent.for !== undefined) {
                        return true
                    }
                    parent = parent.parent;
                }
                return false
            }

            function parseModifiers(name) {
                var match = name.match(modifierRE);
                if (match) {
                    var ret = {};
                    match.forEach(function (m) {
                        ret[m.slice(1)] = true;
                    });
                    return ret
                }
            }

            function makeAttrsMap(attrs) {
                var map = {};
                for (var i = 0, l = attrs.length; i < l; i++) {
                    if (process.env.NODE_ENV !== 'production' && map[attrs[i].name] && !isIE) {
                        warn$1('duplicate attribute: ' + attrs[i].name);
                    }
                    map[attrs[i].name] = attrs[i].value;
                }
                return map
            }

            function isForbiddenTag(el) {
                return (
                    el.tag === 'style' ||
                    (el.tag === 'script' && (
                        !el.attrsMap.type ||
                        el.attrsMap.type === 'text/javascript'
                    ))
                )
            }

            var ieNSBug = /^xmlns:NS\d+/;
            var ieNSPrefix = /^NS\d+:/;

            /* istanbul ignore next */
            function guardIESVGBug(attrs) {
                var res = [];
                for (var i = 0; i < attrs.length; i++) {
                    var attr = attrs[i];
                    if (!ieNSBug.test(attr.name)) {
                        attr.name = attr.name.replace(ieNSPrefix, '');
                        res.push(attr);
                    }
                }
                return res
            }

            function checkForAliasModel(el, value) {
                var _el = el;
                while (_el) {
                    if (_el.for && _el.alias === value) {
                        warn$1(
                            "<" + (el.tag) + " v-model=\"" + value + "\">: " +
                            "You are binding v-model directly to a v-for iteration alias. " +
                            "This will not be able to modify the v-for source array because " +
                            "writing to the alias is like modifying a function local variable. " +
                            "Consider using an array of objects and use v-model on an object property instead."
                        );
                    }
                    _el = _el.parent;
                }
            }

            /*  */

            var isStaticKey;
            var isPlatformReservedTag;

            var genStaticKeysCached = cached(genStaticKeys$1);

            /**
             * Goal of the optimizer: walk the generated template AST tree
             * and detect sub-trees that are purely static, i.e. parts of
             * the DOM that never needs to change.
             *
             * Once we detect these sub-trees, we can:
             *
             * 1. Hoist them into constants, so that we no longer need to
             *    create fresh nodes for them on each re-render;
             * 2. Completely skip them in the patching process.
             */
            function optimize(root, options) {
                if (!root) {
                    return
                }
                isStaticKey = genStaticKeysCached(options.staticKeys || '');
                isPlatformReservedTag = options.isReservedTag || no;
                // first pass: mark all non-static nodes.
                markStatic(root);
                // second pass: mark static roots.
                markStaticRoots(root, false);
            }

            function genStaticKeys$1(keys) {
                return makeMap(
                    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +
                    (keys ? ',' + keys : '')
                )
            }

            function markStatic(node) {
                node.static = isStatic(node);
                if (node.type === 1) {
                    // do not make component slot content static. this avoids
                    // 1. components not able to mutate slot nodes
                    // 2. static slot content fails for hot-reloading
                    if (
                        !isPlatformReservedTag(node.tag) &&
                        node.tag !== 'slot' &&
                        node.attrsMap['inline-template'] == null
                    ) {
                        return
                    }
                    for (var i = 0, l = node.children.length; i < l; i++) {
                        var child = node.children[i];
                        markStatic(child);
                        if (!child.static) {
                            node.static = false;
                        }
                    }
                }
            }

            function markStaticRoots(node, isInFor) {
                if (node.type === 1) {
                    if (node.static || node.once) {
                        node.staticInFor = isInFor;
                    }
                    // For a node to qualify as a static root, it should have children that
                    // are not just static text. Otherwise the cost of hoisting out will
                    // outweigh the benefits and it's better off to just always render it fresh.
                    if (node.static && node.children.length && !(
                            node.children.length === 1 &&
                            node.children[0].type === 3
                        )) {
                        node.staticRoot = true;
                        return
                    } else {
                        node.staticRoot = false;
                    }
                    if (node.children) {
                        for (var i = 0, l = node.children.length; i < l; i++) {
                            markStaticRoots(node.children[i], isInFor || !!node.for);
                        }
                    }
                    if (node.ifConditions) {
                        walkThroughConditionsBlocks(node.ifConditions, isInFor);
                    }
                }
            }

            function walkThroughConditionsBlocks(conditionBlocks, isInFor) {
                for (var i = 1, len = conditionBlocks.length; i < len; i++) {
                    markStaticRoots(conditionBlocks[i].block, isInFor);
                }
            }

            function isStatic(node) {
                if (node.type === 2) { // expression
                    return false
                }
                if (node.type === 3) { // text
                    return true
                }
                return !!(node.pre || (
                    !node.hasBindings && // no dynamic bindings
                    !node.if && !node.for && // not v-if or v-for or v-else
                    !isBuiltInTag(node.tag) && // not a built-in
                    isPlatformReservedTag(node.tag) && // not a component
                    !isDirectChildOfTemplateFor(node) &&
                    Object.keys(node).every(isStaticKey)
                ))
            }

            function isDirectChildOfTemplateFor(node) {
                while (node.parent) {
                    node = node.parent;
                    if (node.tag !== 'template') {
                        return false
                    }
                    if (node.for) {
                        return true
                    }
                }
                return false
            }

            /*  */

            var fnExpRE = /^\s*([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/;
            var simplePathRE = /^\s*[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?']|\[".*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*\s*$/;

// keyCode aliases
            var keyCodes = {
                esc: 27,
                tab: 9,
                enter: 13,
                space: 32,
                up: 38,
                left: 37,
                right: 39,
                down: 40,
                'delete': [8, 46]
            };

            var modifierCode = {
                stop: '$event.stopPropagation();',
                prevent: '$event.preventDefault();',
                self: 'if($event.target !== $event.currentTarget)return;',
                ctrl: 'if(!$event.ctrlKey)return;',
                shift: 'if(!$event.shiftKey)return;',
                alt: 'if(!$event.altKey)return;',
                meta: 'if(!$event.metaKey)return;'
            };

            function genHandlers(events, native) {
                var res = native ? 'nativeOn:{' : 'on:{';
                for (var name in events) {
                    res += "\"" + name + "\":" + (genHandler(name, events[name])) + ",";
                }
                return res.slice(0, -1) + '}'
            }

            function genHandler(name,
                                handler) {
                if (!handler) {
                    return 'function(){}'
                } else if (Array.isArray(handler)) {
                    return ("[" + (handler.map(function (handler) {
                        return genHandler(name, handler);
                    }).join(',')) + "]")
                } else if (!handler.modifiers) {
                    return fnExpRE.test(handler.value) || simplePathRE.test(handler.value)
                        ? handler.value
                        : ("function($event){" + (handler.value) + "}")
                } else {
                    var code = '';
                    var keys = [];
                    for (var key in handler.modifiers) {
                        if (modifierCode[key]) {
                            code += modifierCode[key];
                        } else {
                            keys.push(key);
                        }
                    }
                    if (keys.length) {
                        code = genKeyFilter(keys) + code;
                    }
                    var handlerCode = simplePathRE.test(handler.value)
                        ? handler.value + '($event)'
                        : handler.value;
                    return 'function($event){' + code + handlerCode + '}'
                }
            }

            function genKeyFilter(keys) {
                return ("if(" + (keys.map(genFilterCode).join('&&')) + ")return;")
            }

            function genFilterCode(key) {
                var keyVal = parseInt(key, 10);
                if (keyVal) {
                    return ("$event.keyCode!==" + keyVal)
                }
                var alias = keyCodes[key];
                return ("_k($event.keyCode," + (JSON.stringify(key)) + (alias ? ',' + JSON.stringify(alias) : '') + ")")
            }

            /*  */

            function bind$2(el, dir) {
                el.wrapData = function (code) {
                    return ("_b(" + code + ",'" + (el.tag) + "'," + (dir.value) + (dir.modifiers && dir.modifiers.prop ? ',true' : '') + ")")
                };
            }

            /*  */

            var baseDirectives = {
                bind: bind$2,
                cloak: noop
            };

            /*  */

// configurable state
            var warn$2;
            var transforms$1;
            var dataGenFns;
            var platformDirectives$1;
            var isPlatformReservedTag$1;
            var staticRenderFns;
            var onceCount;
            var currentOptions;

            function generate(ast,
                              options) {
                // save previous staticRenderFns so generate calls can be nested
                var prevStaticRenderFns = staticRenderFns;
                var currentStaticRenderFns = staticRenderFns = [];
                var prevOnceCount = onceCount;
                onceCount = 0;
                currentOptions = options;
                warn$2 = options.warn || baseWarn;
                transforms$1 = pluckModuleFunction(options.modules, 'transformCode');
                dataGenFns = pluckModuleFunction(options.modules, 'genData');
                platformDirectives$1 = options.directives || {};
                isPlatformReservedTag$1 = options.isReservedTag || no;
                var code = ast ? genElement(ast) : '_c("div")';
                staticRenderFns = prevStaticRenderFns;
                onceCount = prevOnceCount;
                return {
                    render: ("with(this){return " + code + "}"),
                    staticRenderFns: currentStaticRenderFns
                }
            }

            function genElement(el) {
                if (el.staticRoot && !el.staticProcessed) {
                    return genStatic(el)
                } else if (el.once && !el.onceProcessed) {
                    return genOnce(el)
                } else if (el.for && !el.forProcessed) {
                    return genFor(el)
                } else if (el.if && !el.ifProcessed) {
                    return genIf(el)
                } else if (el.tag === 'template' && !el.slotTarget) {
                    return genChildren(el) || 'void 0'
                } else if (el.tag === 'slot') {
                    return genSlot(el)
                } else {
                    // component or element
                    var code;
                    if (el.component) {
                        code = genComponent(el.component, el);
                    } else {
                        var data = el.plain ? undefined : genData(el);

                        var children = el.inlineTemplate ? null : genChildren(el, true);
                        code = "_c('" + (el.tag) + "'" + (data ? ("," + data) : '') + (children ? ("," + children) : '') + ")";
                    }
                    // module transforms
                    for (var i = 0; i < transforms$1.length; i++) {
                        code = transforms$1[i](el, code);
                    }
                    return code
                }
            }

// hoist static sub-trees out
            function genStatic(el) {
                el.staticProcessed = true;
                staticRenderFns.push(("with(this){return " + (genElement(el)) + "}"));
                return ("_m(" + (staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")")
            }

// v-once
            function genOnce(el) {
                el.onceProcessed = true;
                if (el.if && !el.ifProcessed) {
                    return genIf(el)
                } else if (el.staticInFor) {
                    var key = '';
                    var parent = el.parent;
                    while (parent) {
                        if (parent.for) {
                            key = parent.key;
                            break
                        }
                        parent = parent.parent;
                    }
                    if (!key) {
                        process.env.NODE_ENV !== 'production' && warn$2(
                            "v-once can only be used inside v-for that is keyed. "
                        );
                        return genElement(el)
                    }
                    return ("_o(" + (genElement(el)) + "," + (onceCount++) + (key ? ("," + key) : "") + ")")
                } else {
                    return genStatic(el)
                }
            }

            function genIf(el) {
                el.ifProcessed = true; // avoid recursion
                return genIfConditions(el.ifConditions.slice())
            }

            function genIfConditions(conditions) {
                if (!conditions.length) {
                    return '_e()'
                }

                var condition = conditions.shift();
                if (condition.exp) {
                    return ("(" + (condition.exp) + ")?" + (genTernaryExp(condition.block)) + ":" + (genIfConditions(conditions)))
                } else {
                    return ("" + (genTernaryExp(condition.block)))
                }

                // v-if with v-once should generate code like (a)?_m(0):_m(1)
                function genTernaryExp(el) {
                    return el.once ? genOnce(el) : genElement(el)
                }
            }

            function genFor(el) {
                var exp = el.for;
                var alias = el.alias;
                var iterator1 = el.iterator1 ? ("," + (el.iterator1)) : '';
                var iterator2 = el.iterator2 ? ("," + (el.iterator2)) : '';
                el.forProcessed = true; // avoid recursion
                return "_l((" + exp + ")," +
                    "function(" + alias + iterator1 + iterator2 + "){" +
                    "return " + (genElement(el)) +
                    '})'
            }

            function genData(el) {
                var data = '{';

                // directives first.
                // directives may mutate the el's other properties before they are generated.
                var dirs = genDirectives(el);
                if (dirs) {
                    data += dirs + ',';
                }

                // key
                if (el.key) {
                    data += "key:" + (el.key) + ",";
                }
                // ref
                if (el.ref) {
                    data += "ref:" + (el.ref) + ",";
                }
                if (el.refInFor) {
                    data += "refInFor:true,";
                }
                // pre
                if (el.pre) {
                    data += "pre:true,";
                }
                // record original tag name for components using "is" attribute
                if (el.component) {
                    data += "tag:\"" + (el.tag) + "\",";
                }
                // module data generation functions
                for (var i = 0; i < dataGenFns.length; i++) {
                    data += dataGenFns[i](el);
                }
                // attributes
                if (el.attrs) {
                    data += "attrs:{" + (genProps(el.attrs)) + "},";
                }
                // DOM props
                if (el.props) {
                    data += "domProps:{" + (genProps(el.props)) + "},";
                }
                // event handlers
                if (el.events) {
                    data += (genHandlers(el.events)) + ",";
                }
                if (el.nativeEvents) {
                    data += (genHandlers(el.nativeEvents, true)) + ",";
                }
                // slot target
                if (el.slotTarget) {
                    data += "slot:" + (el.slotTarget) + ",";
                }
                // scoped slots
                if (el.scopedSlots) {
                    data += (genScopedSlots(el.scopedSlots)) + ",";
                }
                // inline-template
                if (el.inlineTemplate) {
                    var inlineTemplate = genInlineTemplate(el);
                    if (inlineTemplate) {
                        data += inlineTemplate + ",";
                    }
                }
                data = data.replace(/,$/, '') + '}';
                // v-bind data wrap
                if (el.wrapData) {
                    data = el.wrapData(data);
                }
                return data
            }

            function genDirectives(el) {
                var dirs = el.directives;
                if (!dirs) {
                    return
                }
                var res = 'directives:[';
                var hasRuntime = false;
                var i, l, dir, needRuntime;
                for (i = 0, l = dirs.length; i < l; i++) {
                    dir = dirs[i];
                    needRuntime = true;
                    var gen = platformDirectives$1[dir.name] || baseDirectives[dir.name];
                    if (gen) {
                        // compile-time directive that manipulates AST.
                        // returns true if it also needs a runtime counterpart.
                        needRuntime = !!gen(el, dir, warn$2);
                    }
                    if (needRuntime) {
                        hasRuntime = true;
                        res += "{name:\"" + (dir.name) + "\",rawName:\"" + (dir.rawName) + "\"" + (dir.value ? (",value:(" + (dir.value) + "),expression:" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (",arg:\"" + (dir.arg) + "\"") : '') + (dir.modifiers ? (",modifiers:" + (JSON.stringify(dir.modifiers))) : '') + "},";
                    }
                }
                if (hasRuntime) {
                    return res.slice(0, -1) + ']'
                }
            }

            function genInlineTemplate(el) {
                var ast = el.children[0];
                if (process.env.NODE_ENV !== 'production' && (
                        el.children.length > 1 || ast.type !== 1
                    )) {
                    warn$2('Inline-template components must have exactly one child element.');
                }
                if (ast.type === 1) {
                    var inlineRenderFns = generate(ast, currentOptions);
                    return ("inlineTemplate:{render:function(){" + (inlineRenderFns.render) + "},staticRenderFns:[" + (inlineRenderFns.staticRenderFns.map(function (code) {
                        return ("function(){" + code + "}");
                    }).join(',')) + "]}")
                }
            }

            function genScopedSlots(slots) {
                return ("scopedSlots:{" + (Object.keys(slots).map(function (key) {
                    return genScopedSlot(key, slots[key]);
                }).join(',')) + "}")
            }

            function genScopedSlot(key, el) {
                return key + ":function(" + (String(el.attrsMap.scope)) + "){" +
                    "return " + (el.tag === 'template'
                        ? genChildren(el) || 'void 0'
                        : genElement(el)) + "}"
            }

            function genChildren(el, checkSkip) {
                var children = el.children;
                if (children.length) {
                    var el$1 = children[0];
                    // optimize single v-for
                    if (children.length === 1 &&
                        el$1.for &&
                        el$1.tag !== 'template' &&
                        el$1.tag !== 'slot') {
                        return genElement(el$1)
                    }
                    var normalizationType = getNormalizationType(children);
                    return ("[" + (children.map(genNode).join(',')) + "]" + (checkSkip
                        ? normalizationType ? ("," + normalizationType) : ''
                        : ''))
                }
            }

// determine the normalization needed for the children array.
// 0: no normalization needed
// 1: simple normalization needed (possible 1-level deep nested array)
// 2: full normalization needed
            function getNormalizationType(children) {
                var res = 0;
                for (var i = 0; i < children.length; i++) {
                    var el = children[i];
                    if (el.type !== 1) {
                        continue
                    }
                    if (needsNormalization(el) ||
                        (el.ifConditions && el.ifConditions.some(function (c) {
                            return needsNormalization(c.block);
                        }))) {
                        res = 2;
                        break
                    }
                    if (maybeComponent(el) ||
                        (el.ifConditions && el.ifConditions.some(function (c) {
                            return maybeComponent(c.block);
                        }))) {
                        res = 1;
                    }
                }
                return res
            }

            function needsNormalization(el) {
                return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'
            }

            function maybeComponent(el) {
                return !isPlatformReservedTag$1(el.tag)
            }

            function genNode(node) {
                if (node.type === 1) {
                    return genElement(node)
                } else {
                    return genText(node)
                }
            }

            function genText(text) {
                return ("_v(" + (text.type === 2
                    ? text.expression // no need for () because already wrapped in _s()
                    : transformSpecialNewlines(JSON.stringify(text.text))) + ")")
            }

            function genSlot(el) {
                var slotName = el.slotName || '"default"';
                var children = genChildren(el);
                var res = "_t(" + slotName + (children ? ("," + children) : '');
                var attrs = el.attrs && ("{" + (el.attrs.map(function (a) {
                    return ((camelize(a.name)) + ":" + (a.value));
                }).join(',')) + "}");
                var bind$$1 = el.attrsMap['v-bind'];
                if ((attrs || bind$$1) && !children) {
                    res += ",null";
                }
                if (attrs) {
                    res += "," + attrs;
                }
                if (bind$$1) {
                    res += (attrs ? '' : ',null') + "," + bind$$1;
                }
                return res + ')'
            }

// componentName is el.component, take it as argument to shun flow's pessimistic refinement
            function genComponent(componentName, el) {
                var children = el.inlineTemplate ? null : genChildren(el, true);
                return ("_c(" + componentName + "," + (genData(el)) + (children ? ("," + children) : '') + ")")
            }

            function genProps(props) {
                var res = '';
                for (var i = 0; i < props.length; i++) {
                    var prop = props[i];
                    res += "\"" + (prop.name) + "\":" + (transformSpecialNewlines(prop.value)) + ",";
                }
                return res.slice(0, -1)
            }

// #3895, #4268
            function transformSpecialNewlines(text) {
                return text
                    .replace(/\u2028/g, '\\u2028')
                    .replace(/\u2029/g, '\\u2029')
            }

            /*  */

            /**
             * Compile a template.
             */
            function compile$1(template,
                               options) {
                var ast = parse(template.trim(), options);
                optimize(ast, options);
                var code = generate(ast, options);
                return {
                    ast: ast,
                    render: code.render,
                    staticRenderFns: code.staticRenderFns
                }
            }

            /*  */

// operators like typeof, instanceof and in are allowed
            var prohibitedKeywordRE = new RegExp('\\b' + (
                'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +
                'super,throw,while,yield,delete,export,import,return,switch,default,' +
                'extends,finally,continue,debugger,function,arguments'
            ).split(',').join('\\b|\\b') + '\\b');
// check valid identifier for v-for
            var identRE = /[A-Za-z_$][\w$]*/;
// strip strings in expressions
            var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;

// detect problematic expressions in a template
            function detectErrors(ast) {
                var errors = [];
                if (ast) {
                    checkNode(ast, errors);
                }
                return errors
            }

            function checkNode(node, errors) {
                if (node.type === 1) {
                    for (var name in node.attrsMap) {
                        if (dirRE.test(name)) {
                            var value = node.attrsMap[name];
                            if (value) {
                                if (name === 'v-for') {
                                    checkFor(node, ("v-for=\"" + value + "\""), errors);
                                } else {
                                    checkExpression(value, (name + "=\"" + value + "\""), errors);
                                }
                            }
                        }
                    }
                    if (node.children) {
                        for (var i = 0; i < node.children.length; i++) {
                            checkNode(node.children[i], errors);
                        }
                    }
                } else if (node.type === 2) {
                    checkExpression(node.expression, node.text, errors);
                }
            }

            function checkFor(node, text, errors) {
                checkExpression(node.for || '', text, errors);
                checkIdentifier(node.alias, 'v-for alias', text, errors);
                checkIdentifier(node.iterator1, 'v-for iterator', text, errors);
                checkIdentifier(node.iterator2, 'v-for iterator', text, errors);
            }

            function checkIdentifier(ident, type, text, errors) {
                if (typeof ident === 'string' && !identRE.test(ident)) {
                    errors.push(("- invalid " + type + " \"" + ident + "\" in expression: " + text));
                }
            }

            function checkExpression(exp, text, errors) {
                try {
                    new Function(("return " + exp));
                } catch (e) {
                    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);
                    if (keywordMatch) {
                        errors.push(
                            "- avoid using JavaScript keyword as property name: " +
                            "\"" + (keywordMatch[0]) + "\" in expression " + text
                        );
                    } else {
                        errors.push(("- invalid expression: " + text));
                    }
                }
            }

            /*  */

            function transformNode(el, options) {
                var warn = options.warn || baseWarn;
                var staticClass = getAndRemoveAttr(el, 'class');
                if (process.env.NODE_ENV !== 'production' && staticClass) {
                    var expression = parseText(staticClass, options.delimiters);
                    if (expression) {
                        warn(
                            "class=\"" + staticClass + "\": " +
                            'Interpolation inside attributes has been removed. ' +
                            'Use v-bind or the colon shorthand instead. For example, ' +
                            'instead of <div class="{{ val }}">, use <div :class="val">.'
                        );
                    }
                }
                if (staticClass) {
                    el.staticClass = JSON.stringify(staticClass);
                }
                var classBinding = getBindingAttr(el, 'class', false /* getStatic */);
                if (classBinding) {
                    el.classBinding = classBinding;
                }
            }

            function genData$1(el) {
                var data = '';
                if (el.staticClass) {
                    data += "staticClass:" + (el.staticClass) + ",";
                }
                if (el.classBinding) {
                    data += "class:" + (el.classBinding) + ",";
                }
                return data
            }

            var klass$1 = {
                staticKeys: ['staticClass'],
                transformNode: transformNode,
                genData: genData$1
            };

            /*  */

            function transformNode$1(el, options) {
                var warn = options.warn || baseWarn;
                var staticStyle = getAndRemoveAttr(el, 'style');
                if (staticStyle) {
                    /* istanbul ignore if */
                    if (process.env.NODE_ENV !== 'production') {
                        var expression = parseText(staticStyle, options.delimiters);
                        if (expression) {
                            warn(
                                "style=\"" + staticStyle + "\": " +
                                'Interpolation inside attributes has been removed. ' +
                                'Use v-bind or the colon shorthand instead. For example, ' +
                                'instead of <div style="{{ val }}">, use <div :style="val">.'
                            );
                        }
                    }
                    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
                }

                var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
                if (styleBinding) {
                    el.styleBinding = styleBinding;
                }
            }

            function genData$2(el) {
                var data = '';
                if (el.staticStyle) {
                    data += "staticStyle:" + (el.staticStyle) + ",";
                }
                if (el.styleBinding) {
                    data += "style:(" + (el.styleBinding) + "),";
                }
                return data
            }

            var style$1 = {
                staticKeys: ['staticStyle'],
                transformNode: transformNode$1,
                genData: genData$2
            };

            var modules$1 = [
                klass$1,
                style$1
            ];

            /*  */

            var warn$3;

            function model$1(el,
                             dir,
                             _warn) {
                warn$3 = _warn;
                var value = dir.value;
                var modifiers = dir.modifiers;
                var tag = el.tag;
                var type = el.attrsMap.type;
                if (process.env.NODE_ENV !== 'production') {
                    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];
                    if (tag === 'input' && dynamicType) {
                        warn$3(
                            "<input :type=\"" + dynamicType + "\" v-model=\"" + value + "\">:\n" +
                            "v-model does not support dynamic input types. Use v-if branches instead."
                        );
                    }
                }
                if (tag === 'select') {
                    genSelect(el, value, modifiers);
                } else if (tag === 'input' && type === 'checkbox') {
                    genCheckboxModel(el, value, modifiers);
                } else if (tag === 'input' && type === 'radio') {
                    genRadioModel(el, value, modifiers);
                } else {
                    genDefaultModel(el, value, modifiers);
                }
                // ensure runtime directive metadata
                return true
            }

            function genCheckboxModel(el,
                                      value,
                                      modifiers) {
                if (process.env.NODE_ENV !== 'production' &&
                    el.attrsMap.checked != null) {
                    warn$3(
                        "<" + (el.tag) + " v-model=\"" + value + "\" checked>:\n" +
                        "inline checked attributes will be ignored when using v-model. " +
                        'Declare initial values in the component\'s data option instead.'
                    );
                }
                var number = modifiers && modifiers.number;
                var valueBinding = getBindingAttr(el, 'value') || 'null';
                var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
                var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
                addProp(el, 'checked',
                    "Array.isArray(" + value + ")" +
                    "?_i(" + value + "," + valueBinding + ")>-1" + (
                        trueValueBinding === 'true'
                            ? (":(" + value + ")")
                            : (":_q(" + value + "," + trueValueBinding + ")")
                    )
                );
                addHandler(el, 'click',
                    "var $$a=" + value + "," +
                    '$$el=$event.target,' +
                    "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" +
                    'if(Array.isArray($$a)){' +
                    "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," +
                    '$$i=_i($$a,$$v);' +
                    "if($$c){$$i<0&&(" + value + "=$$a.concat($$v))}" +
                    "else{$$i>-1&&(" + value + "=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}" +
                    "}else{" + value + "=$$c}",
                    null, true
                );
            }

            function genRadioModel(el,
                                   value,
                                   modifiers) {
                if (process.env.NODE_ENV !== 'production' &&
                    el.attrsMap.checked != null) {
                    warn$3(
                        "<" + (el.tag) + " v-model=\"" + value + "\" checked>:\n" +
                        "inline checked attributes will be ignored when using v-model. " +
                        'Declare initial values in the component\'s data option instead.'
                    );
                }
                var number = modifiers && modifiers.number;
                var valueBinding = getBindingAttr(el, 'value') || 'null';
                valueBinding = number ? ("_n(" + valueBinding + ")") : valueBinding;
                addProp(el, 'checked', ("_q(" + value + "," + valueBinding + ")"));
                addHandler(el, 'click', genAssignmentCode(value, valueBinding), null, true);
            }

            function genDefaultModel(el,
                                     value,
                                     modifiers) {
                if (process.env.NODE_ENV !== 'production') {
                    if (el.tag === 'input' && el.attrsMap.value) {
                        warn$3(
                            "<" + (el.tag) + " v-model=\"" + value + "\" value=\"" + (el.attrsMap.value) + "\">:\n" +
                            'inline value attributes will be ignored when using v-model. ' +
                            'Declare initial values in the component\'s data option instead.'
                        );
                    }
                    if (el.tag === 'textarea' && el.children.length) {
                        warn$3(
                            "<textarea v-model=\"" + value + "\">:\n" +
                            'inline content inside <textarea> will be ignored when using v-model. ' +
                            'Declare initial values in the component\'s data option instead.'
                        );
                    }
                }

                var type = el.attrsMap.type;
                var ref = modifiers || {};
                var lazy = ref.lazy;
                var number = ref.number;
                var trim = ref.trim;
                var event = lazy || (isIE && type === 'range') ? 'change' : 'input';
                var needCompositionGuard = !lazy && type !== 'range';
                var isNative = el.tag === 'input' || el.tag === 'textarea';

                var valueExpression = isNative
                    ? ("$event.target.value" + (trim ? '.trim()' : ''))
                    : trim ? "(typeof $event === 'string' ? $event.trim() : $event)" : "$event";
                valueExpression = number || type === 'number'
                    ? ("_n(" + valueExpression + ")")
                    : valueExpression;

                var code = genAssignmentCode(value, valueExpression);
                if (isNative && needCompositionGuard) {
                    code = "if($event.target.composing)return;" + code;
                }

                // inputs with type="file" are read only and setting the input's
                // value will throw an error.
                if (process.env.NODE_ENV !== 'production' &&
                    type === 'file') {
                    warn$3(
                        "<" + (el.tag) + " v-model=\"" + value + "\" type=\"file\">:\n" +
                        "File inputs are read only. Use a v-on:change listener instead."
                    );
                }

                addProp(el, 'value', isNative ? ("_s(" + value + ")") : ("(" + value + ")"));
                addHandler(el, event, code, null, true);
                if (trim || number || type === 'number') {
                    addHandler(el, 'blur', '$forceUpdate()');
                }
            }

            function genSelect(el,
                               value,
                               modifiers) {
                if (process.env.NODE_ENV !== 'production') {
                    el.children.some(checkOptionWarning);
                }

                var number = modifiers && modifiers.number;
                var assignment = "Array.prototype.filter" +
                    ".call($event.target.options,function(o){return o.selected})" +
                    ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" +
                    "return " + (number ? '_n(val)' : 'val') + "})" +
                    (el.attrsMap.multiple == null ? '[0]' : '');

                var code = genAssignmentCode(value, assignment);
                addHandler(el, 'change', code, null, true);
            }

            function checkOptionWarning(option) {
                if (option.type === 1 &&
                    option.tag === 'option' &&
                    option.attrsMap.selected != null) {
                    warn$3(
                        "<select v-model=\"" + (option.parent.attrsMap['v-model']) + "\">:\n" +
                        'inline selected attributes on <option> will be ignored when using v-model. ' +
                        'Declare initial values in the component\'s data option instead.'
                    );
                    return true
                }
                return false
            }

            function genAssignmentCode(value, assignment) {
                var modelRs = parseModel(value);
                if (modelRs.idx === null) {
                    return (value + "=" + assignment)
                } else {
                    return "var $$exp = " + (modelRs.exp) + ", $$idx = " + (modelRs.idx) + ";" +
                        "if (!Array.isArray($$exp)){" +
                        value + "=" + assignment + "}" +
                        "else{$$exp.splice($$idx, 1, " + assignment + ")}"
                }
            }

            /*  */

            function text(el, dir) {
                if (dir.value) {
                    addProp(el, 'textContent', ("_s(" + (dir.value) + ")"));
                }
            }

            /*  */

            function html(el, dir) {
                if (dir.value) {
                    addProp(el, 'innerHTML', ("_s(" + (dir.value) + ")"));
                }
            }

            var directives$1 = {
                model: model$1,
                text: text,
                html: html
            };

            /*  */

            var cache = Object.create(null);

            var baseOptions = {
                expectHTML: true,
                modules: modules$1,
                staticKeys: genStaticKeys(modules$1),
                directives: directives$1,
                isReservedTag: isReservedTag,
                isUnaryTag: isUnaryTag,
                mustUseProp: mustUseProp,
                getTagNamespace: getTagNamespace,
                isPreTag: isPreTag
            };

            function compile$$1(template,
                                options) {
                options = options
                    ? extend(extend({}, baseOptions), options)
                    : baseOptions;
                return compile$1(template, options)
            }

            function compileToFunctions(template,
                                        options,
                                        vm) {
                var _warn = (options && options.warn) || warn;
                // detect possible CSP restriction
                /* istanbul ignore if */
                if (process.env.NODE_ENV !== 'production') {
                    try {
                        new Function('return 1');
                    } catch (e) {
                        if (e.toString().match(/unsafe-eval|CSP/)) {
                            _warn(
                                'It seems you are using the standalone build of Vue.js in an ' +
                                'environment with Content Security Policy that prohibits unsafe-eval. ' +
                                'The template compiler cannot work in this environment. Consider ' +
                                'relaxing the policy to allow unsafe-eval or pre-compiling your ' +
                                'templates into render functions.'
                            );
                        }
                    }
                }
                var key = options && options.delimiters
                    ? String(options.delimiters) + template
                    : template;
                if (cache[key]) {
                    return cache[key]
                }
                var res = {};
                var compiled = compile$$1(template, options);
                res.render = makeFunction(compiled.render);
                var l = compiled.staticRenderFns.length;
                res.staticRenderFns = new Array(l);
                for (var i = 0; i < l; i++) {
                    res.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i]);
                }
                if (process.env.NODE_ENV !== 'production') {
                    if (res.render === noop || res.staticRenderFns.some(function (fn) {
                            return fn === noop;
                        })) {
                        _warn(
                            "failed to compile template:\n\n" + template + "\n\n" +
                            detectErrors(compiled.ast).join('\n') +
                            '\n\n',
                            vm
                        );
                    }
                }
                return (cache[key] = res)
            }

            function makeFunction(code) {
                try {
                    return new Function(code)
                } catch (e) {
                    return noop
                }
            }

            /*  */

            var idToTemplate = cached(function (id) {
                var el = query(id);
                return el && el.innerHTML
            });

            var mount = Vue$3.prototype.$mount;
            Vue$3.prototype.$mount = function (el,
                                               hydrating) {
                el = el && query(el);

                /* istanbul ignore if */
                if (el === document.body || el === document.documentElement) {
                    process.env.NODE_ENV !== 'production' && warn(
                        "Do not mount Vue to <html> or <body> - mount to normal elements instead."
                    );
                    return this
                }

                var options = this.$options;
                // resolve template/el and convert to render function
                if (!options.render) {
                    var template = options.template;
                    if (template) {
                        if (typeof template === 'string') {
                            if (template.charAt(0) === '#') {
                                template = idToTemplate(template);
                                /* istanbul ignore if */
                                if (process.env.NODE_ENV !== 'production' && !template) {
                                    warn(
                                        ("Template element not found or is empty: " + (options.template)),
                                        this
                                    );
                                }
                            }
                        } else if (template.nodeType) {
                            template = template.innerHTML;
                        } else {
                            if (process.env.NODE_ENV !== 'production') {
                                warn('invalid template option:' + template, this);
                            }
                            return this
                        }
                    } else if (el) {
                        template = getOuterHTML(el);
                    }
                    if (template) {
                        var ref = compileToFunctions(template, {
                            warn: warn,
                            shouldDecodeNewlines: shouldDecodeNewlines,
                            delimiters: options.delimiters
                        }, this);
                        var render = ref.render;
                        var staticRenderFns = ref.staticRenderFns;
                        options.render = render;
                        options.staticRenderFns = staticRenderFns;
                    }
                }
                return mount.call(this, el, hydrating)
            };

            /**
             * Get outerHTML of elements, taking care
             * of SVG elements in IE as well.
             */
            function getOuterHTML(el) {
                if (el.outerHTML) {
                    return el.outerHTML
                } else {
                    var container = document.createElement('div');
                    container.appendChild(el.cloneNode(true));
                    return container.innerHTML
                }
            }

            Vue$3.compile = compileToFunctions;

            module.exports = Vue$3;

            /* WEBPACK VAR INJECTION */
        }.call(exports, __webpack_require__(114), __webpack_require__(109)))

        /***/
    },
    /* 117 */
    /***/ function (module, exports) {

        module.exports = function (module) {
            if (!module.webpackPolyfill) {
                module.deprecate = function () {
                };
                module.paths = [];
                // module.parent = undefined by default
                if (!module.children) module.children = [];
                Object.defineProperty(module, "loaded", {
                    enumerable: true,
                    configurable: false,
                    get: function () {
                        return module.l;
                    }
                });
                Object.defineProperty(module, "id", {
                    enumerable: true,
                    configurable: false,
                    get: function () {
                        return module.i;
                    }
                });
                module.webpackPolyfill = 1;
            }
            return module;
        }


        /***/
    },
    /* 118 */
    /***/ function (module, exports) {

        /* (ignored) */

        /***/
    },
    /* 119 */
    /***/ function (module, exports, __webpack_require__) {

        "use strict";
        'use strict';

        var _workflow = __webpack_require__(110);

        var _vueboot = __webpack_require__(112);

        var _veeValidate = __webpack_require__(111);

        var _veeValidate2 = _interopRequireDefault(_veeValidate);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {default: obj};
        }

        _workflow.WorkflowApp.use(_veeValidate2.default);

        new _workflow.WorkflowApp({
            el: '#content',
            components: {
                modal: _vueboot.modal
            },
            data: {
                eforms: {},
                eform_title: '',
                eform_description: ''
            },
            methods: {
                EShowModal: function EShowModal(modal) {
                    this.$refs[modal].showModal();
                },
                EHideModal: function EHideModal(modal) {
                    this.$refs[modal].hideModal();
                },
                eFormListModal: function eFormListModal(modal) {
                    var _this = this;

                    this.$http.get(api.eform.list).then(function (response) {
                        _this.eforms = response.body;
                    });

                    this.EShowModal(modal);
                },
                createEformModal: function createEformModal(modal, scope) {
                    this.eform_title = '';
                    this.eform_description = '';
                    this.errors.clear(scope);
                    this.EShowModal(modal);
                },
                createEform: function createEform(modal, scope) {
                    var _this2 = this;

                    var formData = {
                        project: api.project.id,
                        title: this.eform_title,
                        description: this.eform_description
                    };

                    this.$validator.validateAll(scope).then(function (success) {
                        if (success) {
                            _this2.$http.post(api.eform.create, formData).then(function (response) {
                                if (response.body['content'] === null) {
                                    response.body['content'] = '';
                                }

                                _this2.eforms.push(response.body);
                                PMDesigner.dynaformDesigner(response.body);
                                _this2.errors.clear(scope);
                                _this2.EHideModal(modal);
                            }, function (response) {
                                for (var r in response.body) {
                                    notify('', response.body[r], '', 'danger', 2000);
                                }
                            });
                        }
                    });
                },
                editEform: function editEform(id) {
                    this.$http.get('' + api.eform.edit + id + '/').then(function (response) {
                        if (response.body['content'] === null) {
                            response.body['content'] = '';
                        }

                        PMDesigner.dynaformDesigner(response.body);
                    });
                },
                deleteEform: function deleteEform(index, id) {
                    var _this3 = this;

                    this.$http.delete('' + api.eform.delete + id + '/').then(function (response) {
                        if (response.status == 204) {
                            _this3.eforms.splice(index, 1);
                            notify('', 'EForm deleted successfully', '', 'success', 2000);
                        }
                    });
                },
                openVariableModal: function openVariableModal() {
                    var pmvariables = new PMVariables();
                    pmvariables.load();
                }
            }
        });

        /***/
    }
    /******/]);